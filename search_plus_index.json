{"./":{"url":"./","title":"介绍","keywords":"","body":" 面试题目仓库 本仓库正在整理上传Java相关面试题目，题目正在逐步添加中。如发现题目问题或面试题目及相关文章推荐请留言。 在线查看：https://edu2act.github.io/interview/ 题目数量：384 知识点类型 题目数量 Java基础 语法 37 异常 7 集合 19 线程 19 IO流 5 Socket 1 JavaWeb Jsp&Servlet 19 JDBC 42 Hibernate 29 Mybatis 32 Spring 29 Android 基本常识 11 Activity 8 Service 7 BroadCastReceiver 3 ContentProvider 4 Intent 3 Layout 2 ListView 9 JNI&NDK 3 Fragment 2 多线程 1 网络访问 6 数据结构 0 设计模式 0 人事面试 70 相关文章 16 声明：本仓库部分图片、文章来源于网络，版权归原作者所有，如有侵权，请与我联系删除。 Everything you need to prepare for your technical interview.modified at 2019-02-19 "},"java_core/grammar.html":{"url":"java_core/grammar.html","title":"语法","keywords":"","body":"Java基础面试题：语法 面向对象的三大特性 封装 每个对象包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来进行自己的操作。将方法、属性、字段包装在类中，通过实例化类来生成对象。 封装就像建房子，类就是房子，属性是门窗，字段是房子里的东西，方法是人的行为。属性对字段有保护作用，防止字段被随意的修改或读取。 好的封装能减少耦合 类内部的实现可以自由修改 类具有清晰的对外接口 继承 继承代表一种is-a关系（子类is父类），是面向对象程序设计能够提高软件开发效率的重要原因之一。子类具有（继承）父类的所有特性，也可以定义自己独有的特性。 子类无法直接访问父类的private的属性和方法 子类可以扩展父类没有的属性和方法 子类可以重写父类的方法 继承是具有传递性的 继承来的属性和方法是隐式的 缺点：子类和父类具有强耦合性 多态 多态表示不同的对象可以执行相同的动作，但要通过他们自己的实现代码来执行。比如猫和狗继承自动物，猫叫和狗叫都是相同的动作-动物叫，但是实现方式不同。 子类可以以父类的身份出现 （使用父类对象的地方都可以用子类来代替） 子类在工作时以自己的方式来实现 子类以父类的身份出现时，子类特有的方法和属性不能使用 多态的作用是消除类型之间的耦合关系 多态就是对象拥有多种形态：引用多态和方法多态 引用多态：父类的引用可以指向本类对象、父类的引用可以指向子类的对象 方法多态：创建本类对象时，调用的方法为本类的方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法 存在多态的必要条件：继承、重写、向上转型 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 在Java中有两种形式可以实现多态。继承和接口 基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。 面向对象的四大特征 抽象 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象,二是数据抽象。 继承 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象,这些对象通过一个受保护的接口访问其他对象。 多态性 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 语句float f=3.4是否正确 不正确，编译不能通过；精度不准确，应该用强制类型转换。 如下所示： float f=(float)3.4; 语句short s1 = 1; s1 = s1 + 1;是否正确 short s1 = 1; s1 = s1 + 1; s1+1运算结果是int型，需要强制转换类型。 short s1 = 1; s1 += 1; 可以正确编译，自动类型提升。 Java有没有goto goto 是java 中的保留字，现在没有在java 中使用。 int和Integer有什么区别 Java 提供两种不同的类型：引用类型和原始类型（或内置类型）； int 是Java的原始数据类型，Integer 是Java为int提供的封装类。 Java 为每个原始类型提供了封装类： 原始类型 封装类型 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而原始类型实例变量的缺省值与它们的类型有关。 逻辑操作(&,|,^)与条件操作(&&,||)的区别 区别主要有两点： 条件操作只能操作布尔型的，而逻辑操作不仅可以操作布尔型，而且可以操作数值型 逻辑操作不会产生短路 Math的floor、round、ceil函数区别 floor 向下取整，返回不大于的最大整数 ceil 向上取整，则是不小于他的最小整数 round 四舍五入，入的时候是到大于它的整数（当-1.5时，四舍五入后得到的结果不是我们期待的，解决办法是先对他取绝对值，然后在用round方法） round方法，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。 正数小数点后大于5则进位；负数小数点后小于以及等于5都舍去，大于5的则进位。 如希望-11.5四舍五入结果为-12，则先对它取绝对值，然后在用round方法，再乘以-1。 示例 Math.floor Math.round Math.ceil 1.4 1 1 2 1.5 1 2 2 1.6 1 2 2 -1.4 -2 -1 -1 -1.5 -2 -1 -1 -1.6 -2 -2 -1 求2*8的最效率方法 2 有没有length()这个方法 数组没有length()这个方法，有length 的属性。 String 有length()这个方法。 swtich中表达式的类型 int、short、char 或者 byte可以出现在switch中的表达式里。 String类型在 JDK 1.7 之后可以出现在switch中的表达式里。 Java中如何跳出多重嵌套循环 在最外层循环前加 label 标识,然后用 break:label 方法即可跳出多重循环。 构造器Constructor 是否可被override 构造器Constructor 不能被继承，因此不能重写Overriding，但可以被重载Overloading。 x.equals(y) == true; hashcode是否相同 相同。 是否可以继承String 类 String 类是final 类，故不可以继承。 equals()和equalsIgnoreCase()的区别 equals()函数 主要是区分“比较的字符串” 大小写和长度时候相同，比较的类型可以是Object类型。 equalsIgnoreCase()函数 比较的参数只能是字符串，这里只要字符串的长度相等，字母的大小写是忽略的。认为A-Z和a-z是一样的。 值传递还是引用传递 问：当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 char型变量中能否存储一个中文汉字 能够定义成为一个中文的，因为Java 中以unicode 编码，一个char 占16个字节，所以放一个中文是没问题的。 abstract class和interface有什么区别 声明方法的存在而不去实现它的类被叫做抽象类（abstract class）。然而可以创建一个变量，其类型是一个抽象类，它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 接口（interface）是抽象类的变体。新型多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，所有成员变量都是publicstatic final 的。一个类可以实现多个接口，当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换， instanceof 运算符可以用来决定某对象的类是否实现了接口。 Static Nested Class和Inner Class的不同 Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。 而通常的内部类需要在外部类实例化后才能实例化。 Java中是否存在内存泄漏 内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。但是java中有垃圾回收机制，它能够将不再被使用的对象，自动从内存中清除。 即使这样，java中也存在着内存泄漏的情况： 一：当长生命周期的对象持有短生命周期的对象的引用，就很可能发生内存泄漏。尽管短生命周期的对象已经不再需要，但是长生命周期的对象一直持有它的引用导致其无法被回收。例如，缓存系统；加载一个对象放在缓存系统中，一直不去使用这个对象，但是它一直被缓存引用，所以不会被回收导致缓存泄漏。 检查java中的内存泄漏，一定要将程序各个分支情况都完成执行至结束，然后看其是否被使用过，如果没有才能判定这个对象属于内存泄漏。 二：当一个对象被存储进HashSet集合中，就不可修改这个对象中用于计算哈希值的属性了。否则，对象修改后的哈希值与刚添加进HashSet集合时的哈希值不一样，此时如果将当前对象的引用作为参数，用contains方法判断对象是否存在，则会返回找不到对象的结果。这会导致无法从HashSet单独删除当前对象，造成内存泄漏。 静态变量和实例变量的区别 静态变量也称为类变量，归全类共有，它不依赖于某个对象，可通过类名直接访问；而实例变量必须依存于某一实例，只能通过对象才能访问到它。 写clone()方法时通常都有一行代码，是什么 Clone 有缺省行为：super.clone();，它负责产生正确大小的空间，并逐位复制。 GC是什么,为什么要有GC GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。 Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() 。 垃圾回收的优点和原理 Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java 程序员在编写程序的时候不再需要考虑内存管理。 由于有垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。 垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 垃圾回收器的基本原理是什么 垃圾回收器的基本原理是什么？ 答：对于GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是\"可达的\"，哪些对象是\"不可达的\"。当GC 确定一些对象为\"不可达\"时，GC 就有责任回收这些内存空间。 垃圾回收器可以马上回收内存吗？ 答：可以。 有什么办法主动通知虚拟机进行垃圾回收？ 答：程序员可以手动执行System.gc()，通知GC 运行，但是Java 语言规范并不保证GC 一定会执行。 String s=new String(“xyz”);创建了几个String对象 两个对象，一个是\"xyx\",一个是指向\"xyx\"的引用对象s。 上面解释不够详细准确，准确解释可详读《String、StringBuffer、StringBuilder的区别》。 接口与抽象类的相互继承问题 接口是否可继承接口? 答：接口可以继承接口。 抽象类是否可实现(implements)接口? 答：抽象类可以实现(implements)接口。 抽象类是否可继承实体类(concrete class)? 答：抽象类可继承实体类，但前提是实体类必须有明确的构造函数。 Java的接口和C++的虚类的相同和不同处 由于Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static，所有方法默认情况下是public。一个类可以实现多个接口。 一个Java源文件中是否可以包含多个类（非内部类） 可以；必须只有一个类名与文件名相同。 内部类是否可以引用外部类的成员 一个内部类对象可以访问创建它的外部类对象的内容。 Java中实现多态的机制是什么 方法的覆盖Overriding 和重载Overloading 是 Java 多态性的不同表现。 覆盖Overriding 是父类与子类之间多态性的一种表现。 重载Overloading 是一个类中多态性的一种表现。 数据类型之间的转换 如何将数值型字符转换为数字？ 答：调用数值类型相应包装类中的方法parse*(String)或valueOf(String)即可返回相应基本类型或包装类型数值。 如何将数字转换为字符？ 答：将数字与空字符串相加即可获得其所对应的字符串;另外对于基本类型数字还可调用String 类中的valueOf(…)方法返回相应字符串,而对于包装类型数字则可调用其toString()方法获得相应字符串。 如何取小数点前两位并四舍五入? 答：可用该数字构造一java.math.BigDecimal 对象，再利用其round()方法进行四舍五入到保留小数点后两位，再将其转换为字符串截取最后两位。 如何实现字符串的反转及替换 可用字符串构造一StringBuffer 对象，然后调用StringBuffer 中的 reverse 方法即可实现字符串的反转，调用 replace 方法即可实现字符串的替换。 日期和时间 如何取得年月日、小时分秒？ 答：创建java.util.Calendar 实例(Calendar.getInstance())，,调用其get()方法传入不同的参数即可获得参数所对应的值，如： calendar.get(Calendar.YEAR); // 获得年 如何取得从1970 年到现在的毫秒数？ 答：以下方法均可获得该毫秒数: Calendar.getInstance().getTimeInMillis(); System.currentTimeMillis(); 如何取得某个日期是当月的最后一天？ 答：示例代码如下: Calendar time = Calendar.getInstance(); time.set(Calendar.DAY_OF_MONTH, time.getActualMaximum(Calendar.DAY_OF_MONTH)); 如何格式化日期？ 利用java.text.DataFormat 类中的format()方法可将日期格式化。 Java和JavaSciprt的区别 JavaScript 与Java 是两个公司开发的不同的两个产品。 Java 是SUN 公司推出的新一代面向对象的程序设计语言，特别适合于Internet 应用程序开发；而JavaScript 是Netscape 公司的产品，其目的是为了扩展Netscape Navigator功能,而开发的一种可以嵌入Web 页面中的基于对象和事件驱动的解释性语言,它的前身是Live Script；而Java 的前身是Oak 语言。 下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object Based）和事件驱动（Event Driver）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用； 解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行； 强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型； 代码格式不一样。 什么时候用assert assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion 用于保证程序最基本、关键的正确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion 检查通常是关闭的。 在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个Assertionerror。 断言用于调试目的： assert(a > 0); // throws an Assertionerror if a 断言可以有两种形式： assert Expression1 ; assert Expression1 : Expression2 ; Expression1 应该总是产生一个布尔值。 Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的String 消息。 断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记： javac -source 1.4 Test.java 要在运行时启用断言，可使用-enableassertions 或者-ea 标记。 要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。 要在系统类中启用断言，可使用-esa 或者-dsa 标记。 还可以在包的基础上启用或者禁用断言。 可以在预计正常情况下不会到达的任何位置上放置断言。 断言可以用于验证传递给私有方法的参数。 不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。 Everything you need to prepare for your technical interview.modified at 2019-01-29 "},"java_core/exception.html":{"url":"java_core/exception.html","title":"异常","keywords":"","body":"Java基础面试题：异常 Java中的异常处理机制的简单原理和应用 当Java 程序违反了Java 的语义规则时，Java 虚拟机就会将发生的错误表示为一个异常。 违反语义规则包括2 种情况。 一种是Java类库内置的语义检查。例如数组下标越界，会引发IndexOutOfBoundsException；访问null 的对象时会引发NullPointerException。 另一种情况就是Java允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw 关键字引发异常。 所有的异常都是java.lang.Thowable 的子类。 error和exception有什么区别 error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况。 exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 try里的return语句与finally代码的执行执行顺序 问：try {}里有一个return 语句，那么紧跟在这个try 后的finally {}里的code会不会被执行，什么时候被执行，在return 前还是后? 答：会执行，在return 前执行。 Java如何进行异常处理及相应关键字含义 JAVA 语言如何进行异常处理 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。 关键字throws,throw,try,catch,finally分别代表什么意义 Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws 和finally。 一般情况下是用try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。 try 用来指定一块预防所有“异常”的程序 catch 子句紧跟在try 块后面，用来指定你想要捕捉的“异常”的类型 throw 语句用来明确地抛出一个“异常” throws 用来标明一个成员函数可能抛出的各种“异常” finally 为确保一段代码不管发生什么“异常”都被执行一段代码 可以在一个成员函数调用的外面写一个try 语句，在这个成员函数内部写另一个try 语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到堆栈上面，直到所有的try 语句都完成。如果下一级的try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇到有处理这种“异常”的try 语句。 在try 块中可以抛出异常吗 可以。 运行时异常与一般异常有何异同 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。 Java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 常见的runtime exception 异常 说明 ArithmeticException 算术运算中，被0除或模除 ArrayIndexOutOfBoundsException 数组越界访问 ArrayStoreException 数据存储异常，写数组操作时，对象或数据类型不兼容 ClassCastException 类型转换异常 IllegalArgumentException 方法的参数无效 IllegalThreadStateException 试图非法改变线程状态，比方说试图启动一已经运行的线程 NullPointerException 试图访问一空对象的变量、方法或空数组的元素 NumberFormatException 数据格式异常，试图把一字符串非法转换成数值（或相反） SecurityException 如果Applet试图执行一被WWW浏览器安全设置所禁止的操作 IncompatibleClassChangeException 如改变了某一类定义，却没有重新编译其他引用了这个类的对象。如某一成员变量的声明被从静态改变为非静态，但其他引用了这个变量的类却没有重新编译，或者相反。如删除了类声明中的某一域或方法，但没有重新编译那些引用了这个域或方法的类 OutOfMemoryException 内存不足，通常发生于创建对象之时 NoClassDefFoundException JAVA运行时系统找不到所引用的类 IncompatibleTypeException 试图实例化一个接口，Java运行时系统将抛出这个异常 UnsatisfiedLinkException 如果所需调用的方法是C函数，但Java运行时系统却无法连接这个函数 InternalException 系统内部故障所导致的异常情况，可能是因为Java运行时系统本身的原因。如果发现一可重现的InternalException，可以直接给Sun公司发电邮java@java.Sun.com final、finally、finalize 的区别 final：修饰符（关键字）；如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承，因此一个类不能既被声明为abstract的，又被声明为final 的；将变量或方法声明为final，可以保证它们在使用中不被改变；被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改；被声明为final 的方法也同样只能使用，不能重载。 finally：再异常处理时提供finally 块来执行任何清除操作；如果抛出一个异常，那么相匹配的catch 子句就会执行，然后控制就会进入finally 块（如果有的话）。 finalize：方法名；Java 技术允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object 类中定义的，因此所有的类都继承了它。子类覆盖finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 Everything you need to prepare for your technical interview.modified at 2019-01-29 "},"java_core/collection.html":{"url":"java_core/collection.html","title":"集合","keywords":"","body":"Java基础面试题：集合 介绍Java中的Collection FrameWork 说说常见的集合有哪些 Map 接口和 Collection 接口是所有集合框架的父接口： Collection 接口的子接口包括：Set 接口和 List 接口； Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等； Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等； List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。 HashMap 和 Hashtable 的区别有哪些 HashMap 没有考虑同步，是线程不安全的；Hashtable 使用了 synchronized 关键字，是线程安全的； 前者允许 null 作为 Key；后者不允许 null 作为 Key。 HashMap 的底层实现你知道吗 在 Java8 之前，其底层实现是数组 + 链表实现，Java8 使用了数组 + 链表 + 红黑树实现。此时你可以简单的在纸上画图分析。 ConcurrentHashMap 和 Hashtable 的区别 ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。 HashMap 没有考虑同步，hashtable 考虑了同步的问题。但是 hashtable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如 get,put,remove 等常用操作只锁当前需要用到的桶。 ConcurrentHashMap 的具体实现知道吗 该类包含两个静态内部类 HashEntry 和 Segment；前者用来封装映射表的键值对，后者用来充当锁的角色； Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个 HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。 HashMap 的长度为什么是 2 的幂次方 通过将 Key 的 hash 值与 length-1 进行 & 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率； 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费； 如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大。 更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 List 和 Set 的区别是啥 List 元素是有序的，可以重复；Set 元素是无序的，不可以重复。 List、Set 和 Map 的初始容量和加载因子 List ArrayList 的初始容量是 10；加载因子为 0.5； 扩容增量：原容量的 0.5 倍 +1；一次扩容后长度为 16。 Vector 初始容量为 10，加载因子是 1。扩容增量：原容量的 1 倍，如 Vector 的容量为 10，一次扩容后是容量为 20。 Set HashSet，初始容量为 16，加载因子为 0.75； 扩容增量：原容量的 1 倍； 如 HashSet 的容量为 16，一次扩容后容量为 32 Map HashMap，初始容量 16，加载因子为 0.75； 扩容增量：原容量的 1 倍； 如 HashMap 的容量为 16，一次扩容后容量为 32 Comparable 接口和 Comparator 接口有什么区别 前者简单，但是如果需要重新定义比较类型时，需要修改源代码。 后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 Java 集合的快速失败机制 \"fail-fast\" 它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。 例如 ： 假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 原因： 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。 每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized； 使用 CopyOnWriteArrayList 来替换 ArrayList。 List、Set、Map是否继承自Collection接口 List,Set 是；Map 不是。 你所知道的集合类都有哪些 最常用的集合类是List 和Map。 List 的具体实现包括ArrayList 和Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。 ArrayList,Vector,LinkedList的存储性能和特性 ArrayList 和Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Collection和Collections的区别 Collection 是java.util 下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List。 Collections 是个java.util 下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 HashMap和Hashtable的区别 二者都实现了Map 接口，是将惟一键映射到特定的值上。 主要区别在于： HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许； HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey,因为contains 方法容易让人引起误解； Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现； Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。 Arraylist与Vector区别 就ArrayList 与Vector 主要从二方面来说： 同步性：Vector 是线程安全的（同步），而ArrayList 是线程序不安全的。 数据增长：当需要增长时，Vector 默认增长一倍，而ArrayList 却是一半。 List,Map,Set存取元素时各有什么特点 List 以特定次序来持有元素，可有重复元素。 Set 无法拥有重复元素,内部排序。 Map 保存key-value 值，value 可多值。 Set里元素用什么方法来区分重复 Set 里的元素是不能重复的，用equals()方法来区分重复与否。覆盖equals()方法用来判断对象的内容是否相同，而”==”判断地址是否相等，用来决定引用值是否指向同一对象。 Everything you need to prepare for your technical interview.modified at 2019-02-19 "},"java_core/thread.html":{"url":"java_core/thread.html","title":"线程","keywords":"","body":"Java基础面试题：线程 多线程和单线程的区别和联系 在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。 结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。 如何指定多个线程的执行顺序 面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？ 答： 设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。 在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。 线程和进程的区别 进程是一个\"执行中的程序\"，是系统进行资源分配和调度的一个独立单位； 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）； 线程上下文的切换比进程上下文切换要快很多。 进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。 多线程产生死锁的 4 个必要条件 互斥条件：一个资源每次只能被一个线程使用； 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺； 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 如何避免死锁？ 指定获取锁的顺序，举例如下： 比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？ 获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！ synchronized关键字 底层实现： 进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1； 当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。 含义：（monitor 机制） Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。 该关键字是一个几种锁的封装。 volatile关键字 解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。 答：该关键字可以保证可见性不保证原子性。 功能： 主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性； 禁止 JVM 进行的指令重排序。 ThreadLocal（线程局部变量）关键字 当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。 ThreadLocal 内部实现机制： 每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程； Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系； Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。 Atomic 关键字 可以使基本数据类型以原子的方式实现自增自减等操作。 线程池有了解吗 java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态： 当前线程池大小 ：表示线程池中实际工作者线程的数量； 最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限； 核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队； 如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程； 如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。 sleep()和wait()有什么区别 sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep 不会释放对象锁。 wait 是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。 请说出你所知道的线程同步的方法 wait() : 使一个线程处于等待状态，并且释放所持有的对象的lock； sleep() : 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常； notify() : 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM 确定唤醒哪个线程，而且不是按优先级； notityAll() : 唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 多线程和同步分别有几种实现方法 多线程有两种实现方法，分别是继承Thread 类与实现Runnable 接口。 同步的实现方面有两种，分别是synchronized,wait 与notify。 同步和异步有何异同以及在何种情况下使用 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 启动一个线程是用run()还是start() 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 线程的基本概念、线程的基本状态以及状态之间的关系 线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身；Java 中的线程有四种状态分别是：运行、就绪、挂起、结束。 简述synchronized和java.util.concurrent.locks.Lock的异同 主要相同点：Lock 能完成synchronized 所实现的所有功能； 主要不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally 从句中释放。 Java中有几种方法可以实现一个线程 有两种实现方法，分别是继承Thread 类与实现Runnable 接口。 stop()和suspend()方法为何不推荐使用 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在； suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。故不应该使用suspend()，而应在自己的Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。 Everything you need to prepare for your technical interview.modified at 2019-02-19 "},"java_core/io.html":{"url":"java_core/io.html","title":"IO流","keywords":"","body":"Java基础面试题：IO流 如何实现Java序列化 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；序列化的实现：将需要被序列化的类实现Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream 对象的writeObject(Object obj)方法就可以将参数为obj 的对象写出(即保存其状态)，要恢复的话则用输入流。 Java中有几种类型的流，以及对应的抽象类 字节流，字符流。 字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。 文件和目录（IO）操作 如何列出某个目录下的所有文件？ File file = new File(\"e:\\\\总结\"); File[] files = file.listFiles(); for(int i=0; i 如何列出某个目录下的所有子目录？ File file = new File(\"e:\\\\总结\"); File[] files = file.listFiles(); for(int i=0; i 如何判断一个文件或目录是否存在？ 创建File 对象，调用其exsit()方法即可返回是否存在，如： System.out.println(new File(\"d:\\\\t.txt\").exists()); 如何读写文件 读文件: FileInputStream fin = new FileInputStream(\"e:\\\\tt.txt\"); byte[] bs = new byte[100]; while(true){ int len = fin.read(bs); if(len 写文件: FileWriter fw = new FileWriter(\"e:\\\\test.txt\"); fw.write(\"hello world!\" + System.getProperty(\"line.separator\")); fw.write(\"你好！北京！\"); fw.close(); 统计字符串在文件中出现的次数 public int countWords(String file, String find) throws Exception { int count = 0; Reader in = new FileReader(file); int c; while ((c = in.read()) != -1) { while (c == find.charAt(0)) { for (int i = 1; i Everything you need to prepare for your technical interview.modified at 2019-01-29 "},"java_core/socket.html":{"url":"java_core/socket.html","title":"Socket","keywords":"","body":"Java基础面试题：Socket 使用Socket读取服务器字符并本地显示 Server 端程序 package test; import java.net.*; import java.io.*; public class Server{ private ServerSocket ss; private Socket socket; private BufferedReader in; private PrintWriter out; public Server(){ try { ss=new ServerSocket(10000); while(true){ socket = ss.accept(); String RemoteIP = socket.getInetAddress().getHostAddress(); String RemotePort = \":\"+socket.getLocalPort(); System.out.println(\"A client come in!IP:\" + RemoteIP+RemotePort); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = in.readLine(); System.out.println(\"Cleint send is :\" + line); out = new PrintWriter(socket.getOutputStream(),true); out.println(\"Your Message Received!\"); out.close(); in.close(); socket.close(); } } catch (IOException e){ out.println(\"wrong\"); } } public static void main(String[] args){ new Server(); } } Client 端程序 package test; import java.io.*; import java.net.*; public class Client { Socket socket; BufferedReader in; PrintWriter out; public Client(){ try { System.out.println(\"Try to Connect to 127.0.0.1:10000\"); socket = new Socket(\"127.0.0.1\",10000); System.out.println(\"The Server Connected!\"); System.out.println(\"Please enter some Character:\"); BufferedReader line = new BufferedReader(new InputStreamReader(System.in)); out = new PrintWriter(socket.getOutputStream(),true); out.println(line.readLine()); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(in.readLine()); out.close(); in.close(); socket.close(); } catch(IOException e) { out.println(\"Wrong\"); } } public static void main(String[] args) { new Client(); } } Everything you need to prepare for your technical interview.modified at 2019-01-29 "},"java_web/jsp_servlet.html":{"url":"java_web/jsp_servlet.html","title":"Jsp&Servlet","keywords":"","body":"JavaWeb面试题：JSP&Servlet 说出Servlet 的生命周期，并说出Servlet 和CGI 的区别 Web 容器加载Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其init 方法进行Servlet 的初始化，请求到达时运行其service 方法，service方法自动派遣运行与请求对应的doXXX 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy 方法。与cgi 的区别在于servlet 处于服务器进程中，它通过多线程方式运行其service 方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。 forward 和redirect 的区别 forward 是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 redirect 就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request 参数都可以获取，并且从浏览器的地址栏中可以看到跳转后的链接地址。 前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接；在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。 JSP 中动态INCLUDE与静态INCLUDE的区别 动态INCLUDE 用jsp:include 动作实现它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。 静态INCLUDE 用include 伪码实现,它不会检查所含文件的变化，适用于包含静态页面。 说出数据连接池的工作机制是什么 J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 JSP的内置对象及方法 request 表示HttpServletRequest 对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header 和session 数据的有用的方法。 response 表示HttpServletResponse 对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）。 out 对象是javax.jsp.JspWriter 的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 pageContext 表示一个javax.servlet.jsp.PageContext 对象。它是用于方便存取各种范围的名字空间、servlet 相关的对象的API，并且包装了通用的servlet 相关功能的方法。 session 表示一个请求的javax.servlet.http.HttpSession 对象。Session可以存贮用户的状态信息。 application 表示一个javax.servle.ServletContext 对象。这有助于查找有关servlet 引擎和servlet 环境的信息。 config 表示一个javax.servlet.ServletConfig 对象。该对象用于存取servlet 实例的初始化参数。page 表示从该页面产生的一个servlet 实例。 JSP有哪些动作，作用分别是什么 JSP 共有以下6 种基本动作： jsp:include：在页面被请求的时候引入一个文件； jsp:useBean：寻找或者实例化一个JavaBean。； jsp:setProperty：设置JavaBean 的属性。； jsp:getProperty：输出某个JavaBean 的属性； jsp:forward：把请求转到一个新的页面； jsp:plugin：根据浏览器类型为Java 插件生成OBJECT 或EMBED 标记。 JSP有哪些内置对象，作用分别是什么 JSP 共有以下9 种基本内置组件（可与ASP 的6 种内部组件相对应）： request：用户端请求，此请求会包含来自GET/POST 请求的参数； response：网页传回用户端的回应； pageContext：网页的属性是在这里管理； session：与请求有关的会话期； application：servlet 正在执行的内容； out：用来传送回应的输出； config：servlet 的构架部件； page：JSP 网页本身； exception：针对错误网页，未捕捉的例外。 get和post的区别 Form 中的get 和post 方法，在数据传输过程中分别对应了HTTP 协议中的GET 和POST 方法。二者主要区别如下： Get 是用来从服务器上获得数据，而Post 是用来向服务器上传递数据； Get 将表单中数据按照variable=value 的形式，添加到action 所指向的URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post 是将表单中的数据放在form 的数据体中，按照变量和值相对应的方式，传递到action所指向URL； Get 是不安全的，因为在传输过程，数据被放在请求的URL 中；Post 的所有操作对用户来说都是不可见的； Get 传输的数据量小，这主要是因为受URL 长度限制；而Post 可以传输大量的数据，所以在上传文件只能使用Post； Get 限制Form 表单的数据集必须为ASCII 字符，而Post 支持整个ISO10646字符集； Get 是Form 的默认方法。 什么情况下调用doGet()和doPost() JSP 页面中的form 标签里的method 属性为get 时调用doGet()，为post时调用doPost()。 如何从form表单中得取checkbox的值 可在页面把checkbox 的name 属性取同一个，value 属性取每个条目的id,后台用getParamter(“name”)能取到checkbox 的一组值。 JSP和Servlet有哪些相同点和不同点 JSP 是Servlet 技术的扩展，本质上是Servlet 的简易方式，更强调应用的外表表达。JSP 编译后是\"类servlet\"。Servlet 和JSP 最主要的不同点在于，Servlet 的应用逻辑是在Java 文件中，并且完全从表示层中的HTML 里分离开来。而JSP 的情况是Java 和HTML 可以组合成一个扩展名为.jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。 JSP的四种范围 JSP有四种范围，可以说是四种对象，这四种对象对应不同的作用范围，所以我们说JSP中的四种范围，这四种范围作用域由大到小分别是 page>request>session>application。 利用这四个对象最常用的就是传值，在一个地方设置值，在另一个地方获取值。 这四种范围除了page用pageContext来设置和获取，其它都可以用本对象名来设置和获取。 page：pageContext.setAttribute(\"key\",\"value\")设置变量，pageContext.getAttribute(\"key\",\"value\")获取变量 request：request.setAttribute(\"key\",\"value\")设置变量，request.getAttribute(\"key\",\"value\")获取变量 session：session.setAttribute(\"key\",\"value\")设置变量，session.getAttribute(\"key\",\"value\")获取变量 application：application.setAttribute(\"key\",\"value\")设置变量，application.getAttribute(\"key\",\"value\")获取变量 page： page代表的是当前页面，所以他的范围只是当前页面，在jsp经过编译后的java代码文件中有这么一句，也就是说在jsp页面中this代表的就是page当前页面，一个jsp中有一个page，所以不能通过page在不同页面中传值。 request： request的范围是一次请求，在不同的页面之间可以用request来传值，条件是不可以用重定向，必须要用转发，转发和重定向的区别是：转发在服务器端进行不和用户的客户端发生交互，在服务器的两个页面之间执行转发，用户的浏览器上的网址不发生改变，而重定向是服务器返回给客户端的浏览器，通过浏览器再向服务器发送一次请求，等于和客户端发生了一次交互，浏览器上的网址发生改变。重定向和转发对应的是分贝对应的是两次请求和一次请求。通过实现两个页面之间的转发。 session： session 代表的范围是一次会话，用户初次访问的时候，产生一次会话，当时间超时或者关闭当前会话的时候（关闭当前浏览器，再打开一个浏览器），session失效，在当前会话期间，所有的页面之间是共享的。 application： application 作用域最大，可以理解为一个全局变量，创建之后，只要服务器开启就一直有效，直到服务器关闭。在所有的页面之间共享，即使是再次打开浏览器。所以在程序中不宜创建过多的application，会带来资源上的消耗。 Request对象的主要方法 方法 说明 setAttribute(String name,Object) 设置名字为name 的属性值 getAttribute(String name) 返回由name 指定的属性值 getAttributeNames() 返回request 对象所有属性的名字集合(枚举) getCookies() 返回客户端的所有Cookie 对象，结果是一个Cookie 数组 getCharacterEncoding() 返回请求中的字符编码方式 getContentLength() 返回请求的Body 的长度 getHeader(String name) 获得HTTP 协议定义的文件头信息 getHeaders(String name) 返回指定名的request Header 的所有值(枚举) getHeaderNames() 返回所有request Header 的名字(枚举) getInputStream() 返回请求的输入流，用于获得请求中的数据 getMethod() 获得客户端向服务器端传送数据的方法 getParameter(String name) 获得客户端请求中传送的name 指定的参数值 getParameterNames() 获得客户端传送给服务器端的所有参数的名字(枚举) getParameterValues(String name) 获得有name 指定的参数的所有值 getProtocol() 获取客户端向服务器端传送数据所依据的协议名称 getQueryString() 获得查询字符串 getRequestURI() 获取发出请求字符串的客户端地址 getRemoteAddr() 获取客户端的IP 地址 getRemoteHost() 获取客户端的名字 getSession([Boolean create]) 返回和请求相关Session getServerName() 获取服务器的名字 getServletPath() 获取客户端所请求的脚本文件的路径 getServerPort() 获取服务器的端口号 removeAttribute(String name) 删除请求中的一个属性 Servlet执行时一般实现哪几个方法 public void init(ServletConfig config) public ServletConfig getServletConfig() public String getServletInfo() public void service(ServletRequest request,ServletResponse response) public void destroy() BS与CS的联系与区别 C/S 是Client/Server 的缩写，是客户机与服务器结构的应用程序，服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix 或SQL Server。客户端需要安装专用的客户端软件。B/Ｓ是Brower/Server 的缩写，是浏览器和服务器结构的应用程序，即Web 应用程序，客户机上只要安装一个浏览器（Browser），如Netscape Navigator 或InternetExplorer，服务器安装Oracle、Sybase、Informix 或SQL Server 等数据库。在这种结构下，用户界面完全通过WWW 浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。 硬件环境不同 C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务；B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S 更强的适应范围, 一般只要有操作系统和浏览器就行。 对安全要求不同 C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S 发布部分可公开信息；B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。 对程序架构不同 C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑；B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上.比C/S 有更高的要求B/S 结构的程序架构是发展的趋势, 从MS 的.Net 系列的BizTalk 2000 Exchange 2000 等, 全面支持网络的构件搭建的系统. SUN 和IBM 推的JavaBean 构件技术等,使B/S 更加成熟。 软件重用不同 C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S 要求下的构件的重用性好；B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子。 系统维护不同 C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统；B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级。 处理问题不同 C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统；B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S 无法作到的. 与操作系统平台关系最小。 用户接口不同 C/S 多是建立的Window 平台上,表现方法有限,对程序员普遍要求较高；B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本。 信息流不同 C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低；B/S 信息流向可变化, B-B B-C B-G 等信息、流向的变化, 更像交易中心。 过滤器有哪些作用 可以验证客户是否来自可信的网络，可以对客户提交的数据进行重新编码，可以从系统里获得配置的信息，可以过滤掉客户的某些不应该出现的词汇，可以验证用户是否登录，可以验证客户的浏览器是否支持当前的应用，可以记录系统的日志等等。 在JSP中如何使用JavaBeans 在JSP 中使用JavaBean 常用的动作有： ：用来创建和查找bean 对象； ：用来设置bean 的属性，即调用其setXxx()方法； ：用来获得bean 的属性，即调用其getXxx()方法。 JSP和Servlet中的请求转发分别如何实现 JSP 中的请求转发可利用forward 动作实现：； Serlvet 中实现请求转发的方式为： getServletContext().getRequestDispatcher(path).forward(req,res)。 JSP标签的作用及如何定义 作用： 分离JSP页面的内容和逻辑； 业务逻辑开发者可以创建自定义标签； 封装业务逻辑； 可重用并且易维护； 易于手工修改、易于工具维护； 提供简洁的语法； 定义: 写标签处理器； 写tld 文件； 讲标签处理器和tld 文件放到同一个包里面； 把JSP页面和标签库配置部署在一起。 Everything you need to prepare for your technical interview.modified at 2019-01-28 "},"java_web/jdbc.html":{"url":"java_web/jdbc.html","title":"JDBC","keywords":"","body":"JavaWeb面试题：JDBC 什么是JDBC，在什么时候会用到它 JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。 JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。 有哪些不同类型的JDBC驱动 有四类JDBC驱动。和数据库进行交互的Java程序分成两个部分，一部分是JDBC的API，实际工作的驱动则是另一部分。 JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。 Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。 Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。 Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。 JDBC是如何实现Java程序和JDBC驱动的松耦合的 JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现。 这是Java核心库里反射机制的最佳实践之一，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。在这里可以看到更多JDBC的使用示例。 什么是JDBC连接，在Java中如何创建一个JDBC连接 JDBC连接是和数据库服务器建立的一个会话。你可以想像成是一个和数据库的Socket连接。 创建JDBC连接很简单，只需要两步： 注册并加载驱动：使用Class.forName()，驱动类就会注册到DriverManager里面并加载到内存里。 用DriverManager获取连接对象：调用DriverManager.getConnnection()方法并传入数据库连接的URL，用户名及密码，就能获取到连接对象。 Connection con = null; try{ // load the Driver Class Class.forName(\"com.mysql.jdbc.Driver\"); // create the connection now con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/DBName\", \"username\", \"password\"); }catch (SQLException e) { System.out.println(\"Check database is UP and configs are correct\"); e.printStackTrace(); }catch (ClassNotFoundException e) { System.out.println(\"Please include JDBC MySQL jar in classpath\"); e.printStackTrace(); } } JDBC的DriverManager是用来做什么的 JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，你可以看下JDBC Driver类的源码来了解一下。 然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。 在Java程序中如何获取数据库服务器的相关信息 使用DatabaseMetaData可以获取到服务器的信息。当和数据库的连接成功建立了之后，可以通过调用getMetaData()方法来获取数据库的元信息。DatabaseMetaData里面有很多方法，通过它们可以获取到数据库的产品名称，版本号，配置信息等。 DatabaseMetaData metaData = con.getMetaData(); String dbProduct = metaData.getDatabaseProductName(); JDBC的Statement是什么 Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法我们可以生成一个Statement对象。我们可以通过调用它的execute()，executeQuery()，executeUpdate()方法来执行静态SQL查询。 由于SQL语句是程序中传入的，如果没有对用户输入进行校验的话可能会引起SQL注入的问题，如果想了解更多关于SQL注入的，可以看下这里。 默认情况下，一个Statement同时只能打开一个ResultSet。如果想操作多个ResultSet对象的话，需要创建多个Statement。Statement接口的所有execute方法开始执行时都默认会关闭当前打开的ResultSet。 execute，executeQuery，executeUpdate的区别是什么 Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。 Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。 Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。 只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。 JDBC的PreparedStatement是什么 PreparedStatement对象代表的是一个预编译的SQL语句。用它提供的setter方法可以传入查询的变量。 由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。由于PreparedStatement自动对特殊字符转义，避免了SQL注入攻击，因此应当尽量的使用它。 PreparedStatement中如何注入NULL值 可以使用它的setNull方法来把null值绑定到指定的变量上。setNull方法需要传入参数的索引以及SQL字段的类型，像这样： ps.setNull(10, java.sql.Types.INTEGER); Statement中的getGeneratedKeys方法有什么用 有的时候表会生成主键，这时候就可以用Statement的getGeneratedKeys()方法来获取这个自动生成的主键的值了。 相对于Statement，PreparedStatement的优点是什么 它和Statement相比优点在于： PreparedStatement有助于防止SQL注入，因为它会自动对特殊字符转义。 PreparedStatement可以用来进行动态查询。 PreparedStatement执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。 使用PreparedStatement的setter方法更容易写出面向对象的代码，而Statement的话，我们得拼接字符串来生成查询语句。如果参数太多了，字符串拼接看起来会非常丑陋并且容易出错。 PreparedStatement的缺点是什么，怎么解决 PreparedStatement的一个缺点是，我们不能直接用它来执行in条件语句；需要执行IN条件语句的话，下面有一些解决方案： 分别进行单条查询——这样做性能很差，不推荐。 使用存储过程——这取决于数据库的实现，不是所有数据库都支持。 动态生成PreparedStatement——这是个好办法，但是不能享受PreparedStatement的缓存带来的好处了。 在PreparedStatement查询中使用NULL值——如果你知道输入变量的最大个数的话，这是个不错的办法，扩展一下还可以支持无限参数。 JDBC的ResultSet是什么 在查询数据库后会返回一个ResultSet，它就像是查询结果集的一张数据表。 ResultSet对象维护了一个游标，指向当前的数据行。开始的时候这个游标指向的是第一行。如果调用了ResultSet的next()方法游标会下移一行，如果没有更多的数据了，next()方法会返回false。可以在for循环中用它来遍历数据集。 默认的ResultSet是不能更新的，游标也只能往下移。也就是说你只能从第一行到最后一行遍历一遍。不过也可以创建可以回滚或者可更新的ResultSet，像下面这样。 Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); 当生成ResultSet的Statement对象要关闭或者重新执行或是获取下一个ResultSet的时候，ResultSet对象也会自动关闭。 可以通过ResultSet的getter方法，传入列名或者从1开始的序号来获取列数据。 有哪些不同的ResultSet 根据创建Statement时输入参数的不同，会对应不同类型的ResultSet。如果你看下Connection的方法，你会发现createStatement和prepareStatement方法重载了，以支持不同的ResultSet和并发类型。 一共有三种ResultSet对象。 ResultSet.TYPE_FORWARD_ONLY：这是默认的类型，它的游标只能往下移。 ResultSet.TYPE_SCROLL_INSENSITIVE：游标可以上下移动，一旦它创建后，数据库里的数据再发生修改，对它来说是透明的。 ResultSet.TYPE_SCROLL_SENSITIVE：游标可以上下移动，如果生成后数据库还发生了修改操作，它是能够感知到的。 ResultSet有两种并发类型。 ResultSet.CONCUR_READ_ONLY:ResultSet是只读的，这是默认类型。 ResultSet.CONCUR_UPDATABLE:我们可以使用ResultSet的更新方法来更新里面的数据。 Statement中的setFetchSize和setMaxRows方法有什么用处 setMaxRows可以用来限制返回的数据集的行数。当然通过SQL语句也可以实现这个功能。比如在MySQL中我们可以用LIMIT条件来设置返回结果的最大行数。 setFetchSize理解起来就有点费劲了，因为你得知道Statement和ResultSet是怎么工作的。当数据库在执行一条查询语句时，查询到的数据是在数据库的缓存中维护的。ResultSet其实引用的是数据库中缓存的结果。 假设我们有一条查询返回了100行数据，我们把fetchSize设置成了10，那么数据库驱动每次只会取10条数据，也就是说得取10次。当每条数据需要处理的时间比较长的时候并且返回数据又非常多的时候，这个可选的参数就变得非常有用了。 我们可以通过Statement来设置fetchSize参数，不过它会被ResultSet对象设置进来的值所覆盖掉。 如何使用JDBC接口来调用存储过程 存储过程就是数据库编译好的一组SQL语句，可以通过JDBC接口来进行调用。我们可以通过JDBC的CallableStatement接口来在数据库中执行存储过程。初始化CallableStatement的语法是这样的： CallableStatement stmt = con.prepareCall(\"{call insertEmployee(?,?,?,?,?,?)}\"); stmt.setInt(1, id); stmt.setString(2, name); stmt.setString(3, role); stmt.setString(4, city); stmt.setString(5, country); //register the OUT parameter before calling the stored procedure stmt.registerOutParameter(6, java.sql.Types.VARCHAR); stmt.executeUpdate(); 我们得在执行CallableStatement之前注册OUT参数。 JDBC的批处理是什么，有什么好处 有时候类似的查询我们需要执行很多遍，比如从CSV文件中加载数据到关系型数据库的表里。我们也知道，执行查询可以用Statement或者PreparedStatement。除此之外，JDBC还提供了批处理的特性，有了它，我们可以在一次数据库调用中执行多条查询语句。 JDBC通过Statement和PreparedStatement中的addBatch和executeBatch方法来支持批处理。 批处理比一条条语句执行的速度要快得多，因为它需要很少的数据库调用。 JDBC的事务管理是什么，为什么需要它 默认情况下，我们创建的数据库连接，是工作在自动提交的模式下的。这意味着只要我们执行完一条查询语句，就会自动进行提交。因此我们的每条查询，实际上都是一个事务，如果我们执行的是DML或者DDL，每条语句完成的时候，数据库就已经完成修改了。 有的时候我们希望由一组SQL查询组成一个事务，如果它们都执行OK我们再进行提交，如果中途出现异常了，我们可以进行回滚。 JDBC接口提供了一个setAutoCommit(boolean flag)方法，我们可以用它来关闭连接自动提交的特性。我们应该在需要手动提交时才关闭这个特性，不然的话事务不会自动提交，每次都得手动提交。数据库通过表锁来管理事务，这个操作非常消耗资源。因此我们应当完成操作后尽快的提交事务。在这里有更多关于事务的示例程序。 如何回滚事务 通过Connection对象的rollback方法可以回滚事务。它会回滚这次事务中的所有修改操作，并释放当前连接所持有的数据库锁。 JDBC的保存点(Savepoint)是什么，如何使用 有时候事务包含了一组语句，而我们希望回滚到这个事务的某个特定的点。JDBC的保存点可以用来生成事务的一个检查点，使得事务可以回滚到这个检查点。 一旦事务提交或者回滚了，它生成的任何保存点都会自动释放并失效。回滚事务到某个特定的保存点后，这个保存点后所有其它的保存点会自动释放并且失效。可以读下这个了解更多关于JDBC Savepoint的信息。 JDBC的DataSource是什么，有什么好处 DataSource即数据源，它是定义在javax.sql中的一个接口，跟DriverManager相比，它的功能要更强大。我们可以用它来创建数据库连接，当然驱动的实现类会实际去完成这个工作。除了能创建连接外，它还提供了如下的特性： 缓存PreparedStatement以便更快的执行 可以设置连接超时时间 提供日志记录的功能 ResultSet大小的最大阈值设置 通过JNDI的支持，可以为servlet容器提供连接池的功能 如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池 对部署在servlet容器中的WEB程序而言，创建数据库连接池非常简单，仅需要以下几步。 在容器的配置文件中创建JDBC的JNDI资源，通常在server.xml或者context.xml里面。 在WEB应用程序中，先用InitialContext来查找JNDI资源，然后获取连接。 Context ctx = new InitialContext(); DataSource ds = (DataSource) ctx.lookup(\"java:/comp/env/jdbc/MyLocalDB\"); Apache的DBCP是什么 如果用DataSource来获取连接的话，通常获取连接的代码和驱动特定的DataSource是紧耦合的。另外，除了选择DataSource的实现类，剩下的代码基本都是一样的。 Apache的DBCP就是用来解决这些问题的，它提供的DataSource实现成为了应用程序和不同JDBC驱动间的一个抽象层。Apache的DBCP库依赖commons-pool库，所以要确保它们都在部署路径下。 什么是数据库的隔离级别 当我们为了数据的一致性使用事务时，数据库系统用锁来防止别人访问事务中用到的数据。数据库通过锁来防止脏读，不可重复读(Non-Repeatable Reads)及幻读（Phantom-Read）的问题。 数据库使用JDBC设置的隔离级别来决定它使用何种锁机制，我们可以通过Connection的getTransactionIsolation和setTransactionIsolation方法来获取和设置数据库的隔离级别。 隔离级别 事务 脏读 不可重复读 幻读 TRANSACTION_NONE 不支持 不可用 不可用 不可用 TRANSACTION_READ_COMMITTED 支持 阻止 允许 允许 TRANSACTION_READ_UNCOMMITTED 支持 允许 允许 允许 TRANSACTION_REPEATABLE_READ 支持 阻止 阻止 允许 TRANSACTION_SERIALIZABLE 支持 阻止 阻止 阻止 JDBC的RowSet是什么，有哪些不同的RowSet RowSet用于存储查询的数据结果，和ResultSet相比，它更具灵活性。RowSet继承自ResultSet，因此ResultSet能干的，它们也能，而ResultSet做不到的，它们还是可以。RowSet接口定义在javax.sql包里。 RowSet提供的额外的特性有： 提供了Java Bean的功能，可以通过settter和getter方法来设置和获取属性。RowSet使用了JavaBean的事件驱动模型，它可以给注册的组件发送事件通知，比如游标的移动，行的增删改，以及RowSet内容的修改等。 RowSet对象默认是可滚动，可更新的，因此如果数据库系统不支持ResultSet实现类似的功能，可以使用RowSet来实现。 RowSet分为两大类： A. 连接型RowSet——这类对象与数据库进行连接，和ResultSet很类似。JDBC接口只提供了一种连接型RowSet，javax.sql.rowset.JdbcRowSet，它的标准实现是com.sun.rowset.JdbcRowSetImpl。 B. 离线型RowSet——这类对象不需要和数据库进行连接，因此它们更轻量级，更容易序列化。它们适用于在网络间传递数据。 有四种不同的离线型RowSet的实现。 CachedRowSet——可以通过他们获取连接，执行查询并读取ResultSet的数据到RowSet里。我们可以在离线时对数据进行维护和更新，然后重新连接到数据库里，并回写改动的数据。 WebRowSet继承自CachedRowSet——他可以读写XML文档。 JoinRowSet继承自WebRowSet——它不用连接数据库就可以执行SQL的join操作。 FilteredRowSet继承自WebRowSet——我们可以用它来设置过滤规则，这样只有选中的数据才可见。 RowSet和ResultSet的区别是什么 RowSet继承自ResultSet，因此它有ResultSet的全部功能，同时它自己添加了些额外的特性。RowSet一个最大的好处是它可以是离线的，这样使得它更轻量级，同时便于在网络间进行传输。 具体使用哪个取决于你的需求，不过如果你操作ResultSet对象的时间较长的话，最好选择一个离线的RowSet，这样可以释放数据库连接。 常见的JDBC异常有哪些 有以下这些： java.sql.SQLException——这是JDBC异常的基类。 java.sql.BatchUpdateException——当批处理操作执行失败的时候可能会抛出这个异常。这取决于具体的JDBC驱动的实现，它也可能直接抛出基类异常java.sql.SQLException。 java.sql.SQLWarning——SQL操作出现的警告信息。 java.sql.DataTruncation——字段值由于某些非正常原因被截断了（不是因为超过对应字段类型的长度限制）。 JDBC里的CLOB和BLOB数据类型分别代表什么 CLOB意思是Character Large OBjects，字符大对象，它是由单字节字符组成的字符串数据，有自己专门的代码页。这种数据类型适用于存储超长的文本信息，那些可能会超出标准的VARCHAR数据类型长度限制（上限是32KB）的文本。 BLOB是Binary Larget OBject，它是二进制大对象，由二进制数据组成，没有专门的代码页。它能用于存储超过VARBINARY限制（32KB）的二进制数据。这种数据类型适合存储图片，声音，图形，或者其它业务程序特定的数据。 JDBC的脏读是什么，哪种数据库隔离级别能防止脏读 当我们使用事务时，有可能会出现这样的情况，有一行数据刚更新，与此同时另一个查询读到了这个刚更新的值。这样就导致了脏读，因为更新的数据还没有进行持久化，更新这行数据的业务可能会进行回滚，这样这个数据就是无效的。 数据库的TRANSACTIONREADCOMMITTED，TRANSACTIONREPEATABLEREAD，和TRANSACTION_SERIALIZABLE隔离级别可以防止脏读。 什么是两阶段提交 当我们在分布式系统上同时使用多个数据库时，这时候我们就需要用到两阶段提交协议。两阶段提交协议能保证是分布式系统提交的原子性。在第一个阶段，事务管理器发所有的事务参与者发送提交的请求。如果所有的参与者都返回OK，它会向参与者正式提交该事务。如果有任何一个参与方返回了中止消息，事务管理器会回滚所有的修改动作。 JDBC中存在哪些不同类型的锁 从广义上讲，有两种锁机制来防止多个用户同时操作引起的数据损坏。 乐观锁——只有当更新数据的时候才会锁定记录。 悲观锁——从查询到更新和提交整个过程都会对数据记录进行加锁。 不仅如此，一些数据库系统还提供了行锁，表锁等锁机制。 DDL和DML语句分别代表什么 DDL（数据定义语言，Data Definition Language）语句用来定义数据库模式。Create，Alter, Drop, Truncate, Rename都属于DDL语句，一般来说，它们是不返回结果的。 DML（数据操作语言，Data Manipulation Language）语句用来操作数据库中的数据。select, insert, update, delete, call等，都属于DML语句。 java.util.Date和java.sql.Date有什么区别 java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段。 如何把图片或者原始数据插入到数据库中 可以使用BLOB类型将图片或者原始的二进制数据存储到数据库里。 什么是幻读，哪种隔离级别可以防止幻读 幻读是指一个事务多次执行一条查询返回的却是不同的值。假设一个事务正根据某个条件进行数据查询，然后另一个事务插入了一行满足这个查询条件的数据。之后这个事务再次执行了这条查询，返回的结果集中会包含刚插入的那条新数据。这行新数据被称为幻行，而这种现象就叫做幻读。 只有TRANSACTION_SERIALIZABLE隔离级别才能防止产生幻读。 SQLWarning是什么，在程序中如何获取SQLWarning SQLWarning是SQLException的子类，通过Connection, Statement, Result的getWarnings方法都可以获取到它。 SQLWarning不会中断查询语句的执行，只是用来提示用户存在相关的警告信息。 如果Oracle的存储过程的入参出参中包含数据库对象，应该如何进行调用 如果Oracle的存储过程的入参出参中包含数据库对象，我们需要在程序创建一个同样大小的对象数组，然后用它来生成Oracle的STRUCT对象。然后可以通过数据库对象的setSTRUCT方法传入这个struct对象，并对它进行使用。 如果java.sql.SQLException: No suitable driver found该怎么办 如果你的SQL URL串格式不正确的话，就会抛出这样的异常。不管是使用DriverManager还是JNDI数据源来创建连接都有可能抛出这种异常。它的异常栈看起来会像下面这样。 org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot create JDBC driver of class 'com.mysql.jdbc.Driver' for connect URL ''jdbc:mysql://localhost:3306/UserDB' at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createConnectionFactory(BasicDataSource.java:1452) at org.apache.tomcat.dbcp.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1371) at org.apache.tomcat.dbcp.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044) java.sql.SQLException: No suitable driver found for 'jdbc:mysql://localhost:3306/UserDB at java.sql.DriverManager.getConnection(DriverManager.java:604) at java.sql.DriverManager.getConnection(DriverManager.java:221) at com.journaldev.jdbc.DBConnection.getConnection(DBConnection.java:24) at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:15) Exception in thread \"main\" java.lang.NullPointerException at com.journaldev.jdbc.DBConnectionTest.main(DBConnectionTest.java:16) 解决这类问题的方法就是，检查下日志文件，像上面的这个日志中，URL串是jdbc:mysql://localhost:3306/UserDB，只要把它改成jdbc:mysql://localhost:3306/UserDB就好了。 什么是JDBC的最佳实践 下面列举了其中的一些： 数据库资源是非常昂贵的，用完了应该尽快关闭它。Connection, Statement, ResultSet等JDBC对象都有close方法，调用它就好了。 养成在代码中显式关闭掉ResultSet，Statement，Connection的习惯，如果你用的是连接池的话，连接用完后会放回池里，但是没有关闭的ResultSet和Statement就会造成资源泄漏了。 在finally块中关闭资源，保证即便出了异常也能正常关闭。 大量类似的查询应当使用批处理完成。 尽量使用PreparedStatement而不是Statement，以避免SQL注入，同时还能通过预编译和缓存机制提升执行的效率。 如果你要将大量数据读入到ResultSet中，应该合理的设置fetchSize以便提升性能。 你用的数据库可能没有支持所有的隔离级别，用之前先仔细确认下。 数据库隔离级别越高性能越差，确保你的数据库连接设置的隔离级别是最优的。 如果在WEB程序中创建数据库连接，最好通过JNDI使用JDBC的数据源，这样可以对连接进行重用。 如果你需要长时间对ResultSet进行操作的话，尽量使用离线的RowSet。 JDBC操作数据库的步骤 注册数据库驱动。 建立数据库连接。 创建一个Statement。 执行SQL语句。 处理结果集。 关闭数据库连接。 数据库连接池工作原理和实现方案 工作原理：JAVA EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 实现方案：返回的Connection是原始Connection的代理，代理Connection的close方法，当调用close方法时，不是真正关连接，而是把它代理的Connection对象放回到连接池中，等待下一次重复利用。 Everything you need to prepare for your technical interview.modified at 2019-01-28 "},"java_web/spring.html":{"url":"java_web/spring.html","title":"Spring","keywords":"","body":"JavaWeb面试题：Spring 什么是Spring框架？Spring框架有哪些主要模块 Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。目的：解决企业应用开发的复杂性。功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能。范围：任何Java应用Spring是一个轻量级控制反转(IOC)和面向切面(AOP)的容器框架。 Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 使用Spring框架能带来哪些好处 下面列举了一些使用 Spring 框架带来的主要好处： Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。 与 EJB 容器相比较，IOC 容器更加趋向于轻量级。这样一来 IOC 容器在有限的内存和 CPU资源的情况下进行应用程序的开发和发布就变得十分有利。 Spring 并没有闭门造车，Spring 利用了已有的技术比如 ORM 框架、logging 框架、J2EE、Quartz 和 JDK Timer，以及其他视图技术。 Spring 框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。 要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。 Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。 Spring 提供了一个便捷的事务管理接口，适用于小型的本地事务处理（比如在单 DB 的环境下）和复杂的共同事务处理（比如利用 JTA 的复杂 DB 环境）。 什么是控制反转(IOC)？什么是依赖注入 控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 请解释下Spring框架中的IOC Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了Spring 框架 IOC 容器的基础。BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的WebApplicationContext。 BeanFactory和 ApplicationContext有什么区别？ BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。 BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。 提供了支持国际化的文本消息 统一的资源文件读取方式 已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： ClassPathXmlApplicationContext：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。 ApplicationContext context = new ClassPathXmlApplicationContext(“application.xml”); FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 ApplicationContext context = new FileSystemXmlApplicationContext(“application.xml”); XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 Spring提供几种配置方式来设置元数据 将 Spring 配置到应用开发中有以下三种方式： 基于 XML 的配置 基于注解的配置 基于 Java 的配置 如何使用XML配置的方式配置Spring 在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的 Spring 配置类型（比如声明的方式或基于 Java Class 的配置方式）Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 下面这个 web.xml 仅仅配置了 DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。 Archetype Created Web Application spring org.springframework.web.servlet.DispatcherServlet 1 spring / 如何用基于Java配置的方式配置Spring Spring 对 Java 配置的支持是由@Configuration 注解和@Bean 注解来实现的。由@Bean 注解的方法将会实例化、配置和初始化一个新对象，这个对象将由 Spring 的 IOC 容器来管理。@Bean 声明所起到的作用与 元素类似。被@Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被@Configuration 声明的类可以通过在同一个类的内部调用@bean 方法来设置嵌入 bean 的依赖关系。 最简单的@Configuration 声明类请参考下面的代码： @Configuration public class AppConfig{ @Bean public MyService myService() { return new MyServiceImpl(); } } 对于上面的@Beans 配置文件相同的 XML 配置文件如下： 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化 public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff(); } 要使用组件组建扫描，仅需用@Configuration 进行注解即可： @Configuration @ComponentScan(basePackages = \"com.gupaoedu\") public class AppConfig { } 在上面的例子中，com.gupaoedu 包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照 Sring bean 定义进行注册。如 果 你 要 在 你 的 web 应 用 开 发 中 选 用 上 述 的 配 置 的 方 式 的 话 ， 需 要 用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置 Spring 的Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。 contextClass org.springframework.web.context.support.AnnotationConfigWebApplicationContext contextConfigLocation com.gupaoedu.AppConfig org.springframework.web.context.ContextLoaderListener dispatcher org.springframework.web.servlet.DispatcherServlet contextClass org.springframework.web.context.support.AnnotationConfigWebApplicationContext contextConfigLocation com.gupaoedu.web.MVCConfig dispatcher /web/* 怎样用注解的方式配置Spring Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML方式的 bean 描述，可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 在标签配置完成以后，就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。下面是几种比较重要的注解类型： @Required：该注解应用于设值方法。 @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 @Qualifier：该注解和@Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 JSR-250 Annotations ：Spring 支持 基于 JSR-250 注解 的以下 注解 ，@Resource、@PostConstruct 和 @PreDestroy。 请解释Spring Bean的生命周期 Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean容器中移除。Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。 初始化之后调用的回调方法。 销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init()方法和 destroy()方法 @PostConstruct 和@PreDestroy 注解方式 使用 customInit()和 customDestroy()方法管理 bean 生命周期的代码样例如下： Spring Bean作用域之间的区别 Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下： singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。 prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。 request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。 Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。 global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。 什么是Spring inner beans 在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。内部 bean 可以用 setter 注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例，然后在 Customer 内部使用。 public class Customer{ private Person person; //Setters and Getters } public class Person{ private String name; private String address; private int age; //Setters and Getters } 内部 bean 的声明方式如下： Spring框架中的单例Beans是线程安全的么 Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。 请举例说明如何在Spring中注入一个Java集合 Spring 提供了以下四种集合类的配置元素： 该标签用来装配可重复的 list 值。 该标签用来装配没有重复的 set 值。 该标签可用来注入键和值可以为任何类型的键值对。 该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： INDIA Pakistan USA UK INDIA Pakistan USA UK admin@gupaoedu.com support@gupaoedu.com 如何向Spring Bean中注入java.util.Properties 第一种方法是使用如下面代码所示的标签： admin@gupaoedu.com support@gupaoedu.com 也可用”util:”命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter方法注入 bean 的引用。 请解释Spring Bean的自动装配 在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配： 除了 bean 配置文件中提供的自动装配模式，还可以使用@Autowired 注解来自动装配指定的bean。在使用@Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。 也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 配置好以后就可以使用@Autowired 来标注了。 @Autowired public EmployeeDAOImpl ( EmployeeManager manager ) { this.manager = manager; } 请解释各种自动装配模式的区别 在 Spring 框架中共有 5 种自动装配，让我们逐一分析。 no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean定义中用标签明确的设置依赖关系。 byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。 autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byTpe 的自动装配方式。 如何开启基于注解的自动装配 要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 引入配置文件中的下引入 在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor 自动装配有哪些局限性 自动装配有如下局限性： 重写：你仍然需要使用 和设置指明依赖，这意味着总要重写自动装配。 原生数据类型：你不能自动装配简单的属性，如原生类型、字符串和类。 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 在Spring中可以注入null或空字符串吗 完全可以。 请举例解释@Required Annotation 在产品级别的应用中，IOC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置“dependency-check”来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正 确 配 置 。 或 者 你 宁 可 验 证 某 个 bean 的 特 定 属 性 是 否 被 正 确 的 设 置 。 即 使 是 用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。需要用如下的方式使用来标明 bean 的设值方法。 public class EmployeeFactoryBean extends AbstractFactoryBean { private String designation; public String getDesignation() { return designation; } @Required public void setDesignation(String designation) { this.designation = designation; } } RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被@Required 注解的 bean 属性是否被正确的设置了。在使用 RequiredAnnotationBeanPostProcesso 来验证bean 属性之前，首先要在 IOC 容器中对其进行注册： 但 是 如 果 没 有 属 性 被 用 @Required 注 解 过 的 话 ， 后 置 处 理 器 会 抛 出 一 个BeanInitializationException 异常。 请举例解释@Autowired 注解 @Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像@Required 注解、构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。比如，可以在设值方法上使@Autowired 注解来替代配置文件中的 元素。当 Spring 容器在setter 方法上找到@Autowired 注解时，会尝试用 byType 自动装配。当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 public class TextEditor { private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker){ System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; } public void spellCheck(){ spellChecker.checkSpelling(); } } 下面是没有构造参数的配置方式： 请举例说明@Qualifier注解 @Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 public class Customer{ @Autowired private Person person; } 下面我们要在配置文件中来配置 Person 类。 Spring 会知道要自动装配哪个 person bean 么？不会的，但是运行上面的示例时，会抛出下面的异常： Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.gupaoedu.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： public class Customer{ @Autowired @Qualifier(\"personA\") private Person person; } 构造方法注入和设值注入有什么区别 请注意以下明显的区别： 在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException 异常，因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。 Spring 框架中有哪些不同类型的事件 Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件，如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 public class AllApplicationEventListener implements ApplicationListener { @Override public void onApplicationEvent(ApplicationEvent applicationEvent) { //process event } } Spring 提供了以下 5 中标准的事件： 上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。 上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的 Start()方法开始/重新开始容器时触发该事件。 上下文停止事件（ContextStoppedEvent）：当容器调ConfigurableApplicationContext的 Stop()方法停止容器时触发该事件。 上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。 请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请（request）结束触发该事件。除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 public class CustomApplicationEvent extends ApplicationEvent{ public CustomApplicationEvent ( Object source, final String msg ){ super(source); System.out.println(\"Created a Custom event\"); } } 为了监听这个事件，还需要创建一个监听器： public class CustomEventListener implements ApplicationListener { @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) { //handle event } } 之后通过 applicationContext 接口的 publishEvent()方法来发布自定义事件。 CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext,“Test message”); applicationContext.publishEvent(customEvent); FileSystemResource和ClassPathResource有何区别 在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把ClassPathResource 文件放在 ClassPath 下。如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src文件夹是默认。简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。 Spring框架中都用到了哪些设计模式 Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 代理模式—在 AOP 和 remoting 中被用的比较多。 单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。 模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 委派模式：Srping 提供了 DispatcherServlet 来对请求进行分发。 工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext接口的核心理念。 代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 在Spring框架中如何更有效的使用JDBC 使用Spring JDBC框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过statements和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate。 Spring5新特性 依赖 JDK 8+和 Java EE7+以上版本 首次采用反应式编程模型 支持使用注解进行编程 新增函数式编程 支持使用 REST 断点执行反应式编程 支持 HTTP 2.0 新增 Kotlin 和 Spring WebFlux 可使用 Lambda 表达式注册 Bean Spring WebMVC 支持最新的 API 使用 JUnit5 执行条件和并发测试 使用 Spring WebFlux 执行集成测试 核心容器优化 Everything you need to prepare for your technical interview.modified at 2019-01-28 "},"java_web/hibernate.html":{"url":"java_web/hibernate.html","title":"Hibernate","keywords":"","body":"JavaWeb面试题：Hibernate 进行更新操作时为什么需先获取数据库中原数据 进行更新操作的时候，为什么一般都是需要先获取到数据库中原数据，然后再把新对象的内容进行复制，然后再执行更新操作呢？比如下面的代码(1)而不是直接代码(2)。 代码（1）内容： // 其中Persion为一个pojo类 // 参数：currentPerson表示从controller层获取到从页面中传递过来的内容 // Service层中： public void updatePerson(Person currentPerson){ //获取到需要修改内容在数据库中原始的内容信息，也就是调用sesssion.load(id)这hibernate方法，也可以是get方法 Person person = personDao.loadPerson（currentPerson.getId()); //将传递过来的对象的属性内容进行复制到获取的对象中 BeanUtil.copyProperties(currentPerson , person); //进行hibernate中的session更新操作 personDao.updatePerson(person); } 代码（2）内容： // 其中Persion为一个pojo类 // 参数：currentPerson表示从controller层获取到从页面中传递过来的内容 // Service层中： public void updatePerson(Person currentPerson){ //进行hibernate中的session更新操作 personDao.updatePersoncurrentPerson) } 解答： 在上面的service层的这个更新的方法中（当然也可以是在controller层或者是strus2的方法中，只是调用的形式有变化而已），注意到了是先获取到数据库中对应的主键id的内容，然后再根据修改的内容进行的更新操作的。 当然，这个问题并不是一定会的，可以说是一种规范吧，就是能够更安全。原因就在于，在hibernate的工作机制中，对应在同一区域（Hibernate缓存区）和时间是不能够有相同主键内容的数据存在的，也就是说不能有两个相同主键的持久化类存在。 更为通俗的讲解就是，如果当前需要更新的实体，刚好的主键id对应着Hibernate缓存区中，已经存在了，那么这样就会报一个different object with the same identitifer的错误，很明显就是说存在了相同id的两个持久化类了，所以，通过先拿到当前修改id的原始内容，然后进行修改属性内容之后，再把改对象放入到更新操作中，就相当于从hibernate缓存区先取出已经存在的，然后修改了，再放回去，这样就肯定保证了只会存在一个唯一了，所以就防止不会出现上述的这个错误了。 当然，如果不进行先获取，再保存也可以，只是这样增加了安全性，所以记住，如果进行修改操作，那么就需要这样的步骤才是最安全的。 解决Hibernate懒加载load出现no session的错误 这个问题其实是开发中，很经过会遇到的一个问题。之所以出现这样的问题是在于，session对象当执行了相应的crud操作之后，就会结束生命周期了，而当session接受之后，然后又访问刚获取到的对象的相应的内容，那么因为是load（）方法是进行懒加载，当真正进行使用该对象的时候，再会真正的去获取，而此时session对象已经关闭了，所以肯定就会出现上面的问题了。就代码解释就是如下的代码： // 其中Persion为一个pojo类 // 参数：id表示从要进行获取到主键id // Dao层中： public void loadOpPerson(Long id){ Person person = this.hibernateTemplate.load(Person.class , id); person.getName(); //执行到这就会报no session的错误 } 原理上面，我解释过了，所以，来说一下如何解决这个问题，其实很好解决，那就是扩大session的生命周期，这样不就可以么吗？所以就可以采取在web.xml中配置一个OpenSessionInViewFilter过滤器，具体代码如下： OpenSessionInViewFilter org.springframework.orm.hibernate3.support.OpenSessionInViewFilter OpenSessionInViewFilter *.action 注意，这个一定要配置在strus2的核心过滤器前面（如果采取的是strus2的框架，如果用的springmvc那么同理）。 解决Hibernate中并发所引起的数据库内容读取问题 对于这个问题中，是非常常见的，但是Hibernate提供了很好的支持，就是通过锁机制，这就可以采取悲观锁与乐观锁的机制来解决这个问题。 悲观锁 —— 锁的粒度为数据库 悲观锁，它是对数据库而言的，数据库悲观了，他感觉每一个对他操作的程序都有可能产生并发。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 首先说一条SQL语句如下： select * from student where name=\"xiaoming\" for update 其实这就是一个非常依赖于数据库的悲观锁的使用，同理，Hibernate之所以也能够这样，也就是通过数据库中的锁机制来实现的。代码如下： String hqlStr =\"from Student s where s.name='xiaoming'\"; Query query = session.createQuery(hqlStr); query.setLockMode(\"s\",LockMode.UPGRADE); // 加锁 List userList = query.list();// 执行查询，获取数据 这里Hibernate通过使用数据库的 for update子句实现了悲观锁机制。 Hibernate的加锁模式有： LockMode.NONE ：无锁机制。 LockMode.WRITE ：Hibernate在 Insert和 Update记录的时候会自动获取。 LockMode.READ ：Hibernate在读取记录的时候会自动获取。 以上这三种锁机制一般由 Hibernate内部使用，如Hibernate为了保证 Update过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE锁。 LockMode.UPGRADE ：利用数据库的 for update 子句加锁。 LockMode. UPGRADE_NOWAIT ： Oracle的特定实现，利用 Oracle的 for update nowait子句实现加锁。 上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： Criteria.setLockMode Query.setLockMode Session.lock 注意，只有在查询开始之前（也就是 Hiberate生成 SQL之前）设定加锁，才会真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含 for update子句的 Select SQL加载进来，所谓数据库加锁也就无从谈起。 乐观锁 —— 锁的粒度为表，而且当出现了问题之后，才采取措施 乐观锁，从名字来看，就肯定比悲观锁有着更为乐观的态度了，就是说悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个\"version\"字段来实现。 乐观锁的工作原理：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 Hibernate为乐观锁提供了三 种实现： 基于version —— 最常用 基于timestamp —— 较常用 为遗留项目添加乐观锁 —— 不常用 基于version的使用 （1）对需要进行锁控制的数据库表中，添加一个字段，名字随便，一般就叫version，类型只有为long,integer,short,timestamp,calendar，也就是只能为数字或timestamp类型。 （2）如果通过配置文件进行配置的hibernate映射文件，那么就在对应的实体映射文件中添加如下代码： 如果是通过注解的形式进行的hibernate实体配置，那么很简单，只需要在对应的version字段用注解@version，即可，是不是简单很多呢？ （3）在POJO实体类中，实现对于version字段的set（）和get（）方法，这个和普通的属性一样，都需要这两个方法。 基于timestamp 这个使用一样，只是需要把映射文件中的标签改一下即可， 好了，下面就用一个test例子来验证一下是否有锁控制机制。 //开启两个session Sessionsession1=sessionFactory.openSession(); Session session2=sessionFactory.openSession(); Student stu1=(Student)session1.createQuery(\"from Student s wheres.name='xiaoming'\").uniqueResult(); Student stu2=(Student)session2.createQuery(\"from Student s wheres.name='xiaoming'\").uniqueResult(); //首先看一下，拿出来的数据的version版本是否一致，结果是是一致，都是数据库当前的版本 System.out.println(\"v1=\"+stu1.getVersion()+\"--v2=\"+stu2.getVersion()); //开始第一个事务 Transactiontx1=session1.beginTransaction(); //修改内容 stu1.setName(\"xiaohong\"); //事务提交 tx1.commit(); //当进行了事务提交之后，也就是数据的更新操作，再看看此时两个version是否一致，结果显示version不一样了 System.out.println(\"v1=\"+stu1.getVersion()+\"--v2=\"+stu2.getVersion()); //同理，再将第二个事务进行提交 Transactiontx2=session2.beginTransaction(); stu2.setName(\"xiaobai\"); //提交 tx2.commit(); OK,编译的时候是没有任何问题的，但是一运行就发现报了一个错，并且错误显示： Exception in thread \"main\" org.hibernate.StaleObjectStateException:Row was updated or deleted by another transaction (or unsaved-value mapping wasincorrect): 其实，原因很简单，就是因为第一个事务提交对数据之后，这条数据的内容被更新，然后数据库中的版本控制字段version相比原来的版本+1，而当第二个事务再提交更新操作的时候，因为当前的数据的版本是原来的版本，而数据库中的版本比它高了，所以就认为这条数据是条无效的数据，那么结果很明显就是会发现刚才的错误。这样的话，是不是对于并发操作的问题就提供了一个很好的方法呢？ 什么是Hibernate的并发机制 Hibernate并发机制： Hibernate的Session对象是非线程安全的,对于单个请求,单个会话,单个的工作单元(即单个事务,单个线程),它通常只使用一次, 然后就丢弃。 如果一个Session 实例允许共享的话，那些支持并发运行的,例如Http request,session beans将会导致出现资源争用。 如果在Http Session中有hibernate的Session的话,就可能会出现同步访问Http Session。只要用户足够快的点击浏览器的“刷新”, 就会导致两个并发运行的线程使用同一个Session。 多个事务并发访问同一块资源,可能会引发第一类丢失更新，脏读，幻读，不可重复读，第二类丢失更新一系列的问题。 解决方案：设置事务隔离级别。 Serializable：串行化。隔离级别最高 Repeatable Read：可重复读 Read Committed：已提交数据读 Read Uncommitted：未提交数据读。隔离级别最差 设置锁：乐观锁和悲观锁。 乐观锁：使用版本号或时间戳来检测更新丢失,在的映射中设置 optimistic-lock=”all”可以在没有版本或者时间戳属性映射的情况下实现 版本检查，此时Hibernate将比较一行记录的每个字段的状态 行级悲观锁：Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！只要为JDBC连接指定一下隔 离级别，然后让数据库去搞定一切就够了。类LockMode 定义了Hibernate所需的不同的锁定级别：LockMode.UPGRADE,LockMode.UPGRADE_NOWAIT,LockMode.READ; update和saveOrUpdate的区别 update()和saveOrUpdate()是用来对跨Session的PO进行状态管理的。 update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。 saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会 更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。 Hibernate的三种状态之间如何转换 在hibernate中 不同的持久化操作会导致对象的状态的改变 ，如下图所示： 瞬时状态转换为持久状态 使用session对象的save()或saveOrUpdate()方法保存对象后，该对象的状态由瞬时状态转换为持久状态。 使用session对象的get()或load()方法获取对象后，该对象的状态是持久状态。 持久状态转换为瞬时状态 执行session对象的delete()方法后，对象由原来的持久状态变为瞬时状态，因此该对象没有与任何的数据库数据有关联。 持久状态变为游离状态 执行了session对象的evict()、clear()、 close() 方法，对象由原来的持久状态变为游离态。 游离状态转换为持久状态 重新获取session对象，执行session对象的update()或 saveOrUpdate()方法，由游离状态转换为持久状态，该对象再次与session关联。 游离状态转换为瞬时状态 执行session的delete()方法，对象有游离状态变为瞬时状态。 对瞬时状态或游离状态 的对象不再被其他对象引用时，会被Java虚拟机按照垃圾回收机制处理。 Hibernate的三种检索策略优缺点 立即检索： 优点： 对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象； 缺点： 1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间； 立即检索:lazy=false； 延迟检索： 优点： 由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间； 缺点： 应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化； 延迟加载：lazy=true； 迫切左外连接检索： 优点： 1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少； 缺点： 1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能； 预先抓取： fetch=“join”； 如何在控制台查看Hibernate生成并执行的sql 在定义数据库和数据库属性的文件applicationConfig.xml里面，把hibernate.show_sql 设置为true 这样生成的SQL就会在控制台出现了。 注意：这样做会加重系统的负担，不利于性能调优。 Hibernate都支持哪些缓存策略 Read-only: 这种策略适用于那些频繁读取却不会更新的数据，这是目前为止最简单和最有效的缓存策略 Read/write:这种策略适用于需要被更新的数据，比read-only更耗费资源，在非JTA环境下，每个事务需要在session.close和session.disconnect()被调用 Nonstrict read/write: 这种策略不保障两个同时进行的事务会修改同一块数据，这种策略适用于那些经常读取但是极少更新的数据 Transactional: 这种策略是完全事务化得缓存策略，可以用在JTA环境下 sorted collection 和ordered collection的区别 sorted collection 是在内存中通过Java比较器进行排序的 ordered collection 是在数据库中通过order by进行排序的 对于比较大的数据集，为了避免在内存中对它们进行排序而出现 Java中的OutOfMemoryError，最好使用ordered collection。 Hibernate工作原理及为什么要使用 工作原理： 读取并解析配置文件 读取并解析映射信息，创建SessionFactory 打开Sesssion 创建事务Transation 持久化操作 提交事务 关闭Session 关闭SesstionFactory 为什么要使用： 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作。 Hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 Hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate是如何延迟加载 当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 说下Hibernate的缓存机制 一级缓存： Hibenate中一级缓存，也叫做session的缓存，它可以在session范围内减少数据库的访问次数！ 只在session范围有效！ Session关闭，一级缓存失效！ 只要是持久化对象状态的，都受Session管理，也就是说，都会在Session缓存中！ Session的缓存由hibernate维护，用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。 二级缓存： 二级缓存是基于应用程序的缓存，所有的Session都可以使用。 Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可； 不想用，直接移除，不影响代码。 如果用户觉得hibernate提供的框架框架不好用，自己可以换其他的缓存框架或自己实现缓存框架都可以。 Hibernate二级缓存：存储的是常用的类。 Hibernate的查询方式有几种 对象导航查询(objectcomposition) HQL查询 1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数 Criteria 查询 SQLQuery本地SQL查询 如何优化Hibernate 数据库设计调整 HQL优化 API的正确使用(如根据不同的业务类型选用不同的集合及查询API) 主配置参数(日志，查询缓存，fetch_size, batch_size等) 映射文件优化(ID生成策略，二级缓存，延迟加载，关联优化) 一级缓存的管理 针对二级缓存，还有许多特有的策略 谈谈Hibernate中inverse的作用 inverse属性默认是false,就是说关系的两端都来维护关系。 比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp) 如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。 如果表之间的关联关系是“一对多”的话，那么inverse只能在“一”的一方来配置！ Detached Object（游离对象）有什么好处 Detached Object（游离对象）可以传递到任何层直到表现层而不是用任何DTO(DataTransfer Objects)。 然后你还可以重新把游离对象赋给另外一个Session。 数据库中条件查询速度很慢时如何优化 建索引 减少表之间的关联 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引，把数据量大的表排在前面 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 什么是SessionFactory，它是线程安全么 SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问。 一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存。 Hibernate的五个核心接口 Configuration 接口：配置Hibernate，根据其启动hibernate，创建 SessionFactory 对象； SessionFactory 接口：初始化Hibernate，充当数据存储源的代理，创建session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级、二级缓存； Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的， 避免多个线程共享同一个session，是轻量级、一级缓存； Transaction 接口：管理事务； Query 和Criteria 接口：执行数据库的查询。 get和load区别 get()：立即查询 load()：懒加载 get如果没有找到会返回null， load如果没有找到会抛出异常。 get会先查一级缓存， 再查二级缓存，然后查数据库；load会先查一级缓存，如果没有找到，就创建代理对象， 等需要的时候去查询二级缓存和数据库。 merge的含义 如果session中存在相同持久化标识(identifier)的实例，用用户给出的对象的状态覆盖旧有的持久实例 如果session没有相应的持久实例，则尝试从数据库中加载，或创建新的持久化实例,最后返回该持久实例 用户给出的这个对象没有被关联到session上，它依旧是脱管的 persist和save的区别 persist不保证立即执行，可能要等到flush； persist不更新缓存； save, 把一个瞬态的实例持久化标识符，及时的产生,它要返回标识符，所以它会立即执行Sql insert 使用 save() 方法保存持久化对象时，该方法返回该持久化对象的标识属性值(即对应记录的主键值)； 使用 persist() 方法来保存持久化对象时，该方法没有任何返回值。 主键生成策略有哪些 主键类型 自然主键（主键本身就是表中的一个字段，实体中一个具体的属性） 表中已经具有某字段，并且该字段具有业务含义作为主键，称之为自然主键。 例如：在person表中的身份证号，既是唯一的，又可以单独标识一个person。 又如：在customer表中，如果把name作为主键，其前提条件必须是，每一个客户的姓名不允许为null，不允许客户重名，并且不允许修改客户姓名。尽管这也是可行的，但是不能满足不断变化的业务需求，一旦出现了允许客户重名的业务需求，就必须修改数据模型，重新定义表的主键，这给数据库的维护增加了难度。 代理主键（主键不是实体中某个具体的属性，而是一个不相关的字段） 表中原本不存在的字段，且不具备业务含义的字段作为主键，称之为代理主键。更合理的方式是使用代理主键。 主键生成策略 主键生成策略，就是每条记录录入时，主键的生成规则。Hibernate中，提供了几个内置的主键生成策略，其常用主键生成策略的名称和描述如下 代理主键 identity（主键自增） 适用于long、short或int类型主键，采用底层数据库本身提供的主键生成标识符。在DB2、MySQL、MS SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增类型。Oracle没有自动增长 sequence（序列） 适用于long、short或int类型主键，Hibernate根据底层数据库序列生成标识符。条件是数据库支持序列。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence，MySQL这种不支持sequence increment（主键自增，单线程，maxID+1） 适用于long、short或int类型主键，由Hibernate提供自动递增的方式生成唯一标识符，每次增量为1。只有当没有其他进程向同一张表中插入数据时才可以使用，不能再多线程环境下使用 hilo（主键自增，高低位算法） hilo（高低位方式high low）是hibernate中最常用的一种生成方式，需要一张额外的表保存hi的值。保存hi值的表至少有一条记录（只与第一条记录有关），否则会出现错误。跨数据库，hilo算法生成的标志只能在一个数据库中保证唯一 native（hilo+identity+sequence三选一） 根据底层数据库对自动生成标识符的能力来选择i dentity、sequence、hilo三种生成器中的一种，适合跨数据库平台开发 uuid（随机字符串作主键） Hibernate采用128位的UUID算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32位的十六进制字符串。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字 uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。 guid（全球唯一标识符） 全球唯一标识符，也称作 UUID，是一个128位长的数字，用16进制表示。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。 Hibernate在维护主键时，先查询数据库，获得一个uuid字符串，该字符串就是主键值，该值唯一，缺点长度较大，支持数据库有限，优点同uuid，跨数据库，但是仍然需要访问数据库。注意：长度因数据库不同而不同。 需要数据库支持查询uuid，生成时需要查询数据库，效率没有uuid高，推荐使用uuid。 getCurrentSession和openSession的区别 getCurrentSession会绑定当前线程，而openSession不会，因为我们把hibernate交给我们的spring来管理之后，我们是有事务配置，这个有事务的线程就会绑定当前的工厂里面的每一个session，而openSession是创建一个新session。 getCurrentSession事务是有spring来控制的，而openSession需要我们手动开启和手动提交事务。 getCurrentSession是不需要我们手动关闭的，因为工厂会自己管理，而openSession需要我们手动关闭。 而getCurrentSession需要我们手动设置绑定事务的机制，有三种设置方式，jdbc本地的Thread、JTA、第三种是spring提供的事务管理机制org.springframework.orm.hibernate4.SpringSessionContext，而且srping默认使用该种事务管理机制。 Hibernate中的命名SQL查询指的是什么 命名查询指的是用标签在影射文档中定义的SQL查询，可以通过使用Session.getNamedQuery()方法对它进行调用。命名查询使你可以使用你所指定的一个名字拿到某个特定的查询。 Hibernate中的命名查询可以使用注解来定义，也可以使用我前面提到的xml影射问句来定义。在Hibernate中，@NameQuery用来定义单个的命名查询，@NameQueries用来定义多个命名查询。 为什么在Hibernate的实体类中要提供一个无参数的构造器 每个Hibernate实体类必须包含一个 无参数的构造器, 这是因为Hibernate框架要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例。如果在实体类中找不到无参数的构造器，这个方法就会抛出一个InstantiationException异常。 可不可以将Hibernate的实体类定义为final类 可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了， 如此一来就限制了使用可以提升性能的手段。 Hibernate的OpenSessionView问题 用于解决懒加载异常, 主要功能就是把 Hibernate Session 和一个请求的线程绑定在一起, 直到页面完整输出, 这样就可以保证页面读取数据的时候 Session 一直是开启的状态, 如果去获取延迟加载对象也不会报错。 问题: 如果在业务处理阶段大批量处理数据, 有可能导致一级缓存里的对象占用内存过多导致内存溢出, 另外一个是连接问题: Session 和数据库 Connection 是绑定在一起的, 如果业务处理缓慢也会导致数据库连接得不到及时的释放, 造成连接池连接不够. 所以在并发量较大的项目中不建议使用此种方式, 可以考虑使用迫切左外连接 (LEFT OUTER JOIN FETCH) 或手工对关联的对象进行初始化。 配置 Filter 的时候要放在 Struts2 过滤器的前面, 因为它要页面完全显示完后再退出。 Everything you need to prepare for your technical interview.modified at 2019-01-28 "},"java_web/mybatis.html":{"url":"java_web/mybatis.html","title":"Mybatis","keywords":"","body":"JavaWeb面试题：Mybatis 什么是mybatis？ mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 MyBatis 支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO映射成数据库中的记录。 Mybait的优点 简单易学，容易上手（相比于Hibernate） —- 基于SQL编程； JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接； 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDBC提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。 提供了很多第三方插件（分页插件 / 逆向工程）； 能够与Spring很好的集成； MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，解除sql与程序代码的耦合，便于统一管理和优化，并可重用。 提供XML标签，支持编写动态SQL语句。 提供映射标签，支持对象与数据库的ORM字段关系映射。 提供对象关系映射标签，支持对象关系组建维护。 MyBatis框架的缺点 SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。 SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 MyBatis框架适用场合 MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。 MyBatis与Hibernate有哪些不同？ Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 #{}和${}的区别是什么 #{}是预编译处理，${}是字符串替换。 Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； Mybatis在处理${}时，就是把${}替换成变量的值。 使用#{}可以有效的防止SQL注入，提高系统安全性。 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？ 第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。 select order_id id, order_no orderno ,order_price price form orders where order_id=#{id}; 第2种： 通过来映射字段名和实体类属性名的一一对应的关系 select * from orders where order_id=#{id} 模糊查询like语句该怎么写? 第1种：在Java代码中添加sql通配符。 String wildcardname = \"%smi%\"; List names = mapper.selectlike(wildcardname); select * from foo where bar like #{value} 第2种：在sql语句中拼接通配符，会引起sql注入。 String wildcardname = \"smi\"; List names = mapper.selectlike(wildcardname); select * from foo where bar like \"%\"#{value}\"%\" 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例： com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个、、、标签，都会被解析为一个MappedStatement对象。 Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。 Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 Mybatis是如何进行分页的？分页插件的原理是什么？ Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？ 第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。 有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 如何执行批量插入? 首先,创建一个简单的insert语句: insert into names (name) values (#{value}) 然后在java代码中像下面这样执行批处理插入: List names = new arraylist(); names.add(\"fred\"); names.add(\"barney\"); names.add(\"betty\"); names.add(\"wilma\"); // 注意这里 executortype.batch sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch); try { namemapper mapper = sqlsession.getmapper(namemapper.class); for (string name : names) { mapper.insertname(name); } sqlsession.commit(); } catch(Exception e) { e.printStackTrace(); sqlSession.rollback(); throw e; } finally { sqlsession.close(); } 如何获取自动生成的(主)键值? insert 方法总是返回一个int值 - 这个值代表的是插入的行数。 而自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。 示例: insert into names (name) values (#{name}) Name name = new Name(); name.setname(\"fred\"); int rows = mapper.insertname(name); // 完成后,id已经被设置到对象中 System.out.println(\"rows inserted = \" + rows); System.out.println(\"generated key value = \" + name.getid()); 在mapper中如何传递多个参数? 第1种 // DAO层的函数 public UserselectUser(String name, String area); select * fromuser_user_t whereuser_name = #{0} anduser_area=#{1} 第2种： 使用 @param 注解: import org.apache.ibatis.annotations.param; public interface Usermapper { user selectuser(@param(\"username\") String username, @param(\"hashedpassword\") String hashedpassword); } 然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper): select id, username, hashedpassword from some_table where username = #{username} and hashedpassword = #{hashedpassword} 第3种：多个参数封装成map try{ // 映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL /** * 由于我们的参数超过了两个，而方法中只有一个Object参数收集 * 因此我们使用Map集合来装载我们的参数 */ Map map = new HashMap(); map.put(\"start\", start); map.put(\"end\", end); return sqlSession.selectList(\"StudentID.pagination\", map); } catch(Exception e) { e.printStackTrace(); sqlSession.rollback(); throw e; } finally { MybatisUtil.closeSqlSession(); } Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？ Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。 Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。 Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？ 还有很多其他的标签，、、、、，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？ 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。 原因就是namespace+id是作为Map的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？ Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 一对一、一对多的关联查询 ？ select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#{id} select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id} MyBatis实现一对一有几种方式？具体怎么操作的？ 有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成; 嵌套查询是先查一个表，根据这个表里面 的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。 MyBatis实现一对多有几种方式，怎么操作的？ 有联合查询和嵌套查询,联合查询是几个表联合查询，只查询一次，通过在resultMap里面配 置collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的结果的外键id，去再另外一个表里面查询数据,也是通过配置collection，但另外一个表的查询通过select节点配置。 简述Mybatis的插件运行原理，以及如何编写一个插件。 Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。 编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？ Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 Mybatis的一级、二级缓存 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ； 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 什么是MyBatis的接口绑定,有什么好处？ 接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置. 接口绑定有几种实现方式,分别是怎么实现的? 接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。 什么情况下用注解绑定,什么情况下用xml绑定 ？ 当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。 使用MyBatis的mapper接口调用时有哪些要求？ Mapper接口方法名和mapper.xml中定义的每个sql的id相同 ； Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 ； Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 ； Mapper.xml文件中的namespace即是mapper接口的类路径。 Mapper编写有哪几种方式？ 第一种 接口实现类继承SqlSessionDaoSupport： 使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件。 （1）在sqlMapConfig.xml中配置mapper.xml的位置 （2）定义mapper接口 （3）实现类集成SqlSessionDaoSupport mapper方法中可以this.getSqlSession()进行数据增删改查。 （4）spring 配置 第二种 使用org.mybatis.spring.mapper.MapperFactoryBean： （1）在sqlMapConfig.xml中配置mapper.xml的位置 如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置 （2）定义mapper接口 注意： mapper.xml中的namespace为mapper接口的地址 mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致 Spring中定义 第三种 使用mapper扫描器： （1）mapper.xml文件编写： 注意： mapper.xml中的namespace为mapper接口的地址 mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致 如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置 （2）定义mapper接口 注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录 （3）配置mapper扫描器 （4）使用扫描器后从spring容器中获取mapper的实现对象 Mybatis比IBatis比较大的几个改进是什么？ 有接口绑定,包括注解绑定sql和xml绑定Sql。 动态sql由原来的节点配置变成OGNL表达式。 在一对一，一对多的时候引进了association，在一对多的时候引入了collection 节点，不过都是在resultMap里面配置。 IBatis和MyBatis在核心处理类分别叫什么？ IBatis里面的核心处理类交SqlMapClient, MyBatis里面的核心处理类叫做SqlSession IBatis和MyBatis在细节上的不同有哪些？ 在sql里面变量命名有原来的#变量# 变成了#{变量} 原来的$变量$变成了${变量},； 原来在sql节点里面的class都换名字交type； 原来的queryForObject、queryForList 变成了selectOne、selectList； 原来的别名设置在映射文件里面放在了核心配置文件。 Everything you need to prepare for your technical interview.modified at 2019-02-18 "},"android/basic.html":{"url":"android/basic.html","title":"基本常识","keywords":"","body":"Android面试题：基本常识 什么是ANR，如何避免它？ 在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。不同的组件发生ANR的时间不一样，主线程（Activity、Service）是5秒，BroadCastReceiver是10秒。 解决方案： 将所有耗时操作，比如访问网络，Socket通信，查询大量SQL语句，复杂逻辑计算等都放在子线程中去，然后通过handler.sendMessage()、runonUITread()、AsyncTask等方式更新UI。无论如何都要确保用户界面操作的流畅度。如果耗时操作需要让用户等待，那么可以在界面上显示进度条。 谈谈Android的优点和不足之处 优点： 开放性，开源，免费，可定制 挣脱运营商束缚 丰富的硬件选择 不受任何限制的开发商 无缝结合的Google应用 缺点： 安全问题、隐私问题 同质化严重 运营商对Android手机仍然有影响 山寨化严重 过分依赖开发商，缺乏标准配置 一条最长的短信息约占多少byte? 在国内的三大运营商通常情况下中文70(包括标点)，英文160个。对于国外的其他运行商具体多长需要看运营商类型了。 android内部是通过如下代码进行判断具体一个短信多少byte的。 ArrayList android.telephony.SmsManager.divideMessage(String text) sim卡的EF文件有何作用？ 基本文件EF(Elementary File)是SIM卡文件系统的一部分。 文件 文件标识符 文件缩写 中文名称 文件作用 MF 3F00 根目录 备注：所有非ETSI GSM协议中规定的应用文件由各厂家自行定义在根目录下（如：PIN1，PIN2…） EFICCID 2FE2 ICCID SIM卡唯一的识别号 包含运营商、卡商、发卡时间、省市代码等信息 DFGSM 7F20 GSM目录 备注：根据ETSIGSM09.91的规定Phase2(或以上)的SIM卡中应该有7F21并指向7F20,用以兼容Phase1的手机 EFLP语言选择 6F05 LP 语言选择文件 包含一种或多种语言编码 EFIMSI 6F07 IMSI 国际移动用户识别符 包含SIM卡所对应的号段，比如46000代表135－139号段、46002代表1340－1348 EFKC语音加密密钥 6F20 Kc 计算密钥 用于SIM卡的加密、解密 EFPLMNsel网络选择表 6F30 PLMNsel 公共陆地网选择 决定SIM卡选择哪种网络，在这里应该选择中国移动的网络 EFHPLMN归属地网络选择表 6F31 HPLMN 两次搜索PLMN的时间间隔 两次搜索中国移动的网络的时间间隔 EFACMmax最大计费额 6F37 ACMmax 包含累积呼叫表的最大值 全部的ACM数据存在SIM卡中，此处取最大值 EFSST SIM卡服务表 6F38 SST SIM卡服务列表 指出SIM卡可以提供服务的种类，哪些业务被激活哪些业务没有开通 EFACM累加计费计数器 6F39 ACM 累计呼叫列表 当前的呼叫和以前的呼叫的单位总和 EFGID1分组识别1 6F3E GID1 1级分组识别文件 包含特定的SIM-ME组合的标识符，可以识别一组特定的SIM卡 EFGID2分组识别2 6F3F GID2 2级分组识别文件 包含特定的SIM-ME组合的标识符，可以识别一组特定的SIM卡 EFPUCT单位价格/货币表 6F41 PUCT 呼叫单位的价格和货币表 PUCT是与计费通知有关的信息，ME用这个信息结合EFACM，以用户选择的货币来计算呼叫费用 EFCBMI小区广播识别号 6F45 CBMI 小区广播信息标识符 规定了用户希望MS采纳的小区广播消息内容的类型 EFSPN服务提供商 6F46 SPN 服务提供商名称 包含服务提供商的名称和ME显示的相应要求 EFCBMID 6F48 CBMID 数据下载的小区广播消息识别符 移动台将收到的CBMID传送给SIM卡 EFSUME 6F54 SUME 建立菜单单元 建立SIM卡中的菜单 EFBCCH广播信道 6F74 BCCH 广播控制信道 由于BCCH的存储，在选择小区时，MS可以缩小对BCCH载波的搜索范围 EFACC访问控制级别 6F78 ACC 访问控制级别 SIM卡有15个级别，10个普通级别，5个高级级别 EFFPLMN禁止网络号 6F7B FPLMN 禁用的PLMN 禁止选择除中国移动以外的其他运营商，比如中国联通、中国卫通等 EFLOCI位置信息 6F7E LOCI 位置信息 存储临时移动用户识别符、位置区信息等内容 EFAD管理数据 6FAD AD 管理数据 包括关于不同类型SIM卡操作模式的信息。例如：常规模式（PLMN用户用于GSM网络操作），型号认证模式（允许ME在无线设备的认证期间的特殊应用）；小区测试模式（在小区商用之前，进行小区测试），制造商特定模式（允许ME制造商在维护阶段进行特定的性能自动测试） EFPHASE阶段 6FAE PHASE 阶段标识 标识SIM卡所处的阶段信息，比如是普通SIM卡还是STK卡等 DFTELECOM 7F10 电信目录 EFADN缩位拨号 6F3A AND 电话簿 用于将电话记录存放在SIM卡中 EFFDN固定拨号 6F3B FDN 固定拨号 包括固定拨号（FDN）和/或补充业务控制字串（SSC），还包括相关网络/承载能力的识别符和扩展记录的识别符，以及有关的α识别符 EFSMS短消息 6F3C SMS 短消息 用于将短消息记录存放在SIM卡中 EFCCP能力配置参数 6F3D CCP 能力配置参数 包括所需要的网络和承载能力的参数，以及当采用一个缩位拨号号码，固定拨号号码，MSISDN、最后拨号号码、服务拨号号码或禁止拨号方式等，建立呼叫时相关的ME配置 EFMSISDN电话号码 6F40 MSISDN 移动基站国际综合业务网号 存放用户的手机号 EFSMSP短信息参数 6F42 SMSP 短消息业务参数 包括短信中心号码等信息 EFSMSS短信息状态 6F43 SMSS 短消息状态 这个标识是用来控制流量的 EFLND最后拨号 6F44 LND 最后拨叫号码 存储最后拨叫号码 EFExt1扩展文件1 6F4A EXT1 扩展文件1 包括AND，MSISDN或LND的扩展数据 EFExt2扩展文件2 6F4B EXT2 扩展文件2 包含FDN的扩展数据 如何判断是否有SD卡？ 通过如下方法： Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) 如果返回true就是有sdcard，如果返回false则没有。 dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念？ dvm指dalvik的虚拟机。每一个Android应用程序都拥有一个独立的Dalvik虚拟机实例，应用程序都在它自己的进程中运行。而每一个dvm都是在Linux 中的一个进程，所以说可以近似认为是同一个概念。 什么是android DVM:Dalvik是Google公司自己设计用于Android平台的Java虚拟机，每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 Dalvik和Java虚拟机的区别 Dalvik主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等等重要功能。 　　 Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。 　　 不同于Java虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex dex文件格式可以减少整体文件尺寸，提高I/O操作的类查找速度。 　　 odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化。 　　 所有的Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制 有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化，库的加载，预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的数据提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域。 Android程序与Java程序的区别？ Android程序用android sdk开发，java程序用javasdk开发。 Android SDK引用了大部分的Java SDK，少数部分被AndroidSDK抛弃，比如说界面部分，java.awt swing package除了java.awt.font被引用外，其他都被抛弃，在Android平台开发中不能使用。android sdk 添加工具jar httpclient , pull opengl 启动应用后，改变系统语言，应用的语言会改变么？ 这个一般是不会的，一般需要重启应用才能改变应用语言。但是对应应用来说如果做了国际化处理则支持如果没有处理那系统语言再更改也是无用的。 请介绍下adb、ddms、aapt的作用 adb是Android Debug Bridge ，Android调试桥的意思，ddms是Dalvik Debug Monitor Service，dalvik调试监视服务。aapt即AndroidAsset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建，更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成二进制文件，尽管我们没有直接使用过该工具，但是开发工具会使用这个工具打包apk文件构成一个Android 应用程序。 Android 的主要调试工具是adb(Android debuging bridge)，ddms是一个在adb基础上的一个图形化工具。adb，它是一个命令行工具。而ddms功能与adb相同，只是它有一个图形化界面。对不喜欢命今操作方式的人来说是一个不错的选择。 ddms 和traceview的区别 简单的说ddms是一个程序执行查看器，在里面可以看见线程和堆栈等信息，traceView是程序性能分析器。 TraceView的使用 TraceView简介 Traceview是Android平台特有的数据采集和分析工具，它主要用于分析Android中应用程序的hotspot（瓶颈）。Traceview本身只是一个数据分析工具，而数据的采集则需要使用Android SDK中的Debug类或者利用DDMS工具。二者的用法如下： 开发者在一些关键代码段开始前调用Android SDK中Debug类的startMethodTracing函数，并在关键代码段结束前调用stopMethodTracing函数。这两个函数运行过程中将采集运行时间内该应用所有线程（注意，只能是Java线程）的函数执行情况，并将采集数据保存到/mnt/sdcard/下的一个文件中。开发者然后需要利用SDK中的Traceview工具来分析这些数据。 借助Android SDK中的DDMS工具。DDMS可采集系统中某个正在运行的进程的函数调用信息。对开发者而言，此方法适用于没有目标应用源代码的情况。DDMS工具中Traceview的使用如下图所示。 点击上图中所示按钮即可以采集目标进程的数据。当停止采集时，DDMS会自动触发Traceview工具来浏览采集数据。 下面，我们通过一个示例程序向读者介绍Debug类以及Traceview的使用。 实例程序如下图所示：界面有4个按钮，对应四个方法。 点击不同的方法会进行不同的耗时操作。 public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void method1(View view) { int result = jisuan(); System.out.println(result); } private int jisuan() { for (int i = 0; i 我们分别点击按钮一次，要求找出最耗时的方法。点击前通过DDMS 启动 Start Method Profiling按钮。 然后依次点击4个按钮，都执行后再次点击上图中红框中按钮，停止收集数据。 接下来我们开始对数据进行分析。 当我们停止收集数据的时候会出现如下分析图表。该图表分为2大部分，上面分不同的行，每一行代表一个线程的执行耗时情况。main线程对应行的的内容非常丰富，而其他线程在这段时间内干得工作则要少得多。图表的下半部分是具体的每个方法执行的时间情况。显示方法执行情况的前提是先选中某个线程。 我们主要是分析main线程。 上面方法指标参数所代表的意思如下： 列名 描述 Name 该线程运行过程中所调用的函数名 Incl Cpu Time 某函数占用的CPU时间，包含内部调用其它函数的CPU时间 Excl Cpu Time 某函数占用的CPU时间，但不含内部调用其它函数所占用的CPU时间 Incl Real Time 某函数运行的真实时间（以毫秒为单位），内含调用其它函数所占用的真实时间 Excl Real Time 某函数运行的真实时间（以毫秒为单位），不含调用其它函数所占用的真实时间 Call+Recur Calls/Total 某函数被调用次数以及递归调用占总调用次数的百分比 Cpu Time/Call 某函数调用CPU时间与调用次数的比。相当于该函数平均执行时间 Real Time/Call 同CPU Time/Call类似，只不过统计单位换成了真实时间 我们为了找到最耗时的操作，那么可以通过点击Incl Cpu Time，让其按照时间的倒序排列。我点击后效果如下图： 通过分析发现：method1最耗时，耗时2338毫秒。 那么有了上面的信息我们可以进入我们的method1方法查看分析我们的代码了。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/activity.html":{"url":"android/activity.html","title":"Activity","keywords":"","body":"Android面试题：Activity 什么是Activity? 四大组件之一，通常一个用户交互界面对应一个activity。activity 是Context的子类，同时实现了window.callback和keyevent.callback， 可以处理与窗体用户交互的事件。 常见的Activity类型有FragmentActivitiy，ListActivity，TabAcitivty等。 如果界面有共同的特点或者功能的时候，还会自己定义一个BaseActivity。 请描述一下Activity 生命周期 Activity从创建到销毁有多种状态，从一种状态到另一种状态时会激发相应的回调方法，这些回调方法包括：onCreate、onStart、onResume、onPause、onStop、onDestroy 其实这些方法都是两两对应的， onCreate创建与onDestroy销毁； onStart可见与onStop不可见； onResume可编辑（即焦点）与onPause； 这6个方法是相对应的，那么就只剩下一个onRestart方法了，这个方法在什么时候调用呢？ 答案就是：在Activity被onStop后，但是没有被onDestroy，在再次启动此Activity时就调用onRestart（而不再调用onCreate）方法；如果被onDestroy了，则是调用onCreate方法。 如何保存Activity的状态？ Activity的状态通常情况下系统会自动保存的，只有当我们需要保存额外的数据时才需要使用到这样的功能。 一般来说， 调用onPause()和onStop()方法后的activity实例仍然存在于内存中， activity的所有信息和状态数据不会消失， 当activity重新回到前台之后， 所有的改变都会得到保留。 但是当系统内存不足时， 调用onPause()和onStop()方法后的activity可能会被系统摧毁， 此时内存中就不会存有该activity的实例对象了。如果之后这个activity重新回到前台， 之前所作的改变就会消失。为了避免此种情况的发生， 我们可以覆写onSaveInstanceState()方法。onSaveInstanceState()方法接受一个Bundle类型的参数， 开发者可以将状态数据存储到这个Bundle对象中， 这样即使activity被系统摧毁，当用户重新启动这个activity而调用它的onCreate()方法时， 上述的Bundle对象会作为实参传递给onCreate()方法， 开发者可以从Bundle对象中取出保存的数据， 然后利用这些数据将activity恢复到被摧毁之前的状态。 需要注意的是， onSaveInstanceState()方法并不是一定会被调用的， 因为有些场景是不需要保存状态数据的. 比如用户按下BACK键退出activity时， 用户显然想要关闭这个activity， 此时是没有必要保存数据以供下次恢复的， 也就是onSaveInstanceState()方法不会被调用. 如果调用onSaveInstanceState()方法， 调用将发生在onPause()或onStop()方法之前。 @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); } 两个Activity之间跳转时必然会执行的是哪几个方法？ 一般情况下比如说有两个activity，分别叫A，B，当在A里面激活B组件的时候， A会调用 onPause()方法，然后B调用onCreate() ，onStart()， onResume()。这个时候B覆盖了窗体， A会调用onStop()方法. 如果B是个透明的，或者是对话框的样式， 就不会调用A的onStop()方法。 横竖屏切换时Activity的生命周期 此时的生命周期跟清单文件里的配置有关系。 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，默认首先销毁当前activity，然后重新加载。 设置Activity的android:configChanges=\"orientation|keyboardHidden|screenSize\"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 通常在游戏开发， 屏幕的朝向都是写死的。 如何将一个Activity设置成窗口的样式 只需要给我们的Activity配置如下属性即可。 android:theme=\"@android:style/Theme.Dialog\" 如何退出Activity？如何安全退出已调用多个Activity的Application？ 通常情况用户退出一个Activity只需按返回键，我们写代码想退出activity直接调用finish()方法就行。 记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。 // 伪代码 List lists;// 在application 全局的变量里面 lists = new ArrayList(); lists.add(this); for (Activity activity : lists) { activity.finish(); } lists.remove(this); 发送特定广播： 在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。 // 给某个activity 注册接受接受广播的意图 registerReceiver(receiver, filter) // 如果过接受到的是 关闭activity的广播 就调用finish()方法把当前的activity finish()掉 递归退出 在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。 其实也可以通过 intent的flag 来实现intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)激活一个新的activity。此时如果该任务栈中已经有该Activity，那么系统会把这个Activity上面的所有Activity干掉。其实相当于给Activity配置的启动模式为SingleTop。 请描述一下Activity的启动模式都有哪些以及各自的特点 启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。 Activity一共有以下四种launchMode： standard 默认启动模式 singleTop 栈顶复用模式 singleTask 栈内复用模式 singleInstance 单例模式 我们可以在AndroidManifest.xml配置的android:launchMode属性为以上四种之一即可。 下面我们结合实例一一介绍这四种lanchMode： standard standard模式是默认的启动模式，不用为配置android:launchMode属性即可，当然也可以指定值为standard。 我们将创建一个Activity，命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下： public class FirstActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.first); TextView textView = (TextView) findViewById(R.id.tv); textView.setText(this.toString()); Button button = (Button) findViewById(R.id.bt); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(FirstActivity.this, FirstActivity.class); startActivity(intent); } }); } } FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。 然后我们连续点击几次按钮，将会出现下面的现象： 我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FirstActivity。standard模式的原理如下图所示： 如图所示，每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。 这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。 singleTop 我们在上面的基础上为指定属性android:launchMode=\"singleTop\"，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象： 我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示： 正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。 我们再新建一个Activity命名为SecondActivity，如下： public class SecondActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.second); TextView textView = (TextView) findViewById(R.id.tv); textView.setText(this.toString()); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(SecondActivity.this, FirstActivity.class); startActivity(intent); } }); } } 然后将之前的FirstActivity跳转代码改为： Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); 这时候，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下： 我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下： 我们看到，当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。 这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。 singleTask 在上面的基础上我们修改FirstActivity的属性android:launchMode=\"singleTask\"。演示的结果如下： 我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示： 在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。 这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。 singleInstance 这种启动模式比较特殊，因为它会启用一个新的栈结构，将Activity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。 我们修改FirstActivity的launchMode=\"standard\"，SecondActivity的launchMode=\"singleInstance\"，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以，我们为每个Activity添加如下代码： TextView taskIdView = (TextView) findViewById(R.id.taskIdView); taskIdView.setText(\"current task id: \" + this.getTaskId()); 然后我们再演示一下这个流程： 我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下： 我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。 如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示： singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置： 然后我们在其他应用中这样启动该Activity： Intent intent = new Intent(\"android.intent.action.SINGLE_INSTANCE_SHARE\"); startActivity(intent); 当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下： Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/service.html":{"url":"android/service.html","title":"Service","keywords":"","body":"Android面试题：Service Service是否在main thread中执行, service里面是否能执行耗时的操作? 默认情况,如果没有显示的指servic所运行的进程, Service和activity是运行在当前app所在进程的main thread(UI主线程)里面。 service里面不能执行耗时的操作(网络请求，拷贝数据库，大文件)。 特殊情况 ,可以在清单文件配置 service 执行所在的进程，让service在另外的进程中执行。 Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？ Activity通过bindService(Intent service, ServiceConnection conn,int flags)跟Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给conn，这样我们就拿到了Service提供的服务代理对象。 在Activity中可以通过startService和bindService方法启动Service。一般情况下如果想获取Service的服务对象那么肯定需要通过bindService()方法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么可以使用startService()方法。 请描述一下Service的生命周期 service有绑定模式和非绑定模式，以及这两种模式的混合使用方式。不同的使用方法生命周期方法也不同。 非绑定模式：当第一次调用startService的时候执行的方法依次为onCreate()、onStartCommand()，当Service关闭的时候调用onDestory方法。 绑定模式：第一次bindService（）的时候，执行的方法为onCreate()、onBind(）解除绑定的时候会执行onUnbind()、onDestory()。 上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意Service实例只会有一个，也就是说如果当前要启动的Service已经存在了那么就不会再次创建该Service当然也不会调用onCreate（）方法。 一个Service可以被多个客户进行绑定，只有所有的绑定对象都执行了onBind（）方法后该Service才会销毁，不过如果有一个客户执行了onStart()方法，那么这个时候如果所有的bind客户都执行了unBind()该Service也不会销毁。 Service的生命周期图如下所示，帮助大家记忆。 什么是IntentService？有何优点？ 我们通常只会使用Service，可能IntentService对大部分同学来说都是第一次听说。那么看了下面的介绍相信你就不再陌生了。如果你还是不了解那么在面试的时候你就坦诚说没用过或者不了解等。并不是所有的问题都需要回答上来的。 IntentService简介 IntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题： service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中； service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务； IntentService特征 会创建独立的worker线程来处理所有的Intent请求； 会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题； 所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service； 为Service的onBind()提供默认实现，返回null； 为Service的onStartCommand提供默认实现，将请求Intent添加到队列中； 使用IntentService 本人写了一个IntentService的使用例子供参考。该例子中一个MainActivity一个MyIntentService，这两个类都是四大组件当然需要在清单文件中注册。这里只给出核心代码： MainActivity.java public void click(View view){ Intent intent = new Intent(this, MyIntentService.class); intent.putExtra(\"start\", \"MyIntentService\"); startService(intent); } MyIntentService.javapublic class MyIntentService extends IntentService { private String ex = \"\"; private Handler mHandler = new Handler() { public void handleMessage(android.os.Message msg) { Toast.makeText(MyIntentService.this, \"-e \" + ex, Toast.LENGTH_LONG).show(); } }; public MyIntentService(){ super(\"MyIntentService\"); } @Override public int onStartCommand(Intent intent, int flags, int startId) { ex = intent.getStringExtra(\"start\"); return super.onStartCommand(intent, flags, startId); } @Override protected void onHandleIntent(Intent intent) { /* * 模拟执行耗时任务 * 该方法是在子线程中执行的，因此需要用到handler跟主线程进行通信 */ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } mHandler.sendEmptyMessage(0); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行后效果如下： 说说Activity、Intent、Service是什么关系 他们都是Android开发中使用频率最高的类。其中Activity和Service都是Android四大组件之一。他俩都是Context类的子类ContextWrapper的子类，因此他俩可以算是兄弟关系吧。不过兄弟俩各有各自的本领，Activity负责用户界面的显示和交互，Service负责后台任务的处理。Activity和Service之间可以通过Intent传递数据，因此可以把Intent看作是通信使者。 Service和Activity在同一个线程吗 对于同一app来说默认情况下是在同一个线程中的，mainThread （UI Thread）。 Service里面可以弹吐司么 可以的。弹吐司有个条件就是得有一个Context上下文，而Service本身就是Context的子类，因此在Service里面弹吐司是完全可以的。比如我们在Service中完成下载任务后可以弹一个吐司通知用户。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/broad_cast_receiver.html":{"url":"android/broad_cast_receiver.html","title":"BroadCastReceiver","keywords":"","body":"Android面试题：BroadCastReceiver 请描述一下BroadcastReceiver BroadCastReceiver是Android四大组件之一，主要用于接收系统或者app发送的广播事件。广播分两种：有序广播和无序广播。 内部通信实现机制：通过Android系统的Binder机制实现通信。 无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播intent的传播。 有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者A，B，C，优先级是A > B> C。那这个消息先传给A，再传给B，最后传给C。每个接收者有权终止广播，比如B终止广播，C就无法接收到。此外A接收到广播后可以对结果对象进行操作，当广播传给B时，B可以从结果对象中取得A存入的数据。在通过Context.sendOrderedBroadcast(intent, receiverPermission,resultReceiver, scheduler, initialCode, initialData, initialExtras)时我们可以指定resultReceiver广播接收者，这个接收者我们可以认为是最终接收者，通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的onReceive会被执行两次，第一次是正常的按照优先级顺序执行，第二次是作为最终接收者接收。如果比他优先级高的接收者终止了广播，那么他依然能接收到广播。 在我们的项目中经常使用广播接收者接收系统通知，比如开机启动、sd挂载、低电量、外播电话、锁屏等。 如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放之暂停等。 在manifest和代码中如何注册和使用BroadcastReceiver 在清单文件中注册广播接收者称为静态注册，在代码中注册称为动态注册。静态注册的广播接收者只要app在系统中运行则一直可以接收到广播消息，动态注册的广播接收者当注册的Activity或者Service销毁了那么就接收不到广播了。 静态注册：在清单文件中进行如下配置 动态注册：在代码中进行如下注册 receiver = new BroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(CALL_ACTION); context.registerReceiver(receiver, intentFilter); BroadCastReceiver的生命周期 广播接收者的生命周期非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁； 广播接收者中不要做一些耗时的工作，否则会弹出Application No Response错误对话框； 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉； 耗时的较长的工作最好放在服务中完成。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/content_provider.html":{"url":"android/content_provider.html","title":"ContentProvider","keywords":"","body":"Android面试题：ContentProvider 请介绍下ContentProvider是如何实现数据共享的 在Android中如果想将自己应用的数据（一般多为数据库中的数据）提供给第三发应用，那么我们只能通过ContentProvider来实现了。 ContentProvider是应用程序之间共享数据的接口。使用的时候首先自定义一个类继承ContentProvider，然后覆写query、insert、update、delete等方法。因为其是四大组件之一因此必须在AndroidManifest文件中进行注册。 第三方可以通过ContentResolver来访问该Provider。 请介绍下Android的数据存储方式 File存储 SharedPreference存储 ContentProvider存储 SQLiteDataBase存储 网络存储 为什么要用ContentProvider？它和sql的实现上有什么差别？ ContentProvider屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的uri就可以了，ContentProvider可以实现不同app之间共享。 Sql也有增删改查的方法，但是sql只能查询本应用下的数据库。而ContentProvider 还可以去增删改查本地文件. xml文件的读取等。 说说ContentProvider、ContentResolver、ContentObserver之间的关系 ContentProvider 内容提供者，用于对外提供数据 ContentResolver.notifyChange(uri)发出消息 ContentResolver 内容解析者，用于获取内容提供者提供的数据 ContentObserver 内容监听器，可以监听数据的改变状态 ContentResolver.registerContentObserver()监听消息 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/intent.html":{"url":"android/intent.html","title":"Intent","keywords":"","body":"Android面试题：Intent Intent传递数据时，可以传递哪些类型数据？ Intent可以传递的数据类型非常的丰富，java的基本数据类型和String以及他们的数组形式都可以，除此之外还可以传递实现了Serializable和Parcelable接口的对象。 Serializable和Parcelable的区别 在使用内存的时候，Parcelable 类比Serializable性能高，所以推荐使用Parcelable类。 Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。 Parcelable不能使用在要将数据存储在磁盘上的情况。尽管Serializable效率低点，但在这种情况下，还是建议你用Serializable 。 实现： Serializable 的实现，只需要继承Serializable 即可。这只是给对象打了一个标记，系统会自动将其序列化。 Parcelabel 的实现，需要在类中添加一个静态成员变量 CREATOR，这个变量需要继承 Parcelable.Creator 接口。 public class MyParcelable implements Parcelable { private int mData; public int describeContents() { return 0; } public void writeToParcel(Parcel out, int flags) { out.writeInt(mData); } public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { public MyParcelable createFromParcel(Parcel in) { return new MyParcelable(in); } public MyParcelable[] newArray(int size) { return new MyParcelable[size]; } }; private MyParcelable(Parcel in) { mData = in.readInt(); } } 请描述一下Intent和IntentFilter Android 中通过 Intent 对象来表示一条消息，一个 Intent对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。 通过Intent 可以实现各种系统组件的调用与激活。 IntentFilter: 可以理解为邮局或者是一个信笺的分拣系统， 这个分拣系统通过3个参数来识别： Action: 动作view Data: 数据uri Category : 而外的附加信息 Action 匹配 Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件，一个 IntentFilter 可以包含多个 Action。在 AndroidManifest.xml 的 Activity 定义时可以在其 节点指定一个 Action 列表用于标示 Activity 所能接受的“动作”。 例如： …… 如果我们在启动一个 Activity 时使用这样的Intent 对象： Intentintent = new Intent(); intent.setAction(\"cn.itheima.action\"); 那么所有的 Action 列表中包含了“cn.itheima”的 Activity 都将会匹配成功。Android 预定义了一系列的 Action 分别表示特定的系统动作。这些Action 通过常量的方式定义在 android.content. Intent中，以“ACTION_”开头。我们可以在 Android 提供的文档中找到它们的详细说明。 URI 数据匹配 一个 Intent 可以通过 URI 携带外部数据给目标组件。在 节点中，通过 节点匹配外部数据。 mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。如下： 电话的uri：tel:12345 自己定义的uri：itcast://cn.itcast/person/10 如果在 Intent Filter 中指定了这些属性，那么只有所有的属性都匹配成功时 URI 数据匹配才会成功。 Category 类别匹配 节点中可以为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/layout.html":{"url":"android/layout.html","title":"Layout","keywords":"","body":"Android面试题：Layout Android中常用的布局都有哪些 FrameLayout RelativeLayout LinearLayout AbsoluteLayout TableLayout GridLayout 谈谈UI中， Padding和Margin有什么区别？ android:padding和android:layout_margin的区别，其实概念很简单，padding是站在父view的角度描述问题，它规定它里面的内容必须与这个父view边界的距离。margin则是站在自己的角度描述问题，规定自己和其他（上下左右）的view之间的距离，如果同一级只有一个view，那么它的效果基本上就和padding一样了。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/listview.html":{"url":"android/listview.html","title":"ListView","keywords":"","body":"Android面试题：ListView ListView如何提高其效率？ 复用ConvertView 自定义静态类ViewHolder 使用分页加载 使用WeakRefrence引用ImageView对象 当ListView数据集改变后，如何更新ListView 使用该ListView的adapter的notifyDataSetChanged()方法。该方法会使ListView重新绘制。 ListView如何实现分页加载 设置ListView的滚动监听器：setOnScrollListener(new OnScrollListener{….})。在监听器中有两个方法： 滚动状态发生变化的方法(onScrollStateChanged)和listView被滚动时调用的方法(onScroll) 在滚动状态发生改变的方法中，有三种状态： 手指按下移动的状态：SCROLL_STATE_TOUCH_SCROLL: // 触摸滑动 惯性滚动（滑翔（flgin）状态）：SCROLL_STATE_FLING: // 滑翔 静止状态：SCROLL_STATE_IDLE: // 静止 对不同的状态进行处理： 分批加载数据，只关心静止状态：关心最后一个可见的条目，如果最后一个可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以提示用户无更多数据了。 ListView可以显示多种类型的条目吗 这个当然可以的，ListView显示的每个条目都是通过baseAdapter的getView(int position, View convertView, ViewGroup parent)来展示的，理论上我们完全可以让每个条目都是不同类型的view，除此之外adapter还提供了getViewTypeCount()和getItemViewType(int position)两个方法。在getView方法中我们可以根据不同的viewtype加载不同的布局文件。 ListView如何定位到指定位置 可以通过ListView提供的lv.setSelection(48);方法。 当在ScrollView中如何嵌入ListView 通常情况下我们不会在ScrollView中嵌套ListView，但是如果面试官非让我嵌套的话也是可以的。 在ScrollView添加一个ListView会导致listview控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。所以需要通过listview中的item数量去计算listview的显示高度，从而使其完整展示，如下提供一个方法供大家参考。 lv = (ListView) findViewById(R.id.lv); adapter = new MyAdapter(); lv.setAdapter(adapter); setListViewHeightBasedOnChildren(lv); public void setListViewHeightBasedOnChildren(ListView listView) { ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) { return; } int totalHeight = 0; for (int i = 0; i ListView中如何优化图片 图片的优化策略比较多。 处理图片的方式： 如果ListView中自定义的Item中有涉及到大量图片的，一定要对图片进行细心的处理，因为图片占的内存是ListView项中最头疼的，处理图片的方法大致有以下几种： 不要直接拿路径就去循环BitmapFactory.decodeFile;使用Options保存图片大小、不要加载图片到内存去。 对图片一定要经过边界压缩尤其是比较大的图片，如果你的图片是后台服务器处理好的那就不需要了。 在ListView中取图片时也不要直接拿个路径去取图片，而是以WeakReference（使用WeakReference代替强引用。比如可以使用WeakReference mContextRef）、SoftReference、WeakHashMap等的来存储图片信息。 在getView中做图片转换时，产生的中间变量一定及时释放。 异步加载图片基本思想： 先从内存缓存中获取图片显示（内存缓冲） 获取不到的话从SD卡里获取（SD卡缓冲） 都获取不到的话从网络下载图片并保存到SD卡同时加入内存并显示（视情况看是否要显示） 原理： 优化一：先从内存中加载，没有则开启线程从SD卡或网络中获取，这里注意从SD卡获取图片是放在子线程里执行的，否则快速滑屏的话会不够流畅。 优化二：于此同时，在adapter里有个busy变量，表示listview是否处于滑动状态，如果是滑动状态则仅从内存中获取图片，没有的话无需再开启线程去外存或网络获取图片。 优化三：ImageLoader里的线程使用了线程池，从而避免了过多线程频繁创建和销毁，如果每次总是new一个线程去执行这是非常不可取的，好一点的用的AsyncTask类，其实内部也是用到了线程池。在从网络获取图片时，先是将其保存到sd卡，然后再加载到内存，这么做的好处是在加载到内存时可以做个压缩处理，以减少图片所占内存。 ListView中图片错位的问题是如何产生的 图片错位问题的本质源于我们的listview使用了缓存convertView，假设一种场景，一个listview一屏显示九个item，那么在拉出第十个item的时候，事实上该item是重复使用了第一个item，也就是说在第一个item从网络中下载图片并最终要显示的时候，其实该item已经不在当前显示区域内了，此时显示的后果将可能在第十个item上输出图像，这就导致了图片错位的问题。所以解决之道在于可见则显示，不可见则不显示。 Java中引用类型都有哪些 Java中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用（StrongReference） 这个就不多说，我们写代码天天在用的就是强引用。如果一个对象被被人拥有强引用，那么垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 Java的对象是位于heap中的，heap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。应用的强弱顺序是强、软、弱、和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。如下代码： String abc=new String(\"abc\"); // 1 SoftReference softRef=new SoftReference(abc); // 2 WeakReference weakRef = new WeakReference(abc); // 3 abc=null; // 4 softRef.clear(); // 5 第一行在heap堆中创建内容为“abc”的对象，并建立abc到该对象的强引用,该对象是强可及的。 第二行和第三行分别建立对heap中对象的软引用和弱引用，此时heap中的abc对象已经有3个引用，显然此时abc对象仍是强可及的。 第四行之后heap中对象不再是强可及的，变成软可及的。 第五行执行之后变成弱可及的。 软引用（SoftReference） 如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。软引用是主要用于内存敏感的高速缓存。在jvm报告内存不足之前会清除所有的软引用，这样以来gc就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。 什么时候会被收集取决于gc的算法和gc运行时可用内存的大小。当gc决定要收集软引用时执行以下过程,以上面的softRef为例： 首先将softRef的referent（abc）设置为null，不再引用heap中的new String(\"abc\")对象。 将heap中的newString(\"abc\")对象设置为可结束的(finalizable)。 当heap中的new String(\"abc\")对象的finalize()方法被运行而且该对象占用的内存被释放， softRef被添加到它的ReferenceQueue(如果有的话)中。 注意：对ReferenceQueue软引用和弱引用可以有可无，但是虚引用必须有。被 SoftReference 指到的对象，即使没有任何 Direct Reference，也不会被清除。一直要到 JVM 内存不足且没有Direct Reference 时才会清除，SoftReference 是用来设计 object-cache 之用的。如此一来 SoftReference 不但可以把对象 cache 起来，也不会造成内存不足的错误（OutOfMemoryError）。 弱引用（WeakReference） 如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被gc扫描到了随时都会把它干掉。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 虚引用（PhantomReference） \"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 建立虚引用之后通过get方法返回结果始终为null,通过源代码你会发现,虚引用通向会把引用的对象写进referent,只是get方法返回结果为null。先看一下和gc交互的过程再说一下他的作用。 不把referent设置为null, 直接把heap中的newString(\"abc\")对象设置为可结束的(finalizable)。 与软引用和弱引用不同, 先把PhantomRefrence对象添加到它的ReferenceQueue中.然后在释放虚可及的对象。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/jni_ndk.html":{"url":"android/jni_ndk.html","title":"JNI&NDK","keywords":"","body":"Android面试题：JNI&NDK 在Android中如何调用C语言 当我们的Java需要调用C语言的时候可以通过JNI的方式，Java Native Interface。Android提供了对JNI的支持，因此我们在Android中可以使用JNI调用C语言。在Android开发目录的libs目录下添加xxx.so文件，不过xxx.so文件需要放在对应的CPU架构名目录下，比如armeabi，x86等。 在Java代码需要通过 System.loadLibrary(libName); 加载so文件。同时C语言中的方法在java中必须以native关键字来声明。普通Java方法调用这个native方法接口，虚拟机内部自动调用so文件中对应的方法。 请介绍一下NDK NDK 是一系列工具的集合 NDK 提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so 和java 应用一起打包成apk。NDK 集成了交叉编译器，并提供了相应的mk 文件隔离CPU、平台、ABI 等差异，开发人员只需要简单修改mk 文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。 NDK提供了一份稳定、功能有限的API头文件声明 Google 明确声明该API 是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK 中看出，这些API支持的功能非常有限，包含有：C 标准库（libc）、标准数学库（libm）、压缩库（libz）、Log 库（liblog）。 JNI调用常用的两个参数 JNIEnv*env, jobject obj 第一个是指向虚拟机对象的指针，是一个二级指针。里面封装了很多方法和中间变量供我们使用。 第二个代表着调用该方法的Java对象的C语言表示。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/fragment.html":{"url":"android/fragment.html","title":"Fragment","keywords":"","body":"Android面试题：Fragment Fragment跟Activity之间是如何传值的 当Fragment跟Activity绑定之后，在Fragment中可以直接通过 getActivity() 方法获取到其绑定的Activity对象，这样就可以调用Activity的方法了。在Activity中可以通过如下方法获取到Fragment实例： FragmentManager fragmentManager = getFragmentManager(); Fragment fragment = fragmentManager.findFragmentByTag(tag); Fragment fragment = fragmentManager.findFragmentById(id); 获取到Fragment之后就可以调用Fragment的方法。也就实现了通信功能。 描述一下Fragment的生命周期 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/multi_threading.html":{"url":"android/multi_threading.html","title":"多线程","keywords":"","body":"Android面试题：多线程 能否在子线程中更新UI 可以的，在onCreate()的setContentView()后new一个Thread去更新UI是不会报错的，但是延迟1s后再更新UI就会报错，这是因为在onCreate()的时候ViewRoot的requestLayout()方法没有执行，layout布局文件还没有创建完成。 而ViewRoot的requestLayout()方法中才会调用checkThread()方法检查当前是否是主线程，不是的话就抛CalledFromWrongThreadException。 Android中的定义是：不建议在子线程中更新UI，否则会产生不可预知的错误。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"android/network.html":{"url":"android/network.html","title":"网络访问","keywords":"","body":"Android面试题：网络访问 Android中如何访问网络 Android提供了org.apache.http.HttpClientConnection和java.net.HttpURLConnection两个连接网络对象。使用哪个都行，具体要看企业领导的要求了。 除此之外一般我比较喜欢使用xUtils中的HttpUtils功能，该模块底层使用的就是org.apache.http.client.HttpClient，使用起来非常方便。 如何解析服务器传来的JSON文件 在Android中内置了JSON的解析API，在org.json包中包含了如下几个类：JSONArray、JSONObject、JSONStringer、JSONTokener和一个异常类JSONException。 JSON解析步骤 读取网络文件数据并转为一个json字符串 InputStream in = conn.getInputStream(); String jsonStr = DataUtil.Stream2String(in);//将流转换成字符串的工具类 将字符串传入相应的JSON构造函数中 通过构造函数将json字符串转换成json对象 JSONObject jsonObject = new JSONObject(jsonStr)； 通过构造函数将json字符串转换成json数组： JSONArray array = new JSONArray(jsonStr); 解析出JSON中的数据信息： 从json对象中获取你所需要的键所对应的值 JSONObject json=jsonObject.getJSONObject(\"weatherinfo\"); Stringcity = json.getString(\"city\"); Stringtemp = json.getString(\"temp\") 遍历JSON数组，获取数组中每一个json对象，同时可以获取json对象中键对应的值 for(int i = 0; i 生成JSON对象和数组 生成JSON 方法1、创建一个map，通过构造方法将map转换成json对象 Map map = new HashMap(); map.put(\"name\",\"zhangsan\"); map.put(\"age\",24); JSONObjectjson = new JSONObject(map); 方法2、创建一个json对象，通过put方法添加数据 JSONObjectjson=new JSONObject(); json.put(\"name\",\"zhangsan\"); json.put(\"age\",24); 生成JSON数组 创建一个list，通过构造方法将list转换成json对象 Map map1 = new HashMap(); map1.put(\"name\",\"zhangsan\"); map1.put(\"age\",24); Map map2 = new HashMap(); map2.put(\"name\",\"lisi\"); map2.put(\"age\",25); List> list=new ArrayList>(); list.add(map1); list.add(map2); JSONArrayarray=new JSONArray(list); System.out.println(array.toString()); 如何解析服务器传来的XML格式数据 Android为我们提供了原生的XML解析和生成支持。 XML解析 获取解析器: Xml.newPullParser() 设置输入流: setInput() 获取当前事件类型: getEventType() 解析下一个事件, 获取类型: next() 获取标签名: getName() 获取属性值: getAttributeValue() 获取下一个文本: nextText() 获取当前文本: getText() 5种事件类型: START_DOCUMENT, END_DOCUMENT, START_TAG,END_TAG, TEXT 示例代码： public ListgetPersons(InuptStream in){ XmlPullParserparser=Xml.newPullParser();//获取解析器 parser.setInput(in,\"utf-8\"); for(inttype=){ //循环解析 } } XML生成 获取生成工具: Xml.newSerializer() 设置输出流: setOutput() 开始文档: startDocument() 结束文档: endDocument() 开始标签: startTag() 结束标签: endTag() 属性: attribute() 文本: text() 示例代码： XmlSerializer serial=Xml.newSerializer();//获取xml序列化工具 serial.setOuput(put,\"utf-8\"); serial.startDocument(\"utf-8\",true); serial.startTag(null,\"persons\"); for(Person p:persons){ serial.startTag(null,\"persons\"); serial.attribute(null,\"id\",p.getId().toString()); serial.startTag(null,\"name\"); serial.attribute(null,\"name\",p.getName().toString()); serial.endTag(null,\"name\"); serial.startTag(null,\"age\"); serial.attribute(null,\"age\",p.getAge().toString()); serial.endTag(null,\"age\"); serial.endTag(null,\"persons\"); } 如何从网络上加载一个图片显示到界面 可以通过BitmapFactory.decodeStream(inputStream);方法将图片转换为bitmap，然后通过imageView.setImageBitmap(bitmap);将该图片设置到ImageView中。这是原生的方法，还可以使用第三方开源的工具来实现，比如使用SmartImageView作为ImageView控件，然后直接设置一个url地址即可。也可以使用xUtils中的BitmapUtils工具。 如何播放网络视频 除了使用Android提供的MediaPlayer和VideoView外通常还可以使用第三方开源万能播放器，VitamioPlayer。该播放器兼容性好，支持几乎所有主流视频格式。 Everything you need to prepare for your technical interview.modified at 2019-01-27 "},"data_structure/array.html":{"url":"data_structure/array.html","title":"数组","keywords":"","body":"数据结构面试题：数组 在一个给定的从1到100的整型数组中，如何快速找到缺失的数字 如元素无重复，缺失一个数字时可采用下面方法： 二分法：假设有序，如无需先排序，二分查找，时间复杂度 O(logN)。 求和法：1到100之和 - 数组数字之和 = 缺失数字，时间复杂度： O(n)，空间复杂度： O(1)。 异或法：依次位异或1到100，然后继续位异或数组所有数字，结果即为缺失数字，时间复杂度： O(n) ，空间复杂度： O(1)。 Hash法：对数组数据Hash，可以使用BitSet，时间复杂度 O(n) ，空间复杂度 O(n) 。 扩展1：数组中缺失两个数 先排序，然后将原数据拆分成两部分，使用原始问题方法即可。 如求min~max之和 S1，数组元素和 S2，设缺失元素为 a、b，则 S1-S2 = a+b，以 (a+b)/2 为界将排序后的原数据拆分成两部分，问题即变为原始问题。 扩展2：范围1到100，99个出现了偶数次，1个奇数次，求奇数次的数 数组全部元素位异或，结果即为所求。 扩展3：范围1到100，98个出现了偶数次，2个奇数次，求奇数次的数 设两个出现奇数次的数分别为a、b，则数组全部元素位异或结果 c 等于 a^b，则 c 中至少有一位为1（如无则说明两个数相等，不符合题意）。 接着对 c 进行分析，如果 c 中某一位为1，则说明 a、b 两个数在此位上一个为0，一个为1，因此以此位为界，将原数据分成两部分，问题即变为扩展2。 例如范围1~5的原始数据 [1, 3, 2, 5, 4, 2, 6, 6, 3, 5]，全部位异或后 c=5=a^b，二进制为 0101，如将最低位1作为界对原数据分成 [1, 3, 5, 3, 5] 和 [2, 4, 2, 6, 6] 两部分，求最低位1的方法 c-(c&(c-1))，此时使用扩展2方法即可。 如何在不使用Java Collection API的情况下从数组中删除重复项 先排序，然后遍历移除连续出现的重复数据，可直接在原数组上将重复数据置为0（假设原数据中没有0），或者借助临时数组。 在一个未排序的整型数组中，如何找到最大和最小的数字 定义max、min分别保存数值范围的最小值及最大值，循环比较并记录max、min的值即可。 找出一个数组中的两个数字，使这两个数字之和等于一个给定的值 方法一： 直接穷举，从数组中任意取出两个数字，计算两者之和是否为给定的数字。显然其时间复杂度为 O(n(n-1)/2) 即 O(n^2)。 方法二： 使用Hash表，根据Hash表映射查找一个数字是否存在。遍历数组，使用给定值减去数组元素，接着拍段差值是否存在于Hash表中，时间复杂度可降为 O(n)，但会根据数组元素的取值范围使用过大的存储空间。 方法三： 首先对数组进行排序，时间复杂度为 O(n*log2n)。然后令 i=0，j=n-1，判断 arr[i]+arr[j] 是否等于给定数字，如果是则 arr[i]、arr[j]即为所求。如果小于给定数字则 i+=1，否则 j-=1。这样只需在排序后的数组上遍历一次，就可求得结果，时间复杂度为 O(n)。两步加起来总的时间复杂度 O(n*log2n)。 如果一个数组包含多个重复元素，如何找到这些重复的元素 方法一： 使用二重循环两两比较得到重复元素，时间复杂度为 O(n^2)。 for (int i = 0; i 方法二： 使用Set，因为Set不允许插入重复元素，可通过add()的返回值判断元素是否重复，时间复杂度为 O(n)。 for (String name : names) { if (set.add(name) == false) { // 得到重复元素 } } 方法三： 使用哈希表，遍历数组元素通过数组元素值与元素数量构建哈希表，再遍历哈希表输出数量非1的元素即为重复元素。这种方法时间复杂度为 O(n)，与方法二相同，但却能够准确求到重复数量。 // 构造哈希表 for (String name : names) { Integer count = nameAndCount.get(name); if (count == null) { nameAndCount.put(name, 1); } else { nameAndCount.put(name, ++count); } } // 打印重复元素以及重复数量 Set> entrySet = nameAndCount.entrySet(); for (Entry entry : entrySet) { if (entry.getValue() > 1) { System.out.printf(\"duplicate element '%s' and count '%d' :\", entry.getKey(), entry.getValue()); } } 用Java从一个给定数组中删除重复元素 方法一： 不借助数据结构，申请一个跟给定数组一样大小的新数组，遍历给定数组将给定数组中的每一个元素放入新数组中，放入时遍历新数组判断是否已存在，时间复杂度为 O(n^2)。 方法二： 使用List的contains，本质上跟方法一一样。 int[] attr = { 1, 2, 3, 3, 5, 5, 7, 9 }; List list = new ArrayList(); for (int i : attr) { if (!list.contains(i)) { list.add(i); } } 方法三： 使用Set或LinkedHashSet，特别是LinkedHashSet，因为它能够保持元素是有序的，时间复杂度为 O(n)。 方法四： 先排序再遍历放入新数组中，可根据数组有序的特性快速过滤掉重复元素，时间复杂度由排序算法决定。 如何利用快速排序对一个整型数组进行排序 快速排序过程如下。 import java.util.Arrays; public class QuickSortDemo{ public static void main(String args[]) { // unsorted integer array int[] unsorted = {6, 5, 3, 1, 8, 7, 2, 4}; System.out.println(\"Unsorted array :\" + Arrays.toString(unsorted)); QuickSort algorithm = new QuickSort(); // sorting integer array using quicksort algorithm algorithm.sort(unsorted); // printing sorted array System.out.println(\"Sorted array :\" + Arrays.toString(unsorted)); } } class QuickSort { private int input[]; private int length; public void sort(int[] numbers) { if (numbers == null || numbers.length == 0) { return; } this.input = numbers; length = numbers.length; quickSort(0, length - 1); } /* * This method implements in-place quicksort algorithm recursively. */ private void quickSort(int low, int high) { int i = low; int j = high; // pivot is middle index int pivot = input[low + (high - low) / 2]; // Divide into two arrays while (i pivot) { j--; } if (i Output : Unsorted array :[6, 5, 3, 1, 8, 7, 2, 4] Sorted array :[1, 2, 3, 4, 5, 6, 7, 8] 用 Java 实现数组反转 数组第一个元素与最后一个元素交换，第二个元素与倒数第二个元素交换，时间复杂度为 O(n/2)或O(n)，空间复杂度O(1)。 Everything you need to prepare for your technical interview.modified at 2019-03-05 "},"data_structure/linked_list.html":{"url":"data_structure/linked_list.html","title":"链表","keywords":"","body":"数据结构面试题：链表 遍历一遍确定单链表的中间节点 使用两个指针a、b，a每次移动一个节点，b每次移动两个节点，当b指向末尾时，a指向中间节点。 public class LinkedListTest { public static void main(String args[]) { LinkedList linkedList = new LinkedList(); LinkedList.Node head = linkedList.head(); linkedList.add( new LinkedList.Node(\"1\")); linkedList.add( new LinkedList.Node(\"2\")); linkedList.add( new LinkedList.Node(\"3\")); linkedList.add( new LinkedList.Node(\"4\")); LinkedList.Node current = head; int length = 0; LinkedList.Node middle = head; while(current.next() != null){ length++; if(length%2 ==0){ middle = middle.next(); } current = current.next(); } if(length%2 == 1){ middle = middle.next(); } System.out.println(\"length of LinkedList: \" + length); System.out.println(\"middle element of LinkedList : \" + middle); } } class LinkedList{ private Node head; private Node tail; public LinkedList(){ this.head = new Node(\"head\"); tail = head; } public Node head(){ return head; } public void add(Node node){ tail.next = node; tail = node; } public static class Node{ private Node next; private String data; public Node(String data){ this.data = data; } public String data() { return data; } public void setData(String data) { this.data = data; } public Node next() { return next; } public void setNext(Node next) { this.next = next; } public String toString(){ return this.data; } } } Output: length of LinkedList: 4 middle element of LinkedList: 2 判断链表是否为循环链表 准备快速和慢速两个指针 在每次循环中快速指针移动两个节点，慢速指针移动一个节点 如果快速指针和慢速指针相遇则链表包含循环 如果快速指针指向null或快速指针的下一个节点为null，则链表不是循环的 public class LinkedList { private Node head; public LinkedList() { this.head = new Node(\"head\"); } public Node head() { return head;} public void appendIntoTail(Node node) { Node current = head; while(current.next() != null){ current = current.next(); } current.setNext(node); } public boolean isCyclic(){ Node fast = head; Node slow = head; while(fast!= null && fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow ){ return true; } } return false; } @Override public String toString(){ StringBuilder sb = new StringBuilder(); Node current = head.next(); while(current != null){ sb.append(current).append(\"-->\"); current = current.next(); } sb.delete(sb.length() - 3, sb.length()); // to remove --> from last node return sb.toString(); } public static class Node { private Node next; private String data; public Node(String data) { this.data = data; } public String data() { return data; } public void setData(String data) { this.data = data;} public Node next() { return next; } public void setNext(Node next) { this.next = next; } @Override public String toString() { return this.data; } } } 如何找到带循环的链表中循环的开始位置 遍历节点，第一个出现两次的节点就是循环的开始位置。 如何翻转链表 public class SinglyLinkedList { private Node head; public void append(T data){ if(head == null){ head = new Node(data); return; } tail().next = new Node(data); } private Node tail() { Node tail = head; // Find last element of linked list known as tail while(tail.next != null){ tail = tail.next; } return tail; } @Override public String toString(){ StringBuilder sb = new StringBuilder(); Node current = head; while(current != null){ sb.append(current).append(\"-->\"); current = current.next; } if(sb.length() &gt;=3){ sb.delete(sb.length() - 3, sb.length()); } return sb.toString(); } // 循环 public void reverseIteratively() { Node current = head; Node previous = null; Node forward = null; while(current.next != null){ forward = current.next; current.next = previous; previous = current; current = forward; } head = current; head.next = previous; } private Node reverseRecursively(Node node){ Node newHead; if((node.next == null)){ return node; } newHead = reverseRecursively(node.next); node.next.next = node; node.next = null; return newHead; } // 递归 public void reverseRecursively(){ head = reverseRecursively(head); } private static class Node { private Node next; private T data; public Node(T data) { this.data = data; } @Override public String toString() { return data.toString(); } } } 移除未排序链表中的重复结点 要想移除链表中的重复结点，我们需要设法记录有哪些是重复的。这里只要用到一个简单的散列表。 在下面的解法中，直接迭代访问整个链表，将每个结点加入散列表。若发现有重复元素，则将该结点从链表中移除，然后继续迭代。这个题目使用了链表，因此只需扫描一次就能搞定。 public static void deleteDups(LinkedListNode n) { Hashtable table = new Hashtable(); LinkedListNode previous = null; while (n != null) { if (table.containsKey(n.data)) { previous.next = n.next; } else { table.put(n.data, true); previous = n; } n = n.next; } } 移除未排序链表中的重复结点，不使用缓存区 如不借助额外的缓冲区，可以用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的结点是否重复。空间复杂度为O(1)，但时间复杂度为O(n^2)。 public static void deleteDups(LinkedListNode head) { if (head == null) return; LinkedListNode current = head; while (current != null) { /* 移除后续值相同的所有结点*/ LinkedListNode runner = current; while (runner.next != null) { if (runner.next.data == current.data) { runner.next = runner.next.next; } else { runner = runner.next; } } current = current.next; } } 如何确定链表长度 循环 public int length(){ int count=0; Node current = this.head; while(current != null){ count++; current=current.next() } return count; } 递归 public int length(Node current){ if(current == null){ //base case return 0; } return 1+length(current.next()); } 找出单向链表中倒数第k个结点 下面会以递归和非递归的方式解决这个问题。一般来说，递归解法更简洁，但效率比较差。例如，就这个问题来说，递归解法的代码量大概只有迭代解法的一半，但要占用O(n)空间，其中n为链表结点个数。 注意，在下面的解法中，k定义如下：传入k = 1将返回最后一个结点，k = 2返回倒数第2个结点，依此类推。当然，也可以将k定义为k = 0返回最后一个结点。 解法1：链表长度已知 若链表长度已知，那么，倒数第k个结点就是第(length - k)个结点。直接迭代访问链表就能找到这个结点。不过，这个解法太过简单了，不大可能是面试官想要的答案。 解法2：递归 这个算法会递归访问整个链表，当抵达链表末端时，该方法会回传一个置为0的计数器。之后的每次调用都会将这个计数器加1。当计数器等于k时，表示我们访问的是链表倒数第k个元素。 实现代码简洁明了，前提是我们要有办法通过栈“回传”一个整数值。可惜，我们无法用一般的返回语句回传一个结点和一个计数器，那该怎么办？ 方法A：不返回该元素 一种方法是对这个问题略作调整，只打印倒数第k个结点的值。然后，直接通过返回值传回 计数器值。 public static int nthToLast(LinkedListNode head, int k) { if (head == null) { return 0; } int i = nthToLast(head.next, k) + 1; if (i == k) { System.out.println(head.data); } return i; } 当然，只有得到面试官的首肯，这个解法才算有效。 方法B：使用C++ 第二种解法是使用C++，并通过引用传值。这样一来，我们就可以返回结点值，而且也能通 过传递指针更新计数器。 node* nthToLast(node* head, int k, int& i) { if (head == NULL) { return NULL; } node * nd = nthToLast(head->next, k, i); i = i + 1; if (i == k) { return head; } return nd; } 方法C：创建包裹类 前面提到，这里的难点在于我们无法同时返回计数器和索引值。如果用一个简单的类（或一个单元素数组）包裹计数器值，就可以模仿按引用传递。 public class IntWrapper { public int value = 0; } LinkedListNode nthToLastR2(LinkedListNode head, int k, IntWrapper i) { if (head == null) { return null; } LinkedListNode node = nthToLastR2(head.next, k, i); i.value = i.value + 1; if (i.value == k) { // 找到倒数第k个元素 return head; } return node; } 因为有递归调用，这些递归解法都需要占用O(n)空间。 还有不少其他解法这里并未提及。我们可以将计数器存放在静态变量中，或者，可以创建一个类，存放结点和计数器，并返回这个类的实例。不论选用哪种解法，我们都要设法更新结点和计数器，并在每层递归调用的栈都能访问到。 解法3：迭代法 一种效率更高但不太直观的解法是以迭代方式实现。我们可以使用两个指针p1和p2，并将它们指向链表中相距k个结点的两个结点，具体做法是先将p1和p2指向链表首结点，然后将p2向前移动k个结点。之后，我们以相同的速度移动这两个指针，p2会在移动LENGTH - k步后抵达链表尾结点。此时，p1会指向链表第LENGTH - k个结点，或者说倒数第k个结点。 下面的代码实现了该算法。 LinkedListNode nthToLast(LinkedListNode head, int k) { if (k 这个算法的时间复杂度为O(n)，空间复杂度为O(1)。 Everything you need to prepare for your technical interview.modified at 2019-03-05 "},"data_structure/string.html":{"url":"data_structure/string.html","title":"字符串","keywords":"","body":"数据结构面试题：字符串 确定一个字符串的所有字符是否全都不同 一开始，不妨先问问面试官，上面的字符串是ASCII字符串还是Unicode字符串。这很重要，问这个问题表明你关注细节，并且对计算机科学有深刻了解。 为了简单起见，这里假定字符集为ASCII。若不是的话，则需扩大存储空间，不过其余逻辑没有分别。 假定字符集为ASCII，对于这个问题，我们可以做一个简单的优化，若字符串的长度大于字母表中的字符个数，则直接返回false。毕竟，若字母表只有256个字符，字符串里就不可能有280个各不相同的字符。 第一种解法是构建一个布尔值的数组，索引值i对应的标记指示该字符串是否含有字母表第i个字符。若这个字符第二次出现，则立即返回false。 下面是这个算法的实现代码。 public boolean isUniqueChars2(String str) { if (str.length() > 256) return false; boolean[] char_set = new boolean[256]; for (int i = 0; i 这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。 使用位向量（bit vector），可以将空间占用减少为原先的1/8。下面的代码假定字符串只含有小写字母a到z。这样一来，我们只需使用一个int型变量。 public boolean isUniqueChars(String str) { if (str.length() > 26) return false; int checker = 0; for (int i = 0; i 0) { return false; } checker |= (1 另外，还有以下两种解法。 将字符串中的每一个字符与其余字符进行比较。这种方法的时间复杂度为O(n2 )，空间复杂度为O(1)。 若允许修改输入字符串，可以在O(n log(n))时间里对字符串排序，然后线性检查其中有无相邻字符完全相同的情况。不过，值得注意的是，很多排序算法会占用额外的空间。 从某些方面来看，这些算法算不上最优，不过，从问题的限制条件来看，或许还算是不错的解法。 使用C/C++实现反转一个null结尾的字符串 这是很经典的面试题，你可能会忽略的是：不分配额外空间，直接就地反转字符串，另外，还要注意null字符。 void reverse(char *str) { char* end = str; char tmp; if (str) { // 找出字符串末尾 while (*end) { ++end; } // 回退一个字符，最后一个为null字符 --end; // 从字符串首尾开始交换两个字符，直至两个指针在中间碰头 while (str 上面的代码只是实现这个解法的诸多方法之一。我们甚至还可以递归实现这段代码，但并不推荐这么做。 确定一个字符串的字符重新排列后能否变成另一个字符串 跟其他许多问题一样，首先我们应该向面试官确认一些细节，弄清楚变位词（anagram）比较是否区分大小写。比如，God是否为dog的变位词？此外，我们还应该问清楚是否要考虑空白字符。 这里假定变位词比较区分大小写，空白也要考虑在内。也就是说，“god ”不是“dog”的变位词。 比较两个字符串时，只要两者长度不同，就不可能是变位词。 解决这个问题有两个简单的解决方法，并且都采用了上述优化，即先比较字符串长度。 解法1：排序字符串 若两个字符串互为变位词，那么它们拥有同一组字符，只不过顺序不同。因此，对字符串排序，组成这两个变位词的字符就会有相同的顺序。我们只需比较排序后的字符串。 public String sort(String s) { char[] content = s.toCharArray(); java.util.Arrays.sort(content); return new String(content); } public boolean permutation(String s, String t) { if (s.length() != t.length()) { return false; } return sort(s).equals(sort(t)); } 在某种程度上，这个算法算不上最优，不过换个角度看，该算法或许更可取：它清晰、简单且易懂。从实践角度来看，这可能是解决该问题的上佳之选。 不过，要是效率当头，我们可以换种做法。 解法2：检查两个字符串的各字符数是否相同 我们还可以充分利用变位词的定义——组成两个单词的字符数相同——来实现这个算法。我们只需遍历字母表，计算每个字符出现的次数。然后，比较这两个数组即可。 public boolean permutation(String s, String t) { if (s.length() != t.length()) { return false; } int[] letters = new int[256]; // 假设条件 char[] s_array = s.toCharArray(); for (char c : s_array) { // 计算字符串s中每个字符出现的次数 letters[c]++; } for (int i = 0; i 注意第6行的假设条件。在面试中，最好跟面试官核实一下字符集的大小。这里假设字符集为ASCII。 将字符串中的空格全部替换为“%20” 假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） 处理字符串操作问题时，常见做法是从字符串尾部开始编辑，从后往前反向操作。这种做法很有用，因为字符串尾部有额外的缓冲，可以直接修改，不必担心会覆写原有数据。 我们将采用上面这种做法。该算法会进行两次扫描。第一次扫描先数出字符串中有多少空格，从而算出最终的字符串有多长。第二次扫描才真正开始反向编辑字符串。检测到空格则将%20复制到下一个位置，若不是空白，就复制原先的字符。 下面是这个算法的实现代码。 public void replaceSpaces(char[] str, int length) { int spaceCount = 0, newLength, i; for (i = 0; i = 0; i--) { if (str[i] == ‘ ’) { str[newLength - 1] = ‘0’; str[newLength - 2] = ‘2’; str[newLength - 3] = ‘%’; newLength = newLength - 3; } else { str[newLength - 1] = str[i]; newLength = newLength - 1; } } } 因为Java字符串是不可变的（immutable），所以我们选用了字符数组来解决这个问题。若直接使用字符串，返回时就要把字符串复制一份，不过，这么做的好处是只需扫描一次。 利用字符重复出现的次数实现基本的字符串压缩功能 比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。 乍一看，编写这个方法似乎相当简单，实则有点复杂。我们会迭代访问字符串，将字符拷贝至新字符串，并数出重复字符。这能有多难呢？ public String compressBad(String str) { String mystr = \"\"; char last = str.charAt(0); int count = 1; for (int i = 1; i 这段代码并未处理压缩后字符串比原始字符串长的情况，但除此之外，全都满足要求。这种做法效率够高吗？不妨分析一下这段代码的执行时间。 这段代码的执行时间为O(p + k2 )，其中p为原始字符串长度，k为字符序列的数量。比如，若字符串为aabccdeeaa，则总计有6个字符序列。执行速度慢的原因是字符串拼接操作的时间复杂度为O(n2 )（参见8.1节的StringBuffer部分）。 我们可以使用StringBuffer优化部分性能。 String compressBetter(String str) { /* 检查压缩后的字符串是否会变得更长*/ int size = countCompression(str); if (size >= str.length()) { return str; } StringBuffer mystr = new StringBuffer(); char last = str.charAt(0); int count = 1; for (int i = 1; i 这个算法要好得多。注意，我们在第2～5行代码中加入了长度检查。 若不想或不能使用StringBuffer，我们还是可以高效地解决这个问题。第2行代码会算出字符串压缩后的长度，这样就可以构建出相应大小的字符数组，代码实现如下： String compressAlternate(String str) { /* 检查压缩后的字符串是否会变得更长*/ int size = countCompression(str); if (size >= str.length()) { return str; } char[] array = new char[size]; int index = 0; char last = str.charAt(0); int count = 1; for (int i = 1; i 跟第二种解法一样，执行上述代码的时间复杂度为O(N)，空间复杂度为O(N)。 判断一个字符串是否由另一个字符串旋转而来 假定有一个方法isSubstring，可检查一个单词是否为其他字符串的子串。给定两个字符串s1 和s2，请编写代码检查s2 是否为s1 旋转而成，要求只能调用一次isSubstring。（比如，waterbottle是erbottlewat旋转后的字符串。） 假定s2由s1旋转而成，那么，我们可以找出旋转点在哪。例如，若以wat对waterbottle旋转，就会得到erbottlewat。在旋转字符串时，我们会把s1切分为两部分：x和y，并将它们重新组合成s2。 s1 = xy = waterbottle x = wat y = erbottle s2 = yx = erbottlewat 因此，我们需要确认有没有办法将s1切分为x和y，以满足xy = s1和yx = s2。不论x和y之间的分割点在何处，我们会发现yx肯定是xyxy的子串。也即，s2总是s1s1的子串。 上述分析正是这个问题的解法：直接调用isSubstring(s1s1, s2)即可。 下面是上述算法的实现代码。 public boolean isRotation(String s1, String s2) { int len = s1.length(); /* 检查s1和s2是否等长且不为空*/ if (len == s2.length() && len > 0) { /* 拼接s1和s1，放入新字符串中*/ String s1s1 = s1 + s1; return isSubstring(s1s1, s2); } return false; } Everything you need to prepare for your technical interview.modified at 2019-03-12 "},"data_structure/tree_bragh.html":{"url":"data_structure/tree_bragh.html","title":"树与图","keywords":"","body":"数据结构面试题：树与图 实现一个函数，检查二叉树是否平衡 在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。 还算幸运，此题至少明确给出了平衡树的定义：任意一个结点，其两棵子树的高度差不大于1。根据该定义可以得到一种解法，即直接递归访问整棵树，计算每个结点两棵子树的高度。 public static int getHeight(TreeNode root) { if (root == null) return 0; // 终止条件 return Math.max(getHeight(root.left), getHeight(root.right)) + 1; } public static boolean isBalanced(TreeNode root) { if (root == null) return true; // 终止条件 int heightDiff = getHeight(root.left) - getHeight(root.right); if (Math.abs(heightDiff) > 1) { return false; } else { // 递归 return isBalanced(root.left) && isBalanced(root.right); } } 虽然可行，但效率不太高，这段代码会递归访问每个结点的整棵子树。也就是说，getHeight会被反复调用计算同一个结点的高度。因此，这个算法的时间复杂度为O(N log N)。 我们可以删减部分getHeight调用。 仔细查看上面的方法，你或许会发现，getHeight不仅可以检查高度，还能检查这棵树是否平衡。那么，我们发现子树不平衡时又该怎么做呢？直接返回-1。 改进过的算法会从根结点递归向下检查每棵子树的高度。我们会通过checkHeight方法，以递归方式获取每个结点左右子树的高度。若子树是平衡的，则checkHeight返回该子树的实际高度。若子树不平衡，则checkHeight返回-1。checkHeight会立即中断执行，并返回-1。 下面是该算法的实现代码。 public static int checkHeight(TreeNode root) { if (root == null) { return 0; // 高度为0 } /* 检查左子树是否平衡*/ int leftHeight = checkHeight(root.left); if (leftHeight == -1) { return -1; // 不平衡 } /* 检查左子树是否平衡*/ int rightHeight = checkHeight(root.right); if (rightHeight == -1) { return -1; // 不平衡 } /* 检查当前结点是否平衡*/ int heightDiff = leftHeight - rightHeight; if (Math.abs(heightDiff) > 1) { return -1; // 不平衡 } else { /* 返回高度*/ return Math.max(leftHeight, rightHeight) + 1; } } public static boolean isBalanced(TreeNode root) { if (checkHeight(root) == -1) { return false; } else { return true; } } 这段代码需要O(N)的时间和O(H)的空间，其中H为树的高度。 创建一棵高度最小的二叉查找树 给定一个有序整数数组，元素各不相同且按升序排列。 要创建一棵高度最小的树，就必须让左右子树的结点数量越接近越好。也就是说，我们要让数组中间的值成为根结点，这么一来，数组左边一半就成为左子树，右边一半成为右子树。 然后，我们继续以类似方式构造整棵树。数组每一区段的中间元素成为子树的根结点，左半部分成为左子树，右半部分成为右子树。 一种实现方式是使用简单的root.insertNode(int v)方法，从根结点开始，以递归方式将值v插入树中。这么做的确能构造最小高度的树，但效率并不是太高。每次插入操作都要遍历整棵树，时间开销为O(N log N)。 另一种做法是以递归方式运用createMinimalBST方法，从而消除部分多余的遍历操作。这个方法会传入数组的一个区段，并返回最小树的根结点。 该算法简述如下。 将数组中间位置的元素插入树中。 将数组左半边元素插入左子树。 将数组右半边元素插入右子树。 递归处理。 下面是该算法的实现代码。 TreeNode createMinimalBST(int arr[], int start, int end) { if (end 尽管这段代码看起来不是特别复杂，但在编写过程中很容易犯了差一错误（off-by-one）。对这部分代码，务必进行详尽测试。 创建含有一颗二叉树某一深度上所有结点的链表 给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表，比如，若一棵树的深度为D，则会创建出D个链表。 乍一看，你可能认为这个问题需要一层一层逐一遍历，但其实并无必要。你可以用任意方式遍历整棵树，只要记住结点位于哪一层即可。 我们可以将前序遍历算法稍作修改，将level + 1传入下一个递归调用。下面是使用深度优先搜索的实现代码。 void createLevelLinkedList(TreeNode root, ArrayList> lists, int level) { if (root == null) return; // 终止条件 LinkedList list = null; if (lists.size() == level) { // 该层不在链表中 list = new LinkedList(); /* 以中序遍历所有层级，因此，若这是第一次 * 访问第i层，则表示我们已访问过第0到i-1层。 * 因此，我们可以安全地将这一层加到链表 * 末端。*/ lists.add(list); } else { list = lists.get(level); } list.add(root); createLevelLinkedList(root.left, lists, level + 1); createLevelLinkedList(root.right, lists, level + 1); } ArrayList> createLevelLinkedList( TreeNode root) { ArrayList> lists = new ArrayList>(); createLevelLinkedList(root, lists, 0); return lists; } 另一种做法是对广度优先搜索稍加修改，即从根结点开始迭代，然后第2层，第3层，等等。 处于第i层时，则表明我们已访问过第i-1层的所有结点。也就是说，要得到i层的结点，只需直接查看i-1层结点的所有子结点即可。 下面是该算法的实现代码。 ArrayList> createLevelLinkedList(TreeNode root) { ArrayList> result = new ArrayList>(); /* 访问根结点*/ LinkedList current = new LinkedList(); if (root != null) { current.add(root); } while (current.size() > 0) { result.add(current); // 加入上一层 LinkedList parents = current; // 转到下一层 current = new LinkedList(); for (TreeNode parent : parents) { /* 访问子结点*/ if (parent.left != null) { current.add(parent.left); } if (parent.right != null) { current.add(parent.right); } } } return result; } 你可能会问，这两种解法哪一种效率更高？两者的时间复杂度皆为O(N)，那么空间效率呢？乍一看，我们可能会以为第二种解法的空间效率更高。 在某种意义上，这么说也对。第一种解法会用到O(log N)次递归调用（在平衡树中），每次调用都会在栈里增加一级。第二种解法采用迭代遍历法，不需要这部分额外空间。 不过，两种解法都要返回O(N)数据，因此，递归实现所需的额外O(log N)空间，跟必须传回的O(N)数据相比，并不算多。虽然第一种解法确实使用了较多的空间，但从大O记法的角度来看，两者效率是一样的。 实现一个函数，检查一棵二叉树是否为二叉查找树 此题有两种不同的解法。第一种是利用中序遍历，第二种则建立在left 这项特性之上。 解法1：中序遍历 看到此题，闪过的第一个想法可能是中序遍历，将所有元素复制到数组中，然后检查该数组是否有序。这种解法要多用一点内存，大部分情况下都没问题。 唯一的问题在于，它无法正确处理树中的重复值。例如，该算法无法区分下面这两棵树（其中一棵是无效的），因为两者的中序遍历结果相同。 Valid BST [20.left = 20] Invalid BST [20.right = 20] 不过，要是假定这棵树不得包含重复值，那么这种做法还是行之有效的。该方法的伪码大致如下： public static int index = 0; public static void copyBST(TreeNode root, int[] array) { if (root == null) return; copyBST(root.left, array); array[index] = root.data; index++; copyBST(root.right, array); } public static boolean checkBST(TreeNode root) { int[] array = new int[root.size]; copyBST(root, array); for (int i = 1; i 注意，这里必须记录数组在逻辑上的“尾部”，用它来分配空间以储存所有元素。 仔细审视这个解法，我们就会发现代码中的数组实无必要。除了用来比较某个元素和前一个元素，别无他用。那么，为什么不在进行比较时，直接记下最后的元素？ 下面是该算法的实现代码。 public static int last_printed = Integer.MIN_VALUE; public static boolean checkBST(TreeNode n) { if (n == null) return true; // 递归检查左子树 if (!checkBST(n.left)) return false; // 检查当前结点 if (n.data 要是不喜欢使用静态变量，可以稍作修改，使用包裹类存放这个整数值，如下所示： class WrapInt { public int value; } 或者，若用C++或其他支持按引用传值的语言实现，就可以这么做。 解法2：最小/最大法 第二种解法利用的是二叉查找树的定义。 一棵什么样的树才成其为二叉查找树？我们知道这棵树必须满足以下条件：对于每个结点，left.data ，但是这样还不够。试看下面这棵小树： 尽管每个结点都比左子结点大，比右子结点小，但这显然不是一棵二叉查找树，其中25的位置不对。 更准确地说，成为二叉查找树的条件是：所有左边的结点必须小于或等于当前结点，而当前结点必须小于所有右边的结点。 利用这一点，我们可以通过自上而下传递最小和最大值来解决这个问题。在迭代遍历整个树的过程中，我们会用逐渐变窄的范围来检查各个结点。 以下面这棵树为例： 首先，从(min = INT_MIN, max = INT_MAX)这个范围开始，根结点显然落在其中。然后处理左子树，检查这些结点是否落在(min = INT_MIN, max = 20)范围内。然后再处理（值为10的结点）右子树，检查结点是否落在(min = 20, max = INT_MAX)范围内。 然后，继续依此遍历整棵树。进入左子树时，更新max。进入右子树时，更新min。只要有任一结点不能通过检查，则停止并返回false。 这种解法的时间复杂度为O(N)，其中N为整棵树的结点数。我们可以证明这已经是最佳做法，因为任何算法都必须访问全部N个结点。 因为用了递归，对于平衡树，空间复杂度为O(log N)。在调用栈上，共有O(log N)个递归用，因为递归的深度最大会到这棵树的深度。 该解法的递归实现代码如下： boolean checkBST(TreeNode n) { return checkBST(n, Integer.MIN_VALUE, Integer.MAX_VALUE); } boolean checkBST(TreeNode n, int min, int max) { if (n == null) { return true; } if (n.data = max) { return false; } if (!checkBST(n.left, min, n.data) || !checkBST(n.right, n.data, max)) { return false; } return true; } 记住，在递归算法中，一定要确定终止条件以及结点为空的情况得到妥善处理。 找出二叉查找树中指定结点的“下一个”结点（也即中序后继） 可以假定每个结点都含有指向父结点的连接 回想一下中序遍历，它会遍历左子树，然后是当前结点，接着是右子树。要解决这个问题，必须非常小心，想想具体是怎么回事。 假定我们有一个假想的结点。我们知道访问顺序为左子树，当前结点，然后是右子树。显然，下一个结点应该位于右边。 不过，到底是右子树的哪个结点呢？如果中序遍历右子树，那它就会是接下来第一个被访问的结点，也就是说，它应该是右子树最左边的结点。够简单吧！ 但是，若这个结点没有右子树，又该怎么办？这种情况就有点棘手了。 若结点n没有右子树，那就表示已遍访n的子树。我们必须回到n的父结点，记作q。 若n在q的左边，那么，下一个我们应该访问的结点就是q（中序遍历，left -> current ->right）。 若n在q的右边，则表示已遍访q的子树。我们需要从q往上访问，直至找到我们还未完全遍访过的结点x。怎么才能知道还未完全遍历结点x呢？之前从左结点访问至其父结点时，就已碰到了这种情况。左结点已完全遍历，但其父结点尚未完全遍历。 伪码如下： Node inorderSucc(Node n) { if (n has a right subtree) { return leftmost child of right subtree } else { while (n is a right child of n.parent) { n = n.parent; // 往上 } return n.parent; // 父结点还未遍历 } } 且慢，如果一路往上遍访这棵树都没发现左结点呢？只有当我们遇到中序遍历的最末端时，才会出现这种情况。也就是说，如果我们已位于树的最右边，那就不会再有中序后继，此时该返回null。 下面是该算法的实现代码（已正确处理结点为空的情况）。 public TreeNode inorderSucc(TreeNode n) { if (n == null) return null; /* 找到右子结点，则返回右子树里 * 最左边的结点*/ if (n.right != null) return leftMostChild(n.right); } else { TreeNode q = n; TreeNode x = q.parent; // 向上直至位于左边而不是右边 while (x != null && x.left != q) { q = x; x = x.parent; } return x; } } public TreeNode leftMostChild(TreeNode n) { if (n == null) { return null; } while (n.left != null) { n = n.left; } return n; } 这不是世上最复杂的算法问题，但要写出完美无瑕的代码却有难度。面对这类问题，比较实用的做法是用伪码勾勒大纲，仔细描绘各种不同的情况。 Everything you need to prepare for your technical interview.modified at 2019-03-12 "},"data_structure/other.html":{"url":"data_structure/other.html","title":"杂项","keywords":"","body":"数据结构面试题：其它 杂项 冒泡排序是如何实现的? (解答) 迭代式快排算法是如何实现的？(解答) 你如何实现插入排序算法？(解答) 合并排序算法是如何实现的？(解答) 桶排序算法是如何实现的？(解答) 计数排序算法是如何实现的？(解答) 基数排序算法是如何实现的？(解答) 在不使用第三个变量的前提下如何交换两个数？(解答) 如何检查两个矩形是否重叠？(解答) 如何设计一个自动售货机？(解答) Everything you need to prepare for your technical interview.modified at 2019-03-05 "},"hr/hr.html":{"url":"hr/hr.html","title":"人事面试","keywords":"","body":"人事面试题 请你自我介绍一下你自己 回答提示：一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。 你觉得你个性上最大的优点是什么 回答提示：沉着冷静、条理清楚、立场坚定、顽强向上。 乐于助人和关心他人、适应能力和幽默感、乐观和友爱。 说说你最大的缺点 回答提示：这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌芨可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。企业喜欢聪明的求职者。 你对加班的看法 回答提示：实际上好多公司问这个问题，并不证明一定要加班。 只是想测试你是否愿意为公司奉献。 回答样本：如果是工作需要我会义不容辞加班。我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班 你对薪资的要求 回 答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱。他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一：“我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多 回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训。而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。 回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。 在五年的时间内，你的职业规划 回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到。比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。 你朋友对你的评价 回答提示： 想从侧面了解一下你的性格及与人相处的问题。 回答样本：“我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。 回答样本：”我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题“ 你还有什么问题要问吗 回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没有问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办 回答提示：一段时间发现工作不适合我，有两种情况： 1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距； 2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做 回答提示： 原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法； 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作； 还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办 回答提示： 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决； 是责任问题。分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误 如果你在这次考试中没有被录用，你怎么打算 回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败. 第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我. 第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人. 第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质. 第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩. 第五、再接再厉,成为软件工程师或网络工程师一直是我的梦想,以后如果有机会我仍然后再次参加竞争. 如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样 回答提示：我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：1.我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他；2.他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。 谈谈你对跳槽的看法 回答提示： 正常的\"跳槽\"能促进人才合理流动，应该支持； 频繁的跳槽对单位和个人双方都不利，应该反对。 工作中你难以和同事、上司相处，你该怎么办 回答提示： 我会服从领导的指挥，配合同事的工作。 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好。如果是这样的话 我会努力改正。 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足。有问题就及时改正。 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的！ 假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办 回答提示： 成绩比较突出，得到领导的肯定是件好事情，以后更加努力 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。 工作中，切勿伤害别人的自尊心 不再领导前拨弄是非 乐于助人对面 你最近是否参加了培训课程？谈谈培训课程的内容。是公司资助还是自费参加 回答提示：可以回答一些线上的自我提升的平台,极客学院,慕课网等. 你对于我们公司了解多少 回答提示：在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。 请说出你选择这份工作的动机 回答提示：这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。 你最擅长的技术方向是什么 回答提示：说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。 你能为我们公司带来什么呢 回答提示： 其实我们为公司所做的，也就是为自己所做的，你在为公司不断付出，取得业绩的同时，也是实现了自己价值，自我成为，所以在回答“你能为公司带来什么”时，不妨站在以上角度 最能概括你自己的三个词是什么 回答提示： 我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释， 你的业余爱好是什么 回答提示：找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。 作为被面试者给我打一下分 回答提示：试着列出四个优点和一个非常非常非常小的缺点，（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。 你怎么理解你应聘的职位 回答提示：把岗位职责和任务及工作态度阐述一下 喜欢这份工作的哪一点 回 答提示：相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。 为什么要离职 回答提示： 回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象；建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。 我希望能获得一份更好的工作，如果机会来临，我会抓住；我觉得目前的工作，已经达到顶峰，即沒有升迁机会。 说说你对行业、技术发展趋势的看法 回答提示：企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。 对工作的期望与目标何在 回答提示：这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为了达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。”其他类的工作也可以比照这个方式来回答，只要在目标方面稍微修改一下就可以了。 说说你的家庭 回答提示：企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭！我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。 就你申请的这个职位，你认为你还欠缺什么 回答提示：企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。 你欣赏哪种性格的人 回答提示：诚实、不死板而且容易相处的人、有\"实际行动\"的人。 你通常如何处理別人的批评 回答提示：①沈默是金。不必说什么，否则情况更糟，不过我会接受建设性的批评；②我会等大家冷靜下来再讨论。 你怎样对待自己的失敗 回答提示：我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。 什么会让你有成就感 回答提示：为贵公司竭力效劳；尽我所能，完成一个项目 眼下你生活中最重要的是什么 回答提示：对我来说，能在这个领域找到工作是最重要的；望能在贵公司任职对我说最重要。 你为什么愿意到我们公司来工作 回答提示：对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”，“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”或者“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。 你和别人发生过争执吗？你是怎样解决的 回答提示：这是面试中最险恶的问题。其实是考官布下的一个陷阱。千万不要说任何人的过错。应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。 你做过的哪件事最令自己感到骄傲 回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。 你新到一个部门,一天一个客户来找你解决问题,你努力想让他满意，可是始终达不到群众得满意,他投诉你们部门工作效率低,你这个时候怎么作 回答提示： (1)首先，我会保持冷静。作为一名工作人员，在工作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对，妥善处理。 (2)其次，我会反思一下客户不满意的原因。一是看是否是自己在解决问题上的确有考虑的不周到的地方，二是看是否是客户不太了解相关的服务规定而提出超出规定的要求，三是看是否是客户了解相关的规定，但是提出的要求不合理。 (3)再次，根据原因采取相对的对策。如果是自己确有不周到的地方，按照服务规定作出合理的安排，并向客户作出解释；如果是客户不太了解政策规定而造成的误解，我会向他作出进一步的解释，消除他的误会；如果是客户提出的要求不符合政策规定，我会明确地向他指出。 (4)再次，我会把整个事情的处理情况向领导作出说明，希望得到他的理解和支持。(5)我不会因为客户投诉了我而丧失工作的热情和积极性，而会一如既往地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客户满意的职员。 对这项工作，你有哪些可预见的困难 回答提示： 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行； 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。” 分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节。但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。 如果我录用你，你将怎样开展工作 回答提示： 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法； 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。” 分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话。此人绝对不会录用了。 你希望与什么样的上级共事 回答提示： 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会； 最好回避对上级具体的希望，多谈对自己的要求； 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了 分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做 回答提示： 原则上我会尊重和服从领导的工作安排；同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法； 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作； 还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见；如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 与上级意见不一是，你将怎么办 回答提示： 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。” 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。” 分析：这个问题的标准答案是思路1，如果用2的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。 你工作经验欠缺，如何能胜任这项工作 常规思路： 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答； 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业； 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。” 点评：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。 您在前一家公司的离职原因是什么 回答提示： 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在 避免把“离职原因”说得太详细、太具体 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等 但也不能躲闪、回避，如“想换换环境”、“个人原因”等 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等 尽量使解释的理由为应聘者个人形象添彩；⑦相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好 分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。实在想不出来的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不可能准假，所以辞职。这个答案一般面试官还能接受。 你工作经验欠缺，如何能胜任这项工作 回答提示： 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答； 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业； 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。” 分析：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。 为了做好你工作份外之事，你该怎样获得他人的支持和帮助 回答提示：每个公司都在不断变化发展的过程中；你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。此外，他们遇到矛盾和问题时，也能泰然处之。下面的问题能够考核应聘者这方面的能力。 据说有人能从容避免正面冲突。请讲一下你在这方面的经验和技巧。 有些时候，我们得和我们不喜欢的人在一起共事。说说你曾经克服了性格方面的冲突而取得预期工作效果的经历。 如果你在这次面试中没有被录用，你怎么打算 回答提示：现在的社会是一个竞争的社会,从这次面试中也可看出这一点,有竞争就必然有优劣,有成功必定就会有失败.往往成功的背后有许多的困难和挫折,如果这次失败了也仅仅是一次而已,只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败. 第一、要敢于面对,面对这次失败不气馁,接受已经失去了这次机会就不会回头这个现实,从心理意志和精神上体现出对这次失败的抵抗力。要有自信,相信自己经历了这次之后经过努力一定能行.能够超越自我. 第二、善于反思,对于这次面试经验要认真总结,思考剖析,能够从自身的角度找差距。正确对待自己,实事求是地评价自己,辩证的看待自己的长短得失,做一个明白人. 第三、走出阴影,要克服这一次失败带给自己的心理压力,时刻牢记自己弱点,防患于未然,加强学习,提高自身素质. 第四、认真工作,回到原单位岗位上后,要实实在在、踏踏实实地工作,三十六行,行行出状元,争取在本岗位上做出一定的成绩. 第五、再接再厉,成为国家公务员一直是我的梦想,以后如果有机会我仍然后再次参加竞争. 假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办 回答提示：我觉得工作是第一位的，但朋友间的情谊也是不能偏废的。这个问题我觉得要按照当时具体的情况来决定。 如果我的朋友晚上9点中的飞机，而我的 加班八点就能够完成的话，那就最理想了，干完工作去机场，皆大欢喜。 如果说工作不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点睡就是了。 如果工作很紧急，两者不可能兼顾的情况下，我觉得可以由两种选择。 如果不是全单位都加班的话，是不是可以要其他同事来代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。 如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋友解释一下，小心他会理解，毕竟工作做完了就完了，朋友还是可以再见面的。 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办 回答提示：一段时间发现工作不适合我，有两种情况： 1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距； 2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。 你做过的哪件事最令自己感到骄傲 回答提示：这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。 谈谈你过去做过的成功案例 回答提示：举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。 谈谈你过去的工作经验中，最令你挫折的事情 回答提示：曾经接触过一个客户，原本就有耳闻他们以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。 分析：借此了解你对挫折的容忍度及调解方式。 如何安排自己的时间？会不会排斥加班 回答提示：基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。 分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。 为什么我们要在众多的面试者中选择你 回答提示：根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。 分析：别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。 对这个职务的期许 回答提示：希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造“双赢”的局面。 分析：回答前不妨先询问该公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同。以免说了一堆理想抱负却发现牛头不对马嘴。 为什么选择这个职务 回答提示：：这一直是我的兴趣和专长，经过这几年的磨练，也累积了一定的经验及人脉，相信我一定能胜任这个职务的。 分析：适时举出过去的“丰功伟业”，表现出你对这份职务的熟稔度，但避免过于夸张的形容或流于炫耀。 为什么选择我们这家公司 回答提示：曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。 分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工作，而不只是探探路。 你认为你在学校属于好学生吗 回答提示：企业的招聘者很精明，问这个问题可以试探出很多问题：如果求职者学习成绩好，就会说：“是的，我的成绩很好，所有的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在学校期间我认为成绩是重要的，其他方面包括思想道德、实践经验、团队精神、沟通能力也都是很重要的，我在这些方面也做得很好，应该说我是一个全面发展的学生。”如果求职者成绩不尽理想，便会说：“我认为是不是一个好学生的标准是多元化的，我的学习成绩还可以，在其他方面我的表现也很突出，比如我去很多地方实习过，我很喜欢在快节奏和压力下工作，我在学生会组织过 ××活动，锻炼了我的团队合作精神和组织能力。” 有经验的招聘者一听就会明白，企业喜欢诚实的求职者。 请谈谈如何适应办公室工作的新环境 回答提示 办公室里每个人有各自的岗位与职责，不得擅离岗位。 根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。 多请示并及时汇报，遇到不明白的要虚心请教。 抓间隙时间，多学习，努力提高自己的政治素质和业务水平。 在工作中学习到了些什么 回答提示：这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了 有想过创业吗 回答提示：这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是“那么为什么你不这样做呢？” 最能概括你自己的三个词是什么 回答提示：我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，使他们觉得你具有发展潜力 你认为你在学校属于好学生吗 回答提示：企业的招聘者很精明，问这个问题可以试探出很多问题：如果求职者学习成绩好，就会说：“是的，我的成绩很好，所有的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在学校期间我认为成绩是重要的，其他方面包括思想道德、实践经验、团队精神、沟通能力也都是很重要的，我在这些方面也做得很好，应该说我是一个全面发展的学生。”如果求职者成绩不尽理想，便会说：“我认为是不是一个好学生的标准是多元化的，我的学习成绩还可以，在其他方面我的表现也很突出，比如我去很多地方实习过，我很喜欢在快节奏和压力下工作，我在学生会组织过 ××活动，锻炼了我的团队合作精神和组织能力。” 有经验的招聘者一听就会明白，企业喜欢诚实的求职者。 除了本公司外，还应聘了哪些公司 回答提示：很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。 何时可以到职 回答提示：大多数企业会关心就职时间，最好是回答\\’如果被录用的话，到职日可按公司规定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的 你并非毕业于名牌院校 回答提示：是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作,我有什么什么项目经验,如何帮助项目经理解决了问题,不拉不拉。 你怎样看待学历和能力 回答提示：学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？ Everything you need to prepare for your technical interview.modified at 2019-01-29 "},"article/p001.html":{"url":"article/p001.html","title":"什么是低耦合高内聚","keywords":"","body":"什么是低耦合高内聚 耦合 简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。 有软硬件之间的耦合，还有软件各模块之间的耦合。 耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。 耦合可以分为以下几种，它们之间的耦合度由高到低排列如下： 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 外部耦 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。 标记耦合 。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合 内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p002.html":{"url":"article/p002.html","title":"Java中的作用域的区别","keywords":"","body":"Java中的作用域的区别 Java中的作用域有 public 、protected、private、default。 public：它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类，接口等，它往往用于对象或类对外的一种接口的形式。 protected：它主要的作用是用来保护子类，它的含义在于子类可以用它修饰的成员，其他的不可以，他相对于传递给子类的一种继承的东西。 private：它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是private修饰符，它不希望被外部类访问。 default：有时候也成为friendly（友元），它是针对本包访问而设计的，任何处于本包下的类，接口，异常等，都可以访问，即使是父类没有用protected修饰的成员也可以。 类内部 本包 子类 外部包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 从上面可以更直观的看到： public：可以被其他所有类访问 protected：可以被自身，子类，以及同一包下的类访问 default：可以被自身和同一包中的类访问 private：只可以被自身访问 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p003.html":{"url":"article/p003.html","title":"重载(Overload)与重写(Override)的区别","keywords":"","body":"重写(Override)与重载(Overload)的区别 方法的重写和重载是Java 多态性的不同表现。 重写Overriding 是父类与子类之间多态性的一种表现，重载Overloading 是一个类中多态性的一种表现。 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move(); // 执行 Animal 类的方法 b.move(); // 执行 Dog 类的方法 } } 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 在上面的例子中可以看到，尽管b属于Animal类型，但是它运行的是Dog类的move方法。 这是由于在编译阶段，只是检查参数的引用类型。然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。 因此在上面的例子中，之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。 思考以下例子： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } public void bark(){ System.out.println(\"狗可以吠叫\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move(); // 执行 Animal 类的方法 b.move(); // 执行 Dog 类的方法 b.bark(); } } 以上实例编译运行结果如下： TestDog.java:30: cannot find symbol symbol : method bark() location: class Animal b.bark(); ^ 该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。 方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super关键字的使用 当需要在子类中调用父类的被重写方法时，要使用super关键字。 class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal b = new Dog(); // Dog 对象 b.move(); // 执行 Dog类的方法 } } 以上实例编译运行结果如下： 动物可以移动 狗可以跑和走 重载(Overload) 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 public class Overloading { public int test(){ System.out.println(\"test1\"); return 1; } public void test(int a){ System.out.println(\"test2\"); } // 以下两个参数类型顺序不同 public String test(int a,String s){ System.out.println(\"test3\"); return \"returntest3\"; } public String test(String s,int a){ System.out.println(\"test4\"); return \"returntest4\"; } public static void main(String[] args){ Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); } } 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写和重载是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p004.html":{"url":"article/p004.html","title":"String、StringBuffer、StringBuilder的区别","keywords":"","body":"String、StringBuffer、StringBuilder的区别 重新认识String类 深入理解String、StringBuffer、StringBuilder 不同场景下三个类的性能测试 常见的关于String、StringBuffer的面试题（辟谣网上流传的一些曲解String类的说法） 重新认识String类 想要了解一个类，最好的办法就是看这个类的实现源代码，String类的实现在\\jdk1.6.0_14\\src\\java\\lang\\String.java文件中。 打开这个类文件就会发现String类是被final修饰的： public final class String implements java.io.Serializable, Comparable, CharSequence { /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ...... } 从上面可以看出几点： String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。 上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的。 下面再继续看String类的一些方法实现： public String substring(int beginIndex, int endIndex) { if (beginIndex count) { throw new StringIndexOutOfBoundsException(endIndex); } if (beginIndex > endIndex) { throw new StringIndexOutOfBoundsException(endIndex - beginIndex); } return ((beginIndex == 0) && (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value); } public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf); } public String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = count; int i = -1; char[] val = value; /* avoid getfield opcode */ int off = offset; /* avoid getfield opcode */ while (++i 从上面的三个方法可以看出，无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点： 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。 在了解了于String类基础的知识后，下面来看一些在平常使用中容易忽略和混淆的地方。 深入理解String、StringBuffer、StringBuilder String str=\"hello world\"和String str=new String(\"hello world\")的区别 想必大家对上面2个语句都不陌生，在平时写代码的过程中也经常遇到，那么它们到底有什么区别和联系呢？下面先看几个例子： public class Main { public static void main(String[] args) { String str1 = \"hello world\"; String str2 = new String(\"hello world\"); String str3 = \"hello world\"; String str4 = new String(\"hello world\"); System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str2==str4); } } 这段代码的输出结果为： false true false 为什么会出现这样的结果？下面解释一下原因： 在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。 因此在上述代码中， String str1 = \"hello world\"; 和 String str3 = \"hello world\"; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量\"hello world\"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。 众所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。 String、StringBuffer以及StringBuilder的区别 既然在Java中已经存在了String类，那为什么还需要StringBuilder和StringBuffer类呢？ 那么看下面这段代码： public class Main { public static void main(String[] args) { String string = \"\"; for(int i=0;i 这句 string += \"hello\"; 的过程相当于将原有的string变量指向的对象内容取出与\"hello\"作字符串相加操作再存进另一个新的String对象当中，再让string变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了： 从这段反编译出的字节码文件可以很清楚地看出：从第8行开始到第35行是整个循环的执行过程，并且每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。从上面还可以看出：string+=\"hello\" 的操作事实上会自动被JVM优化成： StringBuilder str = new StringBuilder(string); str.append(\"hello\"); str.toString(); 再看下面这段代码： public class Main { public static void main(String[] args) { StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i 反编译字节码文件得到： 从这里可以明显看出，这段代码的for循环式从13行开始到27行结束，并且new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。 那么有人会问既然有了StringBuilder类，为什么还需要StringBuffer类？查看源代码便一目了然，事实上，StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的，也就是说StringBuffer是线程安全的。 下面摘了2段代码分别来自StringBuffer和StringBuilder，insert方法的具体实现： StringBuilder的insert方法 public StringBuilder insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } StringBuffer的insert方法 public synchronized StringBuffer insert(int index, char str[], int offset, int len) { super.insert(index, str, offset, len); return this; } 不同场景下三个类的性能测试 这一小节我们来做个小测试，来测试一下三个类的性能区别： public class Main { private static int time = 50000; public static void main(String[] args) { testString(); testStringBuffer(); testStringBuilder(); test1String(); test2String(); } public static void testString () { String s=\"\"; long begin = System.currentTimeMillis(); for(int i=0; i 测试结果（Win7，Eclipse，JDK6）： 操作java.lang.String类型使用的时间为：8090毫秒 操作java.lang.StringBuffer类型使用的时间为：3毫秒 操作java.lang.StringBuilder类型使用的时间为：2毫秒 字符串直接相加操作：1毫秒 字符串间接相加操作：9毫秒 上面提到 string+=\"hello\" 的操作事实上会自动被JVM优化，看下面这段代码： public class Main { private static int time = 50000; public static void main(String[] args) { testString(); testOptimalString(); } public static void testString () { String s=\"\"; long begin = System.currentTimeMillis(); for(int i=0; i 执行结果： 操作java.lang.String类型使用的时间为：8654毫秒 模拟JVM优化操作的时间为：8651毫秒 得到验证。 下面对上面的执行结果进行一般性的解释： 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如 \"I\"+\"love\"+\"java\"; 的字符串相加，在编译期间便被优化成了\"Ilovejava\"。这个可以用javap -c命令反编译生成的class文件进行验证。对于间接相加（即包含字符串引用），形如 s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 String、StringBuilder、StringBuffer三者的执行效率： StringBuilder > StringBuffer > String 当然这个是相对的，不一定在所有情况下都是这样。 比如 String str = \"hello\"+ \"world\" 的效率就比 StringBuilder st = new StringBuilder().append(\"hello\").append(\"world\") 要高。 因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用 String str=\"hello\" 这种形式； 当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 常见的关于String、StringBuffer的面试题 下面是一些常见的关于String、StringBuffer的一些面试笔试题，若有不正之处，请谅解和批评指正。 下面这段代码的输出结果是什么？ String a = \"hello2\"; String b = \"hello\" + 2; System.out.println((a == b)); 输出结果为：true。原因很简单，\"hello\"+2在编译期间就已经被优化成\"hello2\"，因此在运行期间，变量a和变量b指向的是同一个对象。 下面这段代码的输出结果是什么？ String a = \"hello2\"; String b = \"hello\"; String c = b + 2; System.out.println((a == c)); 输出结果为:false。由于有符号引用的存在，所以 String c = b + 2; 不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。 下面这段代码的输出结果是什么？ String a = \"hello2\"; final String b = \"hello\"; String c = b + 2; System.out.println((a == c)); 输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么 String c = b + 2; 在编译期间就会被优化成：String c = \"hello\" + 2;。 下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { String a = \"hello2\"; final String b = getHello(); String c = b + 2; System.out.println((a == c)); } public static String getHello() { return \"hello\"; } } 输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。 下面这段代码的输出结果是什么？ public class Main { public static void main(String[] args) { String a = \"hello\"; String b = new String(\"hello\"); String c = new String(\"hello\"); String d = b.intern(); System.out.println(a==b); System.out.println(b==c); System.out.println(b==d); System.out.println(a==d); } } false false false true 这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在Java se6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。 String str = new String(\"abc\")创建了多少个对象？ 这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。 首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容： 很显然，new只调用了一次，也就是说只创建了一个对象。 而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了\"abc\"对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个\"abc\"对象，而在代码执行过程中确实只创建了一个String对象。 因此，这个问题如果换成 String str = new String(\"abc\") 涉及到几个String对象？合理的解释是2个。 个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚是这段代码执行过程中创建了多少个对象还是涉及到多少个对象再根据具体的来进行回答。 下面这段代码[1]和[2]的区别是什么？ public class Main { public static void main(String[] args) { String str1 = \"I\"; // str1 += \"love\"+\"java\"; // [1] str1 = str1+\"love\"+\"java\"; // [2] } } [1]的效率比[2]的效率要高，[1]中的 \"love\"+\"java\" 在编译期间会被优化成 \"lovejava\"，而[2]中的不会被优化。下面是两种方式的字节码： [1]的字节码 [2]的字节码 可以看出，在[1]中只进行了一次append操作，而在[2]中进行了两次append操作。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p005.html":{"url":"article/p005.html","title":"类加载与初始化","keywords":"","body":"类加载与初始化 类加载器 在了解Java的机制之前，需要先了解类在JVM（Java虚拟机）中是如何加载的，这对后面理解java其它机制将有重要作用。 每个类编译后产生一个Class对象，存储在.class文件中，JVM使用类加载器（Class Loader）来加载类的字节码文件（.class），类加载器实质上是一条类加载器链，一般的，我们只会用到一个原生的类加载器，它只加载Java API等可信类，通常只是在本地磁盘中加载，这些类一般就够我们使用了。如果我们需要从远程网络或数据库中下载.class字节码文件，那就需要我们来挂载额外的类加载器。 一般来说，类加载器是按照树形的层次结构组织的，每个加载器都有一个父类加载器。另外，每个类加载器都支持代理模式，即可以自己完成Java类的加载工作，也可以代理给其它类加载器。 类加载器的加载顺序有两种，一种是父类优先策略，一种是是自己优先策略，父类优先策略是比较一般的情况（如JDK采用的就是这种方式），在这种策略下，类在加载某个Java类之前，会尝试代理给其父类加载器，只有当父类加载器找不到时，才尝试自己去加载。自己优先的策略与父类优先相反，它会首先尝试子经济加载，找不到的时候才要父类加载器去加载，这种在web容器（如tomcat）中比较常见。 动态加载 不管使用什么样的类加载器，类，都是在第一次被用到时，动态加载到JVM的。这句话有两层含义： Java程序在运行时并不一定被完整加载，只有当发现该类还没有加载时，才去本地或远程查找类的.class文件并验证和加载； 当程序创建了第一个对类的静态成员的引用（如类的静态变量、静态方法、构造方法——构造方法也是静态的）时，才会加载该类。Java的这个特性叫做：动态加载。 需要区分加载和初始化的区别，加载了一个类的.class文件，不以为着该Class对象被初始化，事实上，一个类的初始化包括3个步骤： 加载（Loading），由类加载器执行，查找字节码，并创建一个Class对象（只是创建）； 链接（Linking），验证字节码，为静态域分配存储空间（只是分配，并不初始化该存储空间），解析该类创建所需要的对其它类的应用； 初始化（Initialization），首先执行静态初始化块static{}，初始化静态变量，执行静态方法（如构造方法）。 链接 Java在加载了类之后，需要进行链接的步骤，链接简单地说，就是将已经加载的java二进制代码组合到JVM运行状态中去。它包括3个步骤： 验证（Verification），验证是保证二进制字节码在结构上的正确性，具体来说，工作包括检测类型正确性，接入属性正确性（public、private），检查final class 没有被继承，检查静态变量的正确性等。 准备（Preparation），准备阶段主要是创建静态域，分配空间，给这些域设默认值，需要注意的是两点：一个是在准备阶段不会执行任何代码，仅仅是设置默认值，二个是这些默认值是这样分配的，原生类型全部设为0，如：float:0f,int 0, long 0L, boolean:0（布尔类型也是0），其它引用类型为null。 解析（Resolution），解析的过程就是对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址），并保证这些类被正确的找到。解析的过程可能导致其它的类被加载。需要注意的是，根据不同的解析策略，这一步不一定是必须的，有些解析策略在解析时递归的把所有引用解析，这是early resolution，要求所有引用都必须存在；还有一种策略是late resolution，这也是Oracle 的JDK所采取的策略，即在类只是被引用了，还没有被真正用到时，并不进行解析，只有当真正用到了，才去加载和解析这个类。 初始化 注意：在《Java编程思想》中，说static{}子句是在类第一次加载时执行且执行一次（可能是笔误或翻译错误，因为此书的例子显示static是在第 一次初始化时执行的），《Java深度历险》中说 static{}是在第一次实例化时执行且执行一次，这两种应该都是错误的，static{}是在第一次初始化时执行，且只执行一次；用下面的代码可以判 定出来： public class Toy { private String name; public static final int price=10; static { System.out.println(\"Initializing\"); } Toy() { System.out.println(\"Building\"); } Toy(String name) { this.setName(name); } public static String playToy(String player) { String msg = buildMsg(player); System.out.println(msg); return msg; } private String buildMsg(String player) { String msg = player + \" plays \" + name; return msg; } } // 对上面的类，执行下面的代码： Class c = Class.forName(\"myblog.rtti.Toy\"); // c.newInstance(); 可以看到，不实例化，只执行forName初始化时，仍然会执行static{}子句，但不执行构造方法，因此输出的只有Initializing，没有Building。 根据java虚拟机规范，所有java虚拟机实现必须在每个类或接口被java程序首次主动使用时才初始化。 主动使用有以下6种： 创建类的实例 访问某个类或者接口的静态变量，或者对该静态变量赋值（如果访问静态编译时常量(即编译时可以确定值的常量)不会导致类的初始化） 调用类的静态方法 反射（Class.forName(xxx.xxx.xxx)） 初始化一个类的子类（相当于对父类的主动使用），不过直接通过子类引用父类元素，不会引起子类的初始化（参见示例6） Java虚拟机被标明为启动类的类（包含main方法的） 类与接口的初始化不同，如果一个类被初始化，则其父类或父接口也会被初始化，但如果一个接口初始化，则不会引起其父接口的初始化。 示例 通过上面的讲解，将可以理解下面的程序 （下面的程序部分来自于《Java编程思想》）： class Toy { static { // 静态子句，只在类第一次被加载并初始化时执行一次，而且只执行一次 System.out.println(\"Initializing\"); } Toy() { // 构造方法，在每次声明新对象时加载 System.out.println(\"Building\"); } } 对上面的程序段，第一次调用Class.forName(\"Toy\")，将执行static子句；如果在之后执行new Toy()都只执行构造方法。 需要注意newInstance()方法 Class cc = Class.forName(\"Toy\");// 获得类（注意，需要使用含包名的全限定名） Toy toy=(Toy)cc.newInstance(); // 相当于new一个对象，但Gum类必须有默认构造方法（无参） 类字面常量 用类字面常量 .class和Class.forName都可以创建对类的应用，但是不同点在于，用Gum.class创建Class对象的应用时，不会自动初始化该Class对象（static子句不会执行） public class TestToy { public static void main(String[] args) { // try { // Class c = Class.forName(\"myblog.classloader.Toy\"); // } catch (ClassNotFoundException e) { // e.printStackTrace(); // } Class c = Toy.class; // 不会输出任何值 } } 使用Toy.class是在编译期执行的，因此在编译时必须已经有了Toy的.class文件，不然会编译失败，这与 Class.forName(\"myblog.classloader.Toy\")不同，后者是运行时动态加载。 但是，如果该main方法是直接写在Toy类中，那么调用Toy.class，会引起初始化，并输出Initializing，原因并不是Toy.class引起的，而是该类中含有启动方法main，该方法会导致Toy的初始化。 编译时常量 回到完整的类Toy，如果直接输出：System.out.println(Toy.price)，会发现static子句和构造方法都没有被执行，这是因为Toy中，常量price被static final限定，这样的常量叫做编译时常量，对于这种常量，不需要初始化就可以读取。 编译时常量必须满足3个条件：static的，final的，常量。 下面几种都不是编译时常量，对它们的应用，都会引起类的初始化： static int a; final int b; static final int c= ClassInitialization.rand.nextInt(100); static final int d; static { d=5; } static块的本质 注意下面的代码： class StaticBlock { static final int c = 3; static final int d; static int e = 5; static { d = 5; e = 10; System.out.println(\"Initializing\"); } StaticBlock() { System.out.println(\"Building\"); } } public class StaticBlockTest { public static void main(String[] args) { System.out.println(StaticBlock.c); System.out.println(StaticBlock.d); System.out.println(StaticBlock.e); } } 这段代码的输出是什么呢？Initialing在c、d、e之前输出，还是在之后？e输出的是5还是10？ 执行一下，结果为： 3 Initializing 5 10 答案是3最先输出，Intializing随后输出，e输出的是10，为什么呢？ 原因是这样的：输出c时，由于c是编译时常量，不会引起类初始化，因此直接输出，输出d时，d不是编译时常量，所以会引起初始化操作，即static块的执行，于是d被赋值为5，e被赋值为10，然后输出Initializing，之后输出d为5，e为10。 但e为什么是10呢？原来，JDK会自动为e的初始化创建一个static块，所以上面的代码等价于： class StaticBlock { static final int d; static int e; static { e=5; } static { d = 5; e = 10; System.out.println(\"Initializing\"); } StaticBlock() { System.out.println(\"Building\"); } } 可见，按顺序执行，e先被初始化为5，再被初始化为10，于是输出了10。 类似的，容易想到下面的代码： class StaticBlock { static { d = 5; e = 10; System.out.println(\"Initializing\"); } static final int d; static int e = 5; StaticBlock() { System.out.println(\"Building\"); } } 在这段代码中，对e的声明被放到static块后面，于是，e会先被初始化为10，再被初始化为5，所以这段代码中e会输出为5。 当访问一个Java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化 class B { static int value = 100; static { System.out.println(\"Class B is initialized\");// 输出 } } class A extends B { static { System.out.println(\"Class A is initialized\"); // 不输出 } } public class SuperClassTest { public static void main(String[] args) { System.out.println(A.value);// 输出100 } } 在该例子中，虽然通过A来引用了value，但value是在父类B中声明的，所以只会初始化B，而不会引起A的初始化 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p006.html":{"url":"article/p006.html","title":"RTTI和反射机制","keywords":"","body":"RTTI和反射机制 类加载器 并不是所有的Class都能在编译时明确，因此在某些情况下需要在运行时再发现和确定类型信息（比如：基于构建编程，），这就是RTTI（Runtime Type Information，运行时类型信息）。 在Java中，有两种RTTI的方式，一种是传统的，即假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信息。 在本文中，将共同使用下面的玩具类Toy，该类中定义了公有、私有方法，变量，构造方法，父类、父接口等： public interface IToy { public String playToy(String player) throws Exception; } public class AbstractToy implements IToy { @Override public String playToy(String player) throws Exception { System.out.println(player + \" plays abstract toy\"); return \"\"; } } public class Toy extends AbstractToy { private String name; public String color; protected int size; public static final int price = 10; static { System.out.println(\"Loading\"); } // 构造方法一定要声明为public类型，不然用getConstructors无法得到 public Toy() { System.out.println(\"Initialing\"); setName(\"myToy\"); color = \"red\"; size = 5; } public Toy(String name, String color, int size) { this.setName(name); this.color = color; this.size = size; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String playToy(String player) throws Exception { String msg = buildMsg(player); System.out.println(msg); return msg; } private String buildMsg(String player) { String msg = player + \" plays \" + name; return msg; } } 传统的RTTI 严格的说，反射也是一种形式的RTTI，不过，一般的文档资料中把RTTI和反射分开，因为一般的，大家认为RTTI指的是传统的RTTI，通过继承和多态来实现，在运行时通过调用超类的方法来实现具体的功能（超类会自动实例化为子类，或使用instance of）。 传统的RTTI有3种实现方式： 向上转型或向下转型（upcasting and downcasting），在java中，向下转型（父类转成子类）需要强制类型转换 Class对象（用了Class对象，不代表就是反射，如果只是用Class对象cast成指定的类，那就还是传统的RTTI） instanceof或isInstance() 传统的RTTI与反射最主要的区别，在于RTTI在编译期需要.class文件，而反射不需要。传统的RTTI使用转型或Instance形式实现，但都需要指定要转型的类型，比如： public void rtti(Object obj){ Toy toy = Toy(obj); // Toy toy = Class.forName(\"myblog.rtti.Toy\") // obj instanceof Toy } 注意其中的obj虽然是被转型了，但在编译期，就需要知道要转成的类型Toy，也就是需要Toy的.class文件。 相对的，反射完全在运行时在通过Class类来确定类型，不需要提前加载Toy的.class文件。 反射 那到底什么是反射（Reflection）呢？反射有时候也被称为内省（Introspection），事实上，反射，就是一种内省的方式，Java不允许在运行时改变程序结构或类型变量的结构，但它允许在运行时去探知、加载、调用在编译期完全未知的class，可以在运行时加载该class，生成实例对象（instance object），调用method，或对field赋值。这种类似于“看透”了class的特性被称为反射（Reflection），我们可以将反射直接理解为：可以看到自己在水中的倒影，这种操作与直接操作源代码效果相同，但灵活性高得多。 关于Java的反射API，没必要去记忆，可以在任何JDK API中查询即可： Class类：http://www.ostools.net/uploads/apidocs/jdk-zh/java/lang/Class.html reflect包：http://www.ostools.net/uploads/apidocs/jdk-zh/java/lang/reflect/package-summary.html 反射的实现方式 import java.lang.reflect.Array; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; public class ToyReflection { public static void printInfo(String info, Object obj) { if (obj.getClass().isArray()) { System.out.println(info + \": \"); int length = Array.getLength(obj); System.out.println(\"Array Size: \" + length); for (int i = 0; i c = Class.forName(\"myblog.rtti.Toy\"); printInfo(\"获得类对象\", c); // 获得超类 Class superClass = c.getSuperclass(); printInfo(\"获得超类\", superClass); // 获得所有父接口 Class[] interfaces = c.getInterfaces(); printInfo(\"获得所有父接口\", interfaces); // 实例化 Toy toy = (Toy) c.newInstance(); printInfo(\"实例化\", toy); // 获得访问属性为public的构造方法 Constructor[] constructors = c.getConstructors(); printInfo(\"获得构造方法\", constructors); // 获得指定参数的构造方法 Constructor constructor = c.getDeclaredConstructor(String.class, String.class, int.class); printInfo(\"获得指定构造方法\", constructor); // 获得方法，getMethod只能获得public方法，包括父类和接口继承的方法 Method method = c.getMethod(\"playToy\", String.class); printInfo(\"获得公有方法\", method); // 调用方法 method.invoke(toy, \"张三\"); // 获得修饰符，包括private/public/protect,static String modifier = Modifier.toString(method.getModifiers()); printInfo(\"获得修饰符\", modifier); // 获得参数类型 Class[] paramTypes = method.getParameterTypes(); printInfo(\"获得参数类型\", paramTypes); // 获得返回值类型 Class returnType = method.getReturnType(); printInfo(\"获得返回值类型\", returnType); // 获得异常类型 Class[] excepTypes = method.getExceptionTypes(); printInfo(\"获得异常类型\", excepTypes); // 调用私有方法，getDeclaredMethod获得类自身的方法，包括public,protect,private方法 Method method2 = c.getDeclaredMethod(\"buildMsg\", String.class); method2.setAccessible(true); String result = (String) method2.invoke(toy, \"李四\"); printInfo(\"获得私有方法\", result); // 获得全部属性 Field[] fields = c.getFields(); printInfo(\"获得全部属性\", fields); // 获得类自身定义的指定属性 Field field = c.getDeclaredField(\"name\"); printInfo(\"获得自身属性\", field); // 获得类及其父类，父接口定义的public属性 Field field2 = c.getField(\"color\"); printInfo(\"获得公有属性\", field2); // 获得权限修饰符，包括private/public/protect,static,final String fieldModifier = Modifier.toString(field.getModifiers()); printInfo(\"获得权限修饰符\", fieldModifier); // 操作数组 int[] exampleArray = { 1, 2, 3, 4, 5 }; // 获得数组类型 Class componentType = exampleArray.getClass().getComponentType(); printInfo(\"数组类型\", componentType.getName()); // 获得长度 printInfo(\"数组长度\", Array.getLength(exampleArray)); // 获得指定元素 printInfo(\"获得数组元素\", Array.get(exampleArray, 2)); // 修改指定元素 Array.set(exampleArray, 2, 6); printInfo(\"修改数组元素\", exampleArray); // 获得当前的类加载器 printInfo(\"获得当前类加载器\", toy.getClass().getClassLoader().getClass().getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } } } 通过上面的代码，可以清晰的理解如何“在水中看到自己”，不过需要注意的有几点： 在java的反射机制中，getDeclaredMethod得到的是全部方法，getMethod得到的是公有方法； 反射机制的setAccessible可能会破坏封装性，可以任意访问私有方法和私有变量； setAccessible并不是将private改为public，事实上，public方法的accessible属性也是false的，setAccessible只是取消了安全访问控制检查，所以通过设置setAccessible，可以跳过访问控制检查，执行的效率也比较高。参考：提高Java反射速度 反射的性能 反射机制给予Java开发很大的灵活性，但反射机制本身也有缺点，代表性的缺陷就是反射的性能，一般来说，通过反射调用方法的效率比直接调用的效率要至少慢一倍以上。参考：反射性能测试 反射与设计模式 反射的一个很重要的作用，就是在设计模式中的应用，包括在工厂模式和代理模式中的应用。参考：反射使用实例详解 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p007.html":{"url":"article/p007.html","title":"提高Java反射速度","keywords":"","body":"提高Java反射速度 提高java反射速度的方法method.setAccessible(true) Java代码中，常常将一个类的成员变量置为private，在类的外面获取此类的私有成员变量的value时，需要注意: public class AccessibleTest { private int id; private String name; public AccessibleTest() {} public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Main { public static void main(String[] args) throws Exception { Class clazz = Class.forName(\"com.test.accessible.AccessibleTest\"); AccessibleTest at = new AccessibleTest(); at.setId(1); at.setName(\"AT\"); for (Field f : clazz.getDeclaredFields()) { // AccessibleTest类中的成员变量为private,故必须进行此操作 f.setAccessible(true); // 获取当前对象中当前Field的value System.out.println(f.get(at)); } } } 如果没有在获取Field之前调用setAccessible(true)方法，异常： java.lang.IllegalAccessException: Class com.test.accessible.Main can not access a member of class com.test.accessible.AccessibleTest with modifiers \"private\" 当然在AccessibleTest类的内部(AccessibleTest的内部类除外)，进行如上操作则不需要调用setAccesible()方法。 明显 Accessible并不是标识方法能否访问的。public的方法 Accessible仍为false，使用了method.setAccessible(true)后 性能有了20倍的提升，Accessable属性是继承自AccessibleObject 类。 功能是启用或禁用安全检查 JDK API中的解释 AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获得字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。 在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象。 setAccessible public void setAccessible(boolean flag) throws SecurityException 将此对象的 accessible 标志设置为指示的布尔值。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。 实际上setAccessible是启用和禁用访问安全检查的开关,并不是为true就能访问为false就不能访问。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p008.html":{"url":"article/p008.html","title":"反射性能测试","keywords":"","body":"反射性能测试 通过对比静态调用与类反射调用方法的效率，来了解现代框架中大量应用的反射调用对性能的影响程度。以便在系统架构中对性能与开发便利性之间进行权衡与取舍。 代码： public class PerformanceTest { public static void main(String[] args) throws Exception { int testTime = 10000000; PerformanceTest test = new PerformanceTest(); String msg = \"this is test message\"; long bTime = System.currentTimeMillis(); for(int i=0; i 测试结果： 930 5369 898 5052 885 5346 889 4992 对比代码的测试结果，没有缓存被调用方法的情况下，性能损失更为严重。 而考虑在框架级实现中，缓存是通过map等机制进行的，那么在获取缓存时的时间成本也要计算在内，则整体性能对比将在上述两个测试之间。 考虑目前的计算机系统的速度，应用开发已经不在那么介意性能，而更为注重系统的可维护性和扩展性以及快速开发效率上。上述的测试结果是在一千万次的测试基础上产生的。而在通常的一次业务请求中，反射使用的次数应该是非常少的，只在框架级基础上被使用，在一个高负载的系统中，业务处理的性能将是关键点，而不在于使用的这些反射所带来的性能影响上。而使用反射所带来的开发便利与可维护性可扩展性的提升所带来的价值，是远远高于其所损耗的性能的。 又回想起原来在某个所谓高性能项目中通过减少反射来提高性能的做法，现在想来，比较愚蠢。这说明前期的测试工作没有到位，而带来这样的结论偏差，从而导致了开发与维护的不便，而且极大地影响了开发速度。 其实那个系统的大部分性能瓶颈都是在数据库上，大部分的业务处理都是在数据库中进行的，在项目后面的性能测试中发现，WEB服务器的负载非常低，远远低于数据库，大部分的操作都是在等待数据库的返回。 前期某些推论既没有经过验证，也没有相关的使用经验来支持此推论，是导致这种错误的根源。在将来的架构设计工作与框架选型要加强这方面的评估工作，来达到性能与开发效率间的最佳平衡。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p009.html":{"url":"article/p009.html","title":"反射使用实例详解","keywords":"","body":"反射使用实例详解 本篇文章依旧采用小例子来说明，案例驱动是最好的，要不然只看理论的话，看了也不懂，不过建议大家在看完文章之后，在回过头去看看理论，会有更好的理解。 案例：通过一个对象获得完整的包名和类名 package Reflect; /** * 通过一个对象获得完整的包名和类名 * */ class Demo{ //other codes... } class hello{ public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.getClass().getName()); } } 运行结果： Reflect.Demo 所有类的对象其实都是Class的实例。 案例：实例化Class类对象 package Reflect; class Demo{ //other codes... } class hello{ public static void main(String[] args) { Class demo1=null; Class demo2=null; Class demo3=null; try{ // 一般尽量采用这种形式 demo1=Class.forName(\"Reflect.Demo\"); }catch(Exception e){ e.printStackTrace(); } demo2=new Demo().getClass(); demo3=Demo.class; System.out.println(\"类名称 \"+demo1.getName()); System.out.println(\"类名称 \"+demo2.getName()); System.out.println(\"类名称 \"+demo3.getName()); } } 运行结果： 类名称 Reflect.Demo 类名称 Reflect.Demo 类名称 Reflect.Demo 案例：通过Class实例化其他类的对象 通过无参构造实例化对象 package Reflect; class Person{ public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString(){ return \"[\"+this.name+\" \"+this.age+\"]\"; } private String name; private int age; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Person per=null; try { per=(Person)demo.newInstance(); } catch (InstantiationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } per.setName(\"Rollen\"); per.setAge(20); System.out.println(per); } } 运行结果： [Rollen 20] 但是注意一下，当我们把Person中的默认的无参构造函数取消的时候，比如自己定义只定义一个有参数的构造函数之后，会出现错误。 比如我定义了一个构造函数： public Person(String name, int age) { this.age=age; this.name=name; } 然后继续运行上面的程序，会出现： java.lang.InstantiationException: Reflect.Person at java.lang.Class.newInstance0(Class.java:340) at java.lang.Class.newInstance(Class.java:308) at Reflect.hello.main(hello.java:39) Exception in thread \"main\" java.lang.NullPointerException at Reflect.hello.main(hello.java:47) 所以在编写使用Class实例化其他类的对象的时候，一定要自己定义无参的构造函数。 案例：通过Class调用其它类中的构造函数 也可以通过这种方式通过Class创建其它类的对象。 package Reflect; import java.lang.reflect.Constructor; class Person{ public Person() {} public Person(String name){ this.name=name; } public Person(int age){ this.age=age; } public Person(String name, int age) { this.age=age; this.name=name; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString(){ return \"[\"+this.name+\" \"+this.age+\"]\"; } private String name; private int age; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Person per1=null; Person per2=null; Person per3=null; Person per4=null; // 取得全部的构造函数 Constructor cons[]=demo.getConstructors(); try{ per1=(Person)cons[0].newInstance(); per2=(Person)cons[1].newInstance(\"Rollen\"); per3=(Person)cons[2].newInstance(20); per4=(Person)cons[3].newInstance(\"Rollen\",20); }catch(Exception e){ e.printStackTrace(); } System.out.println(per1); System.out.println(per2); System.out.println(per3); System.out.println(per4); } } 运行结果： [null 0] [Rollen 0] [null 20] [Rollen 20] 案例：返回一个类实现的接口 package Reflect; interface China{ public static final String name=\"Rollen\"; public static int age=20; public void sayChina(); public void sayHello(String name, int age); } class Person implements China{ public Person() {} public Person(String sex){ this.sex=sex; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } @Override public void sayChina(){ System.out.println(\"hello ,china\"); } @Override public void sayHello(String name, int age){ System.out.println(name+\" \"+age); } private String sex; } class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } // 保存所有的接口 Class intes[]=demo.getInterfaces(); for (int i = 0; i 运行结果： 实现的接口 Reflect.China PS：以下几个例子，都会用到这个例子的Person类，所以为节省篇幅，此处不再粘贴Person的代码部分，只粘贴主类hello的代码。 案例：取得其它类中的父类 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } // 取得父类 Class temp=demo.getSuperclass(); System.out.println(\"继承的父类为： \"+temp.getName()); } } 运行结果： 继承的父类为： java.lang.Object 案例：获得其他类中的全部构造函数 这个例子需要在程序开头添加import java.lang.reflect.*; 然后将主类编写为： class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Constructorcons[]=demo.getConstructors(); for (int i = 0; i 运行结果： 构造方法： public Reflect.Person() 构造方法： public Reflect.Person(java.lang.String) 但是细心的话会发现，上面的构造函数没有public 或者private这一类的修饰符，下面这个例子就来获取修饰符。 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Constructorcons[]=demo.getConstructors(); for (int i = 0; i p[]=cons[i].getParameterTypes(); System.out.print(\"构造方法： \"); int mo=cons[i].getModifiers(); System.out.print(Modifier.toString(mo)+\" \"); System.out.print(cons[i].getName()); System.out.print(\"(\"); for(int j=0;j 运行结果： 构造方法： public Reflect.Person(){} 构造方法： public Reflect.Person(java.lang.String arg1){} 有时候一个方法可能还有异常。 class hello{ public static void main(String[] args) { Class demo=null; try{ demo=Class.forName(\"Reflect.Person\"); }catch (Exception e) { e.printStackTrace(); } Method method[]=demo.getMethods(); for(int i=0;i returnType=method[i].getReturnType(); Class para[]=method[i].getParameterTypes(); int temp=method[i].getModifiers(); System.out.print(Modifier.toString(temp)+\" \"); System.out.print(returnType.getName()+\" \"); System.out.print(method[i].getName()+\" \"); System.out.print(\"(\"); for(int j=0;j exce[]=method[i].getExceptionTypes(); if(exce.length>0){ System.out.print(\") throws \"); for(int k=0;k 运行结果： public java.lang.String getSex () public void setSex (java.lang.String arg0) public void sayChina () public void sayHello (java.lang.String arg0,int arg1) public final native void wait (long arg0) throws java.lang.InterruptedException public final void wait () throws java.lang.InterruptedException public final void wait (long arg0,int arg1) throws java.lang.InterruptedException public boolean equals (java.lang.Object arg0) public java.lang.String toString () public native int hashCode () public final native java.lang.Class getClass () public final native void notify () public final native void notifyAll () 案例：取得其它类的全部属性 通过class取得一个类的全部框架 class hello { public static void main(String[] args) { Class demo = null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"===============本类属性========================\"); // 取得本类的全部属性 Field[] field = demo.getDeclaredFields(); for (int i = 0; i type = field[i].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + field[i].getName() + \";\"); } System.out.println(\"===============实现的接口或者父类的属性========================\"); // 取得实现的接口或者父类的属性 Field[] filed1 = demo.getFields(); for (int j = 0; j type = filed1[j].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + filed1[j].getName() + \";\"); } } } 运行结果： ===============本类属性======================== private java.lang.String sex; ===============实现的接口或者父类的属性======================== public static final java.lang.String name; public static final int age; 案例：通过反射调用其它类中的方法 class hello { public static void main(String[] args) { Class demo = null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } try{ // 调用Person类中的sayChina方法 Method method=demo.getMethod(\"sayChina\"); method.invoke(demo.newInstance()); // 调用Person的sayHello方法 method=demo.getMethod(\"sayHello\", String.class,int.class); method.invoke(demo.newInstance(),\"Rollen\",20); }catch (Exception e) { e.printStackTrace(); } } } 运行结果： hello ,china Rollen 20 案例：调用其它类的set和get方法 class hello { public static void main(String[] args) { Class demo = null; Object obj=null; try { demo = Class.forName(\"Reflect.Person\"); } catch (Exception e) { e.printStackTrace(); } try{ obj=demo.newInstance(); }catch (Exception e) { e.printStackTrace(); } setter(obj,\"Sex\",\"男\",String.class); getter(obj,\"Sex\"); } /** * @param obj * 操作的对象 * @param att * 操作的属性 * */ public static void getter(Object obj, String att) { try { Method method = obj.getClass().getMethod(\"get\" + att); System.out.println(method.invoke(obj)); } catch (Exception e) { e.printStackTrace(); } } /** * @param obj * 操作的对象 * @param att * 操作的属性 * @param value * 设置的值 * @param type * 参数的属性 * */ public static void setter(Object obj, String att, Object value, Class type) { try { Method method = obj.getClass().getMethod(\"set\" + att, type); method.invoke(obj, value); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： 男 案例：通过反射操作属性 class hello { public static void main(String[] args) throws Exception { Class demo = null; Object obj = null; demo = Class.forName(\"Reflect.Person\"); obj = demo.newInstance(); Field field = demo.getDeclaredField(\"sex\"); field.setAccessible(true); field.set(obj, \"男\"); System.out.println(field.get(obj)); } } 案例：通过反射取得并修改数组的信息 import java.lang.reflect.*; class hello{ public static void main(String[] args) { int[] temp={1,2,3,4,5}; Classdemo=temp.getClass().getComponentType(); System.out.println(\"数组类型： \"+demo.getName()); System.out.println(\"数组长度 \"+Array.getLength(temp)); System.out.println(\"数组的第一个元素: \"+Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println(\"修改之后数组第一个元素为： \"+Array.get(temp, 0)); } } 运行结果： 数组类型： int 数组长度 5 数组的第一个元素: 1 修改之后数组第一个元素为： 100 案例：通过反射修改数组大小 class hello{ public static void main(String[] args) { int[] temp={1,2,3,4,5,6,7,8,9}; int[] newTemp=(int[])arrayInc(temp,15); print(newTemp); System.out.println(\"=====================\"); String[] atr={\"a\",\"b\",\"c\"}; String[] str1=(String[])arrayInc(atr,8); print(str1); } /** * 修改数组大小 * */ public static Object arrayInc(Object obj,int len){ Classarr=obj.getClass().getComponentType(); Object newArr=Array.newInstance(arr, len); int co=Array.getLength(obj); System.arraycopy(obj, 0, newArr, 0, co); return newArr; } /** * 打印 * */ public static void print(Object obj){ Classc=obj.getClass(); if(!c.isArray()){ return; } System.out.println(\"数组长度为： \"+Array.getLength(obj)); for (int i = 0; i 运行结果： 数组长度为： 15 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 ===================== 数组长度为： 8 a b c null null null null null 案例：动态代理获得类加载器 class test{} class hello{ public static void main(String[] args) { test t=new test(); System.out.println(\"类加载器 \"+t.getClass().getClassLoader().getClass().getName()); } } 运行结果： 类加载器 sun.misc.Launcher$AppClassLoader 其实在java中有三种类类加载器。 Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类。 AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是Java中默认的加载器。 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。 package Reflect; import java.lang.reflect.*; // 定义项目接口 interface Subject { public String say(String name, int age); } // 定义真实项目 class RealSubject implements Subject { @Override public String say(String name, int age) { return name + \" \" + age; } } class MyInvocationHandler implements InvocationHandler { private Object obj = null; public Object bind(Object obj) { this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object temp = method.invoke(this.obj, args); return temp; } } class hello { public static void main(String[] args) { MyInvocationHandler demo = new MyInvocationHandler(); Subject sub = (Subject) demo.bind(new RealSubject()); String info = sub.say(\"Rollen\", 20); System.out.println(info); } } 运行结果： Rollen 20 类的生命周期 在一个类编译完成之后，下一步就需要开始使用类，如果要使用一个类，肯定离不开JVM。在程序执行中JVM通过装载，链接，初始化这3个步骤完成。 类的装载是通过类加载器完成的，加载器将.class文件的二进制文件装入JVM的方法区，并且在堆区创建描述这个类的java.lang.Class对象。用来封装数据。 但是同一个类只会被类装载器装载以前。 链接就是把二进制数据组装为可以运行的状态。 链接分为校验，准备，解析这3个阶段： 校验一般用来确认此二进制文件是否适合当前的JVM（版本） 准备就是为静态成员分配内存空间。并设置默认值 解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系） 完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收。释放空间。 当没有任何引用指向Class对象时就会被卸载，结束类的生命周期。 案例：将反射用于工厂模式 不用反射的工厂模式 interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } // 构造工厂类 // 也就是说以后如果在添加其它的实例的时候只需要修改工厂类就行了 class Factory{ public static fruit getInstance(String fruitName){ fruit f=null; if(\"Apple\".equals(fruitName)){ f=new Apple(); } if(\"Orange\".equals(fruitName)){ f=new Orange(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.getInstance(\"Orange\"); f.eat(); } } 这样，在添加一个子类的时候，就需要修改工厂类了。如果添加太多的子类的时候，改的就会很多。 利用反射机制的工厂模式 package Reflect; interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } class Factory{ public static fruit getInstance(String ClassName){ fruit f=null; try{ f=(fruit)Class.forName(ClassName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.getInstance(\"Reflect.Apple\"); if(f!=null){ f.eat(); } } } 现在就算添加任意多个子类的时候，工厂类就不需要修改。 上面的代码虽然可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。 结合属性文件的工厂模式 首先创建一个fruit.properties的资源文件，内容为： apple=Reflect.Apple orange=Reflect.Orange 主类代码： package Reflect; import java.io.*; import java.util.*; interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println(\"Apple\"); } } class Orange implements fruit{ public void eat(){ System.out.println(\"Orange\"); } } // 操作属性文件类 class init{ public static Properties getPro() throws FileNotFoundException, IOException{ Properties pro=new Properties(); File f=new File(\"fruit.properties\"); if(f.exists()){ pro.load(new FileInputStream(f)); }else{ pro.setProperty(\"apple\", \"Reflect.Apple\"); pro.setProperty(\"orange\", \"Reflect.Orange\"); pro.store(new FileOutputStream(f), \"FRUIT CLASS\"); } return pro; } } class Factory{ public static fruit getInstance(String ClassName){ fruit f=null; try{ f=(fruit)Class.forName(ClassName).newInstance(); }catch (Exception e) { e.printStackTrace(); } return f; } } class hello{ public static void main(String[] a) throws FileNotFoundException, IOException{ Properties pro=init.getPro(); fruit f=Factory.getInstance(pro.getProperty(\"apple\")); if(f!=null){ f.eat(); } } } 运行结果： Apple Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p010.html":{"url":"article/p010.html","title":"内存区域和GC机制","keywords":"","body":"内存区域和GC机制 Java垃圾回收概况 Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。 关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。 Java GC机制主要完成3件事：确定哪些内存需要回收，确定什么时候需要执行GC，如何执行GC。经过这么长时间的发展（事实上，在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。 学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。 我们将从4个方面学习Java GC机制： 内存是如何分配的； 如何保证内存不被错误回收（即：哪些内存需要回收）； 在什么情况下执行GC以及执行GC的方式； 如何监控和优化GC机制。 Java内存区域 了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块： 程序计数器（Program Counter Register） 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。 每个程序计数器只用来记录一个线程的行号，所以它是线程私有（一个线程就有一个程序计数器）的。 如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。 虚拟机栈（JVM Stack） 一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。 局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。 虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。 每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。 本地方法栈（Native Method Statck） 本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。 本地方法栈也是线程私有的。 堆区（Heap） 堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。 一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。 关于堆区的内容还有很多，将在下节 Java内存分配机制 中详细介绍。 方法区（Method Area） 在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。 方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。 方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。 在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。 在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。 运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符 \"abc\" 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。 直接内存（Direct Memory） 直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。 Java对象的访问方式 一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。 以最简单的本地变量引用：Object obj = new Object()为例： Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据； new Object()作为实例对象数据存储在堆中； 堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中； 在Java虚拟机规范中，对于通过reference类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种： 通过句柄访问 （图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）： 通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。 通过直接指针访问 （图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》） 通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。 Java内存分配机制 这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。 Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation，也就是方法区）。如下图（来源于成为Java GC专家(1)：深入浅出Java垃圾回收机制）： 年轻代（Young Generation） 对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。 年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为（来源于成为Java GC专家(1)：深入浅出Java垃圾回收机制）： 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快； 最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）； 下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区； 将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区； 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。 从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。 在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread-Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。 年老代（Old Generation） 对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　　 可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。 如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。 可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——“card table”，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。 Java GC机制 GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。 年轻代 事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。 这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）。 由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1。 老年代 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。 方法区（永久代） 永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点： 类的所有实例都已经被回收 加载类的ClassLoader已经被回收 类对象的Class对象没有被引用（即没有通过反射引用该类的地方） 永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制。 -verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息 -verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用 -XX:+TraceClassUnLoading需要fastdebug版HotSpot支持 垃圾收集器 在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）： 在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。 Serial收集器 新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）。 ParNew收集器 新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器 新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效），用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。 Serial Old收集器 老年代收集器，单线程收集器，串行，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。 Parallel Old收集器 老年代收集器，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。 CMS（Concurrent Mark Sweep）收集器 老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。 CMS收集的执行过程 初始标记(CMS-initial-mark)- -> 并发标记(CMS-concurrent-mark) -->预清理(CMS-concurrent-preclean)-->可控预清理(CMS-concurrent-abortable-preclean)--> 重新标记(CMS-remark)- -> 并发清除(CMS-concurrent-sweep)- ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。 具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。 首先jvm根据-XX:CMSInitiatingOccupancyFraction，-XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集； 如果设置了-XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc； 如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因； 当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象，CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间； 下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿，此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark； 下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间，此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean； 下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间，此阶段涉及几个参数： -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束 -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，即当eden使用达到此值时，才会开始abortable-preclean阶段 -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行 此阶段会打印一些日志如下： CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean， CMS：abort preclean due to time XXX 再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记； YG occupancy：964861K（2403008K），指执行时young代的情况 CMS remark：961330K（1572864K），指执行时old代的情况 此外，还打印出了弱引用处理、类卸载等过程的耗时 再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理 最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构 有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停 A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。 B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。 影响cms gc时长及触发的参数是以下2个： -XX:CMSMaxAbortablePrecleanTime=5000 -XX:CMSInitiatingOccupancyFraction=80 解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大 解决方式： A，针对cms gc的触发阶段，调整-XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间 C，考虑到cms gc时不会进行compact，因此加入-XX:+UseCMSCompactAtFullCollection（cms gc后会进行内存的compact）和-XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数 在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。 CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。 还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 G1收集器 在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。 注意并发（Concurrent）和并行（Parallel）的区别： 并发是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行） 并行收集是指多个GC线程并行工作，但此时用户线程是暂停的 所以，Serial是串行的，Parallel收集器是并行的，而CMS收集器是并发的. Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p011.html":{"url":"article/p011.html","title":"成为Java GC专家(1)：深入浅出Java垃圾回收机制","keywords":"","body":"成为Java GC专家(1)：深入浅出Java垃圾回收机制 英文原文 对于Java开发人员来说，了解垃圾回收机制（GC）有哪些好处呢？首先可以满足作为一名软件工程师的求知欲，其次，深入了解GC如何工作可以帮你写出更好的Java应用。 这仅仅代表我个人的意见，但我坚信一个精通GC的人往往是一个好的Java开发者。如果你对GC的处理过程感兴趣，说明你已经具备较大规模应用的开发经验。如果你曾经想过如何正确的选择GC算法，那意味着你已经完全理解你所开发的应用的特点。当然，我们不能以偏概全，这不能作为评价一个好的开发人员的共通标准。但是，我要说的是，深入理解GC是成为一名伟大的程序员的必经之路。 这是成为JavaGC专家系列文章的第一篇，本篇主要针对GC机制进行介绍，在下一篇中，我们将重点探讨分析GC状态以及来自NHN的GC调优的例子。 回到正题，咱们继续谈垃圾回收，在学习GC之前，你首先应该记住一个单词：“stop-the-world”。Stop-the-world会在任何一种GC算法中发生。Stop-the-world意味着 JVM 因为要执行GC而停止了应用程序的执行。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态，直到GC任务完成。GC优化很多时候就是指减少Stop-the-world发生的时间。 按代的垃圾回收机制 在Java程序中不能显式地分配和注销内存。有些人把相关的对象设置为null或者调用System.gc()来试图显式地清理内存。设置为null至少没什么坏处，但是调用System.gc()会显著地影响系统性能，必须彻底杜绝（还好，我还没有见到NHN的哪个开发者调用这个方法）。 在Java中，开发人员无法直接在程序代码中清理内存，而是由垃圾回收器自动寻找不必要的垃圾对象，并且清理掉他们。垃圾回收器会在下面两种假设（hypotheses）成立的情况下被创建（称之为假设不如改为推测（suppositions）或者前提（preconditions））。 大多数对象会很快变得不可达 只有很少的由老对象（创建时间较长的对象）指向新生对象的引用 这些假设我们称之为弱年代假设（ weak generational hypothesis）。为了强化这一假设，HotSpot虚拟机将其物理上划分为两个–新生代（young generation）和老年代（old generation）。 新生代（Young generation）: 绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程我们称之为”minor GC“。 老年代（Old generation）: 对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多。对象从老年代中消失的过程，我们称之为”major GC“（或者”full GC“） 请看下面这个图表。 图1 : GC 空间 & 数据流 上图中的持久代（ permanent generation ）也被称为方法区（method area）。他用来保存类常量以及字符串常量。因此，这个区域不是用来永久的存储那些从老年代存活下来的对象。这个区域也可能发生GC。并且发生在这个区域上的GC事件也会被算为major GC。 有些人可能会问： 如果老年代的对象需要引用一个新生代的对象，会发生什么呢？ 为了解决这个问题，老年代中存在一个”card table“，他是一个512 byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询card table来决定是否可以被收集，而不用查询整个老年代。这个card table由一个write barrier来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但GC的整体时间被显著的减少。 图 2: Card Table 结构 新生代的构成 为了更好地理解GC，我们现在来学习新生代，新生代是用来保存那些第一次被创建的对象，他可以被分为三个空间。 一个伊甸园空间（Eden ） 两个幸存者空间（Survivor ） 一共有三个空间，其中包含两个幸存者空间。每个空间的执行顺序如下： 绝大多数刚刚被创建的对象会存放在伊甸园空间。 在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间。 此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间。 当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。之后会清空已经饱和的那个幸存者空间。 在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。 如果你仔细观察这些步骤就会发现，其中一个幸存者空间必须保持是空的。如果两个幸存者空间都有数据，或者两个空间都是空的，那一定标志着你的系统出现了某种错误。 通过频繁的minor GC将数据移动到老年代的过程可以用下图来描述： 图 3: GC执行前后对比 需要注意的是HotSpot虚拟机使用了两种技术来加快内存分配。他们分别是是”bump-the-pointer“和“TLABs（Thread-Local Allocation Buffers）”。 Bump-the-pointer技术跟踪在伊甸园空间创建的最后一个对象。这个对象会被放在伊甸园空间的顶部。如果之后再需要创建对象，只需要检查伊甸园空间是否有足够的剩余空间。如果有足够的空间，对象就会被创建在伊甸园空间，并且被放置在顶部。这样以来，每次创建新的对象时，只需要检查最后被创建的对象。这将极大地加快内存分配速度。但是，如果我们在多线程的情况下，事情将截然不同。如果想要以线程安全的方式以多线程在伊甸园空间存储对象，不可避免的需要加锁，而这将极大地的影响性能。TLABs 是HotSpot虚拟机针对这一问题的解决方案。该方案为每一个线程在伊甸园空间分配一块独享的空间，这样每个线程只访问他们自己的TLAB空间，再与bump-the-pointer技术结合可以在不加锁的情况下分配内存。 以上是针对新生代空间GC技术的简要介绍，你不需要刻意记住我刚刚提到的两种技术。不知道他们不会对你产生什么影响，但是请务必记住在对象刚刚被创建之后，是保存在伊甸园空间的。那些长期存活的对象会经由幸存者空间转存在老年代空间。 老年代GC处理机制 老年代空间的GC事件基本上是在空间已满时发生，执行的过程根据GC类型不同而不同，因此，了解不同的GC类型将有助于你理解本节的内容。 JDK7一共有5种GC类型： Serial GC Parallel GC Parallel Old GC (Parallel Compacting GC) Concurrent Mark & Sweep GC (or “CMS”) Garbage First (G1) GC 其中，Serial GC不应该被用在服务器上。这种GC类型在单核CPU的桌面电脑时代就存在了。使用Serial GC会显著的降低应用的性能指标。 现在，让我们共同学习每一种GC类型。 Serial GC (-XX:+UseSerialGC) 新生代空间的GC方式我们在前面已经介绍过了，在老年代空间中的GC采取称之为”mark-sweep-compact“的算法。 算法的第一步是标记老年代中依然存活对象。（标记） 第二步，从头开始检查堆内存空间，并且只留下依然幸存的对象。（清理） 最后一步，从头开始，顺序地填满堆内存空间，并且将对内存空间分成两部分：一个保存着对象，另一个空着（压缩）。 Parallel GC (-XX:+UseParallelGC) 图 4: Serial GC 与 Parallel GC的区别 从上图中，你可以轻易地看出serial GC和parallel GC的区别，serial GC只使用一个线程执行GC，而parallel GC使用多个线程，因此parallel GC更高效。这种GC在内存充足以及多核的情况下会很有用，因此我们也称之为”throughput GC“。 Parallel Old GC(-XX:+UseParallelOldGC) Parallel Old GC在JDK5之后出现。与parallel GC相比，唯一的区别在于针对老年代的GC算法。Parallel Old GC分为三步：标记-汇总-压缩（mark – summary – compaction）。汇总（summary）步骤与清理（sweep）的不同之处在于，其将依然幸存的对象分发到GC预先处理好的不同区域，算法相对清理来说略微复杂一点。 CMS GC (-XX:+UseConcMarkSweepGC) 图 5: Serial GC & CMS GC 就像你从上图看到的那样, CMS GC比我之前解释的各种算法都要复杂很多。第一步初始化标记（initial mark） 比较简单。这一步骤只是查找那些距离类加载器最近的幸存对象。因此，停顿的时间非常短暂。在之后的并行标记（ concurrent mark ）步骤，所有被幸存对象引用的对象会被确认是否已经被追踪和校验。这一步的不同之处在于，在标记的过程中，其他的线程依然在执行。在重新标记（remark）步骤，会再次检查那些在并行标记步骤中增加或者删除的与幸存对象引用的对象。最后，在并行交换（ concurrent sweep ）步骤，转交垃圾回收过程处理。垃圾回收工作会在其他线程的执行过程中展开。一旦采取了这种GC类型，由GC导致的暂停时间会极其短暂。CMS GC也被称为低延迟GC。它经常被用在那些对于响应时间要求十分苛刻的应用之上。 当然，这种GC类型在拥有stop-the-world时间很短的优点的同时，也有如下缺点： 它会比其他GC类型占用更多的内存和CPU 默认情况下不支持压缩步骤 在使用这个GC类型之前你需要慎重考虑。如果因为内存碎片过多而导致压缩任务不得不执行，那么stop-the-world的时间要比其他任何GC类型都长，你需要考虑压缩任务的发生频率以及执行时间。 G1 GC 最后，我们来学习垃圾回收优先（G1）GC类型。 图 6: G1 GC的结构 如果你想要理解G1，首先你要忘记你所学过的新生代和老年代的概念。正如你在上图所看到的，每个对象被分配到不同的格子，随后GC执行。当一个区域装满之后，对象被分配到另一个区域，并执行GC。这中间不再有从新生代移动到老年代的三个步骤。这个类型是为了替代CMS GC而被创建的，因为CMS GC在长时间持续运作时会产生很多问题。 G1最大的好处是性能，他比我们在上面讨论过的任何一种GC都要快。但是在JDK 6中，他还只是一个早期试用版本。在JDK7之后才由官方正式发布。就我个人看来，NHN在将JDK 7正式投入商用之前需要很长的一段测试期（至少一年）。因此你可能需要再等一段时间。并且，我也听过几次使用了JDK 6中的G1而导致Java虚拟机宕机的事件。请耐心的等到它更稳定吧。 下一次我将讨论GC优化相关的问题，但是在此之前我要先明确一件事情，假如应用中创建的所有对象的大小和类型都是统一的，那么公司使用的WAS的GC参数可以是相同的。但是WAS所创建对象的大小和生命周期根据服务以及硬件的不同而不同。换句话说，不能因为某个应用使用的GC参数“A”，就说明同样的参数也能给其他服务带来最佳的效果。而是要因地制宜，有的放矢。我们需要找到适合每个WAS线程的参数，并且持续的监控和优化每个设备上的WAS实例。这并不是我的一家之谈，而是负责Oracle Java虚拟机研发的工程师在 JavaOne 2010上已经讨论过的。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p012.html":{"url":"article/p012.html","title":"成为Java GC专家(2)：如何监控Java垃圾回收机制","keywords":"","body":"成为Java GC专家(2)：如何监控Java垃圾回收机制 英文原文 本文是成为Java GC专家系列文章的第二篇。在第一篇《成为Java GC专家(1)：深入浅出Java垃圾回收机制》中我们学习了不同GC算法的执行过程，GC是如何工作的，什么是新生代和老年代，你应该了解的JDK7中的5种GC类型，以及这5种类型对于应用性能的影响。 在本文中，我将解释JVM到底是如何执行垃圾回收处理的。 什么是GC监控？ 垃圾回收收集监控指的是搞清楚JVM如何执行GC的过程，例如，我们可以查明： 何时一个新生代中的对象被移动到老年代时，所花费的时间。 Stop-the-world 何时发生的，持续了多长时间。 GC监控是为了鉴别JVM是否在高效地执行GC，以及是否有必要进行额外的性能调优。基于以上信息，我们可以修改应用程序或者调整GC算法（GC优化）。 如何监控GC 有很多种方法可以监控GC，但其差别仅仅是GC操作通过何种方式展现而已。GC操作是由JVM来完成，而GC监控工具只是将JVM提供的GC信息展现给你，因此，不论你使用何种方式监控GC都将得到相同的结果。所以你也就不必去学习所有的监控GC的方法。但是因为学习每种监控方法不会占用太多时间，了解多一点可以帮助你根据不同的场景选择最为合适的方式。 下面所列的工具以及JVM参数并不适用于所有的HVM供应商。这是因为并没有关于GC信息的强制标准。本文我们将使用HotSpot JVM (Oracle JVM)。因为NHN 一直在使用Oracle (Sun) JVM，所以用它作为示例来解释我们提到的工具和JVM参数更容易些。 首先，GC监控方法根据访问的接口不同，可以分成 CUI 和 GUI 两大类。CUI GC监控方法使用一个独立的叫做”jstat”的CUI应用，或者在启动JVM的时候选择JVM参数”verbosegc”。 GUI GC监控由一个单独的图形化应用来完成，其中三个最常用的应用是”jconsole”, “jvisualvm” 和 “Visual GC”。 下面我们来详细学习每种方法。 jstat jstat 是HotSpot JVM提供的一个监控工具。其他监控工具还有 jps 和 jstatd。有些时候，你可能需要同时使用三种工具来监控你的应用。 jstat 不仅提供GC操作的信息，还提供类装载操作的信息以及运行时编译器操作的信息。本文将只涉及jstat能够提供的信息中与监控GC操作信息相关的功能。 jstat 被放置在$JDK_HOME/bin。因此只要 java 和 javac 能执行，jstat 同样可以执行。 你可以在命令行环境下执行如下语句。 $> jstat –gc $ 1000 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 3008.0 3072.0 0.0 1511.1 343360.0 46383.0 699072.0 283690.2 75392.0 41064.3 2540 18.454 4 1.133 19.588 3008.0 3072.0 0.0 1511.1 343360.0 47530.9 699072.0 283690.2 75392.0 41064.3 2540 18.454 4 1.133 19.588 3008.0 3072.0 0.0 1511.1 343360.0 47793.0 699072.0 283690.2 75392.0 41064.3 2540 18.454 4 1.133 19.588 $> 在上图的例子中，实际的数据会按照如下列输出： S0C S1C S0U S1U EC EU OC OU PC vmid (虚拟机 ID)，正如其名字描述的，它是虚拟机的ID，Java应用不论运行在本地还是远程的机器都会拥有自己独立的vmid。运行在本地机器上的vmid称之为lvmid (本地vmid)，通常是PID。如果想得到PID的值你可以使用ps命令或者Windows任务管理器，但我们推荐使用jps来获取，因为PID和lvmid有时会不一致。jps 通过Java PS实现，jps命令会返回vmids和main方法的信息，正如ps命令展现PIDS和进程名字那样。 首先通过jps命令找到你要监控的Java应用的vmid，并把它作为jstat的参数。当几个WAS实例运行在同一台设备上时，如果你只使用jps命令，将只能看到启动（bootstrap）信息。我们建议在这种情况下使用ps -ef | grep java与jps配合使用。 想要得到GC性能相关的数据需要持续不断地监控，因此在执行jstat时，要规则地输出GC监控的信息。 例如，执行”jstat –gc 1000″ (或 1s)会每隔一秒展示GC监控数据。”jstat –gc 1000 10″会每隔1秒展现一次，且一共10次。 除了-gc之外还有许多选项，其中GC相关的选项如下所示。 参数名称 描述 gc 输出每个堆区域的当前可用空间以及已用空间（伊甸园，幸存者等等），GC执行的总次数，GC操作累计所花费的时间 gccapactiy 输出每个堆区域的最小空间限制（ms）/最大空间限制（mx），当前大小，每个区域之上执行GC的次数。（不输出当前已用空间以及GC执行时间） gccause 输出-gcutil提供的信息以及最后一次执行GC的发生原因和当前所执行的GC的发生原因 gcnew 输出新生代空间的GC性能数据 gcnewcapacity 输出新生代空间的大小的统计数据 gcold 输出老年代空间的GC性能数据 gcoldcapacity 输出老年代空间的大小的统计数据 gcpermcapacity 输出持久带空间的大小的统计数据 gcutil 输出每个堆区域使用占比，以及GC执行的总次数和GC操作所花费的事件 你可以只关心那些最常用的命令，你会经常用到 -gcutil (或-gccause), -gc 和 –gccapacity。 -gcutil 被用于检查堆间的使用情况，GC执行的次数以及GC操作所花费的时间。 -gccapacity 以及其它的参数可以用于检查实际分配内存的大小。 使用 -gc 参数你可以看到如下输出： S0C S1C … GCT 1248.0 896.0 … 1.246 1248.0 896.0 … 1.246 … … … … 不同的jstat参数输出不同类型的列，如下表所示，根据你使用的”jstat option”会输出不同列的信息。 列 说明 Jstat参数 S0C 输出Survivor0空间的大小，单位KB -gc-gccapacity-gcnew-gcnewcapacity S1C 输出Survivor1空间的大小，单位KB -gc-gccapacity-gcnew-gcnewcapacity S0U 输出Survivor0已用空间的大小，单位KB -gc-gcnew S1U 输出Survivor1已用空间的大小，单位KB -gc-gcnew EC 输出Eden空间的大小，单位KB -gc-gccapacity-gcnew-gcnewcapacity EU 输出Eden已用空间的大小，单位KB -gc-gcnew OC 输出老年代空间的大小，单位KB -gc-gccapacity-gcold-gcoldcapacity OU 输出老年代已用空间的大小，单位KB -gc-gcold PC 输出持久代空间的大小，单位KB -gc-gccapacity-gcold-gcoldcapacity-gcpermcapacity PU 输出持久代已用空间的大小，单位KB -gc-gcold YGC 新生代空间GC时间发生的次数 -gc-gccapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause YGCT 新生代GC处理花费的时间 -gc-gcnew-gcutil-gccause FGC full GC发生的次数 -gc-gccapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause FGCT full GC操作花费的时间 -gc-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause GCT GC操作花费的总时间 -gc-gcold-gcoldcapacity-gcpermcapacity-gcutil-gccause NGCMN 新生代最小空间容量，单位KB -gccapacity-gcnewcapacity NGCMX 新生代最大空间容量，单位KB -gccapacity-gcnewcapacity NGC 新生代当前空间容量，单位KB -gccapacity-gcnewcapacity OGCMN 老年代最小空间容量，单位KB -gccapacity-gcoldcapacity OGCMX 老年代最大空间容量，单位KB -gccapacity-gcoldcapacity OGC 老年代当前空间容量制，单位KB -gccapacity-gcoldcapacity PGCMN 持久代最小空间容量，单位KB -gccapacity-gcpermcapacity PGCMX 持久代最大空间容量，单位KB -gccapacity-gcpermcapacity PGC 持久代当前空间容量，单位KB -gccapacity-gcpermcapacity PC 持久代当前空间大小，单位KB -gccapacity-gcpermcapacity PU 持久代当前已用空间大小，单位KB -gc-gcold LGCC 最后一次GC发生的原因 -gccause GCC 当前GC发生的原因 -gccause TT 老年化阈值。被移动到老年代之前，在新生代空存活的次数 -gcnew MTT 最大老年化阈值。被移动到老年代之前，在新生代空存活的次数 -gcnew DSS 幸存者区所需空间大小，单位KB -gcnew jstat 的好处是它可以持续的监控GC操作数据，不论Java应用是运行在本地还是远程，只要有控制台的地方就可以使用。当使用–gcutil会输出如下信息。在GC优化的时候，你需要特别注意YGC, YGCT, FGC, FGCT 和GCT。 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 这些信息很重要，因为它们展示了GC处理到底花费了多少时间。 在这个例子中，YGC 是217而 YGCT 是0.928，这样在简单的计算数据平均数后，你可以知道每次新生代的GC大概需要4ms（0.004秒），而full GC的平均时间为33ms。 但是，只看数据平均数经常无法分析出真正的GC问题。这是主要是因为GC操作时间严重的偏差（换句话说，假如两次full GC的时间是 67ms，那么其中的一次full GC可能执行了10ms而另一个可能执行了57ms。）为了更好地检测每次GC处理时间，最好使用 –verbosegc来替代数据平均数。 -verbosegc -verbosegc 是在启动一个Java应用时可以指定的JVM参数之一。而jstat 可以监控任何JVM应用，即便它没有制定任何参数。 -verbosegc 需要在启动的时候指定，因此你可能会认为它没有必要（因为jstat可以替代之）。但是， -verbosegc 会以更浅显易懂的方式展现GC发生的结果，因此他对于监控监控GC信息十分有用。 jstat -verbosegc 监控对象 运行在本机的Java应用可以把日志输出到终端上，或者借助jstatd命令通过网络连接远程的Java应用 只有那些把-verbogc作为启动参数的JVM 输出信息 堆状态（已用空间，最大限制，GC执行次数/时间，等等） 执行GC前后新生代和老年代空间大小，GC执行时间 输出时间 Every designated time 每次设定好的时间 每次GC发生的时候 何时有用 当你试图观察堆空间变化情况 当你试图了解单次GC产生的效果 下面是 -verbosegc 的可用参数 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintGCDateStamps (from JDK 6 update 4) 如果只是用了 -verbosegc。那么默认会加上 -XX:+PrintGCDetails。 –verbosgc 的附加参数并不是独立的。而是经常组合起来使用。 使用 –verbosegc 后，每次GC发生你都会看到如下格式的结果。 [GC [: -> , secs] -> , secs] 收集器 minor gc使用的收集器的名字 starting occupancy1 GC执行前新生代空间大小 ending occupancy1 GC执行后新生代空间大小 pause time1 因为执行minor GC，Java应用暂停的时间 starting occupancy3 GC执行前堆区域总大小 ending occupancy3 GC执行后堆区域总大小 pause time3 Java应用由于执行堆空间GC（包括major GC）而停止的时间 这是 -verbosegc 输出的 minor GC 的例子： S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 0.00 66.44 54.12 10.58 86.63 217 0.928 2 0.067 0.995 这是 Full GC 发生时的例子： [Full GC [Tenured: 3485K->4095K(4096K), 0.1745373 secs] 61244K->7418K(63104K), [Perm : 10756K->10756K(12288K)], 0.1762129 secs] [Times: user=0.19 sys=0.00, real=0.19 secs] 如果使用了 CMS collector，那么如下CMS信息也会被输出。 由于 –verbosegc 参数在每次GC事件发生的时候都会输出日志，我们可以很轻易地观察到GC操作对于堆空间的影响。 (Java) VisualVM + Visual GC Java Visual VM是由Oracle JDK提供的图形化的汇总和监控工具。 图1: VisualVM 截图 除了JDK中自带的版本，你还可以直接从官网下载Visual VM。出于便利性的考虑，JDK中包含的版本被命名为Java VisualVM (jvisualvm),而官网提供的版本被命名为Visual VM (visualvm)。两者的功能基本相同，只有一些细小的差别，例如安装组件的时候。就个人而言，我更喜欢可以从官网下载的Visual VM。 图 2: Viusal GC 安装截图 通过Visual GC，你可以更直观的看到执行 jstatd 所得到的信息。 图3: Visual GC 执行截图 HPJMeter HPJMeter 可以很方便的分析 -verbosegc 输出的结果，如果Visual GC可以视作jstat的图形化版本，那么HPJMeter就相当于 –verbosgc的图形化版本。当然，GC分析只是HPJMeter提供的众多功能之一，HPJMeter是由惠普开发的性能监控工具，他可以支持HP-UX，Linux以及MS Windows。 起初，一个成为 HPTune 被设计用来图形化的分析 -verbosegc。输出的结果。但是，随着HPTune的功能被集成到HPJMeter 3.0版本之后，就没有必要单独下载HPTune了。 但运行一个应用时，-verbosegc 的结果会被输出到一个独立的文件中。 你可以用HPJMeter直接打开这个文件，以便更直观的分析GC性能数据。 图4: HPJMeter 下次预告 本文我们主要讲述了如果监控GC操作信息，这将是GC优化的前提。就我个人经验而言，我推荐使用 jstat 来监控GC操作，如果你感觉到GC操作的执行时间过长，那就可以使用 -verbosegc 参数来分析GC。GC优化的大体步骤就是在添加 -verbosegc 参数后，调整GC参数，分析修改后的结果。在下一篇文章中，我们将通过真实的例子来讲解优化GC的最佳选择。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p013.html":{"url":"article/p013.html","title":"成为Java GC专家(3)：如何优化Java垃圾回收机制","keywords":"","body":"成为Java GC专家(3)：如何优化Java垃圾回收机制 英文原文 本文是成为Java GC专家系列文章的第三篇。在第一篇《成为Java GC专家(1)：深入浅出Java垃圾回收机制》中我们学习了不同GC算法的执行过程，GC是如何工作的，什么是新生代和老年代，你应该了解的JDK7中的5种GC类型，以及这5种类型对于应用性能的影响。 在第二篇《成为Java GC专家(2)：如何监控Java垃圾回收机制》，解释了JVM实际上是如何执行垃圾回收的，我们如何监控GC，以及那哪些具可以让我们的工作更快，更高效。在第三篇文章中，我们会基于实际的例子来解释一些优化GC的最佳实践。我认为在阅读本篇文章之前，你已经很好地理解了之前的文章，因此，为了你能够更好地学习本文，如果你还没有读过之前的两篇文章话，请先阅读。 为什么需要优化GC 或者说的更确切一些，对于基于Java的服务，是否有必要优化GC？应该说，对于所有的基于Java的服务，并不总是需要进行GC优化，但前提是所运行的基于Java的系统，包含了如下参数或行为： 已经通过 -Xms 和 –Xmx 设置了内存大小 包含了 -server 参数 系统中没有超时日志等错误日志 换句话说，如果你没有设定内存的大小，并且系统充斥着大量的超时日志时，你就需要在你的系统中进行GC优化了。 但是，你需要时刻铭记一条：GC优化永远是最后一项任务。 想一下进行GC优化的最根本原因，垃圾收集器清除在Java程序中创建的对象，GC执行的次数即需要被垃圾收集器清理的对象个数，与创建对象的数量成正比，因此，首先你应该减少创建对象的数量。 俗话说的好，“冰冻三尺非一日之寒”。我们应该从小事做起，否则日积月累就会很难管理。 我们需要使用 StringBuilder 或者 StringBuffer 来替代String 应该尽量少的输出日志 但是，我们知道有些情况会让我们束手无策，我们眼睁睁的看着XML以及JSON解析占用了大量的内存。即便我们已经尽可能少的使用 String 以及尽量少的输出日志，大量的临时内存被用于XML或者JSON解析，例如10-100MB。但是，舍弃XML和JSON是很难的。我们只要知道，他会占用很多内存。 如果应用内存使用量经过几次重复调整之后有所改善，你就可以开始GC优化了。 我为GC优化归纳了两个目的： 一个是将转移到老年代的对象数量降到最少 另一个是减少Full GC的执行时间 将转移到老年代的对象数量降到最少 按代的GC机制由Oracle JVM提供，不包括可以在JDK7以及更高版本中使用的G1 GC。换句话说，对象被创建在伊甸园空间，而后转化到幸存者空间，最终剩余的对象被送到老年代。某些比较大的对象会在被创建在伊甸园空间后，直接转移到老年代空间。老年代空间上的GC处理会新生代花费更多的时间。因此，减少被移到老年代对象的数据可以显著地减少Full GC的频率。减少被移到老年代空间的对象的数量，可能被误解为将对象留在新生代。但是，这是不可能的。取而代之，你可以调整新生代空间的大小。 减少Full GC执行时间 Full GC的执行时间比Minor GC要长很多。因此，如果Full GC花费了太多的时间（超过1秒），一些连接的部分可能会发生超时错误。 如果你试图通过消减老年代空间来减少Full GC的执行时间，可能会导致 OutOfMemoryError 或者 Full GC执行的次数会增加。 与之相反，如果你试图通过增加老年代空间来减少Full GC执行次数，执行时间会增加。 因此，你需要将老年代空间设定为一个“合适”的值。 影响GC性能的参数 正如我们在《成为Java GC专家(2)：如何监控Java垃圾回收机制》结尾提到的，不要幻想“某个人设定了GC参数后性能得到极大的提高，我们为什么不和他用一样的参数？”，因为不同的Web服务所创建对象的大小和他们的生命周期都不尽相同。 简单来说，如果一个任务的执行条件是A，B，C，D和E，同样的任务执行条件换为A和B，你会觉得哪个更快？从一般人的直觉来看，在A和B条件下执行的任务会更快。 Java GC参数也是相同的道理，设定一些参数不但没有提高GC执行速度，反而可能导致他更慢。GC优化的最基本原则是将不同的GC参数用于2台或者多台服务器，并进行对比，并将那些被证明提高了性能或者减少了GC执行时间的参数应用于服务器。请谨记这一点。 下面这个表格列出了GC参数中与内存大小相关的，可以影响性能的参数。 表1：GC优化需要考虑的Java参数 定义 参数 描述 堆内存空间 -Xms Heap area size when starting JVM启动JVM时的堆内存空间 -Xmx Maximum heap area size堆内存最大限制 新生代空间 -XX:NewRatio Ratio of New area and Old area新生代和老年代的占比 -XX:NewSize New area size新生代空间 -XX:SurvivorRatio Ratio ofEdenarea and Survivor area伊甸园空间和幸存者空间的占比 我在进行GC优化时经常使用 -Xms，-Xmx和-XX:NewRatio。-Xms 和 -Xmx 是必须的。你如何设定 NewRatio 会对GC性能产生十分显著的影响。 有些人可能会问如何设定Perm区域的大小？你可以通过 -XX:PermSize 和 -XX:MaxPermSize 参数来设定，当 OutOfMemoryError 错误发生并且是由于Perm空间不足导致时。 另一个可能影响GC性能的参数是GC类型。下表列出了所有可选的GC类型（基于JDK6.0） 表2：GC类型可选参数 分类 参数 备考 Serial GC -XX:+UseSerialGC Parallel GC -XX:+UseParallelGC-XX:ParallelGCThreads=value Parallel Compacting GC -XX:+UseParallelOldGC CMS GC -XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+CMSParallelRemarkEnabled-XX:CMSInitiatingOccupancyFraction=value-XX:+UseCMSInitiatingOccupancyOnly G1 -XX:+UnlockExperimentalVMOptions-XX:+UseG1GC 在JDK6中这两个参数必须同时使用 除了G1 GC，可以通过每种类型第一行的参数来切换GC类型。最常用的GC类型是Serial GC。他专门针对客户端系统进行了优化。 影响GC性能的参数有很多，但是上面提到的参数会带来最显著的效果。请牢记，设定过多的参数不一定会减少GC执行时间。 GC优化过程 GC优化的过程与大多数性能改善的过程及其类似。下面是我使用的GC优化过程。 监控GC状态 首先你需要监控GC来检查在系统执行过程中GC的各种状态。请参考前一篇文章中提到的监控方法 《成为Java GC专家(2)：如何监控Java垃圾回收机制》。 在分析监控结果后，决定是否进行GC优化 在检查GC状态的过程中，你应该分析监控结果以便决定是否进行GC优化，如果分析结果表明执行GC的时间只有0.1-0.3秒，那你就没必要浪费时间去进行GC优化。但是，如果GC的执行时间是1-3秒，或者超过10秒，GC将势在必行。 但是，如果你已经为Java分配了10GB的内存，并且不能再减少内存大小，你将无法再对GC进行优化。在进行GC优化之前，你必须想清楚你为什么要分配如此大的内存空间。假如当你分1 GB 或 2 GB内存时出现 OutOfMemoryError ，你应该执行堆内存转储（heap dump），并消除隐患。 注意： 堆内存转储是一个用来检查Java内存中的对象和数据的文件。该文件可以通过执行JDK中的jmap命令来创建。在创建文件的过程中，Java程序会暂停，因此不要再系统执行过程中创建该文件。 你可以在互联网上搜索堆内存[s1] 转储的详细说明。对于韩国的读者，可以参考我去年发布的书： The story of troubleshooting for Java developers and system operators (Sangmin Lee, Hanbit Media, 2011, 416 pages)。 调整GC类型/内存空间 如果你已经决定要进行GC优化，那么就要选择GC类型和设定内存空间。在这时，如果你有几台不同服务器，请时刻牢记，检查每一台服务器的GC参数，并进行有针对性的优化。 分析结果 在调整了GC参数并持续收集24小时之后，开始对结果进行分析，如果你幸运的话，你就找到那些最适合系统的GC参数。反之，你需要通过分析日志来检查内存是如何被分配的。然后你需要通过不断的调整GC类型和内存空间大小一边找到最佳的参数。 如果结果令人满意，你可以将该参数应用于所有的服务器，并停止GC优化 有过GC优化结果令人满意，你可以应用于所有的服务器，下面的章节中，我们将看到每个步骤的具体任务。 监控GC状态及分析结果 查看运行中的Web Application Server (WAS)的GC状态的最佳方法是通过jstat命令，在第二篇文章《成为Java GC专家(2)：如何监控Java垃圾回收机制》中我已经详细解释过jstat命令，因此本篇文章我将重点描述数据部分。 下面这个例子展现了某个JVM在进行GC优化之前的状态。（很遗憾，这不是一个操作服务器） $ jstat -gcutil 21719 1s S0 S1 E O P YGC YGCT FGC FGCT GCT 48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673 48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673 如上表，我们先看一下YGC 和YGCT，计算YGCT/ YGC得到0.050秒（50毫秒）。这意味着新生代空间上的GC操作平均花费50毫秒。在这种情况，你大可不必担心新生代空间上执行的GC操作。 接下来，我们来看一下FGCT 和FGC。，计算FGCT/ FGC得到19.68秒，这意味着GC的平均执行时间为19.68秒，可能是每次花费19.68秒执行了三次，也可能是其中的两次执行了1秒而另一次执行了58秒。不论哪种情况，都需要进行GC优化。 通过 jstat 命令可以很轻易地查看GC状态，但是，分析GC的最佳方式是通过 –verbosegc 参数来生成日志，在之前的文章中我已经解释了如何分析这些日志，HPJMeter 是我个人最喜欢的用于分析 -verbosegc 日志的工具。他很易于使用和分析结果。通过HPJmeter你可以很轻易查看GC执行时间以及GC发生频率。 如果GC执行时间满足下面所有的条件，就意味着无需进行GC优化了。 Minor GC执行的很快（小于50ms） Minor GC执行的并不频繁（大概10秒一次） Full GC执行的很快（小于1s） Full GC执行的并不频繁（10分钟一次） 上面提到的数字并不是绝对的；他们根据服务状态的不同而有所区别，某些服务可能满足于Full GC每次0.9秒的速度，但另一些可能不是。因此，针对不同的服务设定不同的值以决定是否进行GC优化。 在查看GC状态的时候有件事你需要特别注意，那就是不要只关注Minor GC 和Full GC的执行时间。还要关注GC执行的次数，例如，当新生代空间较小时，Minor GC会过于频繁的执行（有时每秒超过1次）。另外，转移到老年代的对象数增多，则会导致Full GC执行次数增多。因此，别忘了加上 –gccapacity 参数来查看具体占用了多少空间。 设定GC类型/内存空间大小 设定GC类型 OracleJVM有5种GC类型，但是在JDK7之前的版本中，只能在Parallel GC, Parallel Compacting GC 和CMS GC之中选择一个，对于选择哪个没有明确的原则和规则。 这样的话，我们该如何选择呢？强烈建议三者都选，但是，有一点是很明确的：CMS GC比Parallel GCs更快。如果真的如此，那么就选CMS GC了。但是，CMS GC也不总是更快。整体来看，CMS GC模式下的Full GC执行更快，不过，一旦出现并行模式失败，他将比Parallel GC更慢。 并发模式失败 我们来详细讲解一下并发模式失败。 Parallel GC 和 CMS GC 最大的不同来自于压缩任务。压缩任务是通过删除已分配内存空间中的空白空间以便压缩内存，清理内存碎片。 在Parallel GC模式下，压缩工作在Full GC执行时进行，这会费很多时间，但是，在执行完Full GC之后，由于能够顺序地分配空间，随后的内存能够被更快的分配。 与之相反的，CMS GC并不进行压缩处理，因此，CMS GC执行的更快。但是，由于没有压缩，在进行磁盘清理之前，内存中会有很多空白空间。这就是说，可能没有足够的空间存储大的对象，例如，虽然老年代空间还有300MB空间，但是一些10MB的对象无法被顺序的存储。在这种情况下，会出现“并行模式失败”警告，并执行压缩处理。在CMS GC模式下，压缩处理的执行时间要比Parallel GCs长很多。另外，这还将导致另外一个问题。关于并发模式失败的详细说明，可以参考Oracle工程师撰写的Understanding CMS GC Logs。 综上所述，你需要找到最适合你的系统的GC类型。 每个系统都有最适合他的GC类型等着你去寻找，如果你有6台服务器。我建议你每两台设置相同的参数。并添加 –verbosegc 参数，分析结果。 设定内存空间大小 下表展示了内存空间大小，GC执行次数以及GC执行时间三者间的关系。 大内存空间 减小GC执行次数 增加GC执行时间 小内存空间 减小GC执行时间 增加GC执行次数 关于如何设置内存空间的大小，没有唯一的标准答案。如果服务器资源足够，而且Full GC也可能在1秒内完成，设置为10GB当然可行。。但绝大多数服务器并不是这样，当内存设为10GB时，可能要花费10~30秒来执行Full GC。当然，执行时间会随对象的大小而改变。 鉴于如此，我们应该如何设定内存空间大小呢？一般来说，我建议为500MB。不过请注意这不是让你将WAS的内存参数设置为 –Xms500m 和 –Xmx500m。根据优化GC之前的状态，如果Full GC执行之后内存空间剩余300MB，那么最好将内存设置为1GB（300MB（默认程序占用）+ 500MB（老年代最小空间）+200MB（空闲内存））。也就是说你要为老年代额外设置500MB。因此，如果你有三个执行服务器，内存分别设置为1GB，1.5GB，2GB，并且检查结果。 理论上来讲，GC执行速度应该遵循1GB> 1.5GB> 2GB,因此1GB执行GC速度最快。但是并不说明1GB空间的Full GC会花费1秒而2GB空间会花费2秒。时间取决于服务器的性能和对象的大小。因此，最佳的方式是建立尽可能多的衡量指标来监控他们。 对于内存空间大小，你应该额外设定 NewRatio 参数。 NewRatio参数是新生代和老年代空间的比例，即 XX:NewRatio=1 意味着新生代与老年代之比为1:1。对于1GB来说就是新生代和老年代各500MB。如果 NewRatio 为2，意味着新生代老年代之比为1:2，因此该值越大，老年代空间越大，新生代空间越小。 这看似一件不是很重要的事情，但 NewRatio 参数会显著地影响整个GC的性能。如果新生代空间很小，会用更多的对象被转移到老年代空间，这样导致频繁的Full GC，增加暂停时间。 你可以简单的认为 NewRatio 为1是最佳的选择，但是，有时可能设置为2或3更好，我就见过很多这样的例子。 如何最快的完成GC优化？对比性能测试的结果应该是最快地方法，为每一台服务器设置不同的参数并监控他们的状态，强烈建议至少监控1或2天的数据。但是，当你对GC优化是，你要确保每次执行相同的负载。并且请求的比率，例如URL都应该是一致的。不过，即便对于专业测试人员要想精确的控制负载也是很难的，并要花费大量的时间准备。因此，相对来说比较方便和容易的方法是调整才参数，之后花费较长的时间收集结果。 分析GC优化结果 在设置了GC参数以及 -verbosegc 参数之后，通过 tail 命令确保日志被正确的生成。如果参数设置的不正确或者日志没有生成，你将白白浪费你的时间。如果日志正确的话，持续收集1到2天。随后最好将日志下载到本地PC并用 HPJMeter 来分析。 Full GC 执行时间 Minor GC执行时间 Full GC 执行间隔 Minor GC 执行间隔 Entire Full GC 执行时间 Entire Minor GC 执行时间 Entire GC 执行时间 Full GC e执行时间 Minor GC 执行时间 找到最佳的GC参数是件非常幸运的事情，然而在大多数场合，我们并不会得到幸运之神的眷顾，在进行GC优化时要尽量小心谨慎，想一步完成优化往往会导致 OutOfMemoryError 。 优化示例 好了，我们一直在纸上谈兵，现在我们看一些实际的GC优化的例子。 示例1 下面这个例子针对 Service S 的优化,对于最近被部署的 Service S，Full GC花费了太长的时间。 请看 jstat –gcutil 的执行结果。 S0 S1 E O P YGC YGCT FGC FGCT GCT 12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993 最左边的 Perm 空间对于最初的GC优化不是很重要，这一次YGC参数的值更加有用。 Minor GC和Full GC的平均值如下表所示。 表3：Service S的Minor GC 和Full GC的平均执行时间 GC 类型 GC 执行次数 GC 执行时间 平均 Minor GC 54 2.047 37 ms Full GC 5 6.946 1,389 s 最重要的是下面两个数据 新生代实际使用空间: 212,992 KB 老年代实际使用空间: 1,884,160 KB 因此，总的内存空间为2GB，不算Perm空间的话，新生代与老年代之比为1:9。通过jstat和 -verbosegc 日志进行数据收集，并把三台服务器按照如下方式设置。 NewRatio=2 NewRatio=3 NewRatio=4 一天之后，检查系统的GC日志后发现，在设置了 NewRatio 参数后很幸运的没有发生Full GC。 为什么？ NewRatio=2: 45 ms NewRatio=3: 34 ms NewRatio=4: 30 ms 我们看到NewRatio=4 是最佳的参数，虽然它的新生代空间最小，但GC时间确最短。设定这个参数之后，系统没有执行过Full GC。 为了说明这个问题，下面是服务之星一段时间后执行 jstat –gcutil 的结果。 S0 S1 E O P YGC YGCT FGC FGCT GCT 8.61 0.00 30.67 24.62 22.38 2424 30.219 0 0.000 30.219 你可能会认为因为服务器接受的请求少才导致的GC执行频率下降。实际上，虽然Full GC没有执行，但是Minor GC被执行了 2,424次。 示例2 这是一个针对ServiceA的例子，我们通过公司内部的应用性能管理系统（APM）发现JVM暂停了相当长的时间（超过8秒），因此我们进行了GC优化。我们找到了Full GC执行时间过长的原因，并着手解决。 进行GC优化的第一步，就是我们添加了 -verbosegc 参数，并得到如下结果。 图1：进行GC优化之前的STW时间 如上图所示，由HPJMeter自动生成的图片之一。X坐标表示JVM执行的时间。Y坐标表示每次GC的时间。CMS绿点，表示Full GC结果。Parallel Scavenge蓝点，表示Minor GC结果。 之前我曾经说过CMS GC是最快的，但是上面的的结果显示出于某种原因，它最多花费了15秒。是什么导致这个结果？是否想起我之前提过的，CMS在进行内存清理时，会变慢。与此同时，服务的内存被设定为 –Xms1g 和 –Xmx4g ，且实际分配了4GB内存。 因此，我将GC类型从CMS改为Parallel GC。并且将内存改为2GB，设定 NewRatio 为3。几小时之后我使用 jstat –gcutil 得到如下结果。 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 30.48 3.31 26.54 37.01 226 11.131 4 11.758 22.890 相对于4GB时的15秒，Full GC变成了平均每次3秒。但是3秒一样比较慢，因此我设计了如下6种场景。 Case 1: -XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=2 Case 2: -XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=3 Case 3: -XX:+UseParallelGC -Xms1g -Xmx1g -XX:NewRatio=3 Case 4: -XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=2 Case 5: -XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=3 Case 6:-XX:+UseParallelOldGC -Xms1g -Xmx1g -XX:NewRatio=3 那一个最快呢？结果显示，内存越小，结果越好。下图展示了Case6的结果。这是GC的性能最好。最长的响应时间只有1.7秒。平均时间在1秒之内。 图2：Case6的时间图表 基于以上结果。我们按照Case6调整了GC参数。但是，这导致了每天晚上都会发生OutOfMemoryError。在这里很难解释具体的原因。简单来说，批处理程序导致了内存泄漏。相关的问题已经被解决。 如果对GC日志只分析很短的时间就贸然对所有服务器进行优化是非常危险的。请时刻牢记，你必须同时分析GC日志和应用程序。 我们回顾了两个关于GC优化的例子，正如我之前提到的，例子中提到的GC参数，可以设置在相同的服务器之上，但前提是他们具有相同的CPU，操作系统，JDK版本以及运行着相同的服务。但是不要直接把我用过的参数用到你的服务至上，它们未必能很好的工作。 结论 我凭借经验进行GC优化，而没有执行堆转储并分析内存的详细内容。精确地分析内存可以得到更好的优化效果。但是，这种分析一般适用于内存使用量相对固定的场合。不过，如果服务严重过载并占用的大量的内存，强力建议根据之前的经验进行GC优化。 我已经在一些服务上设置了G1 GC参数，并进行过性能测试。但还没有应用与正式环境，G1 GC参数的速度要快于其他任何GC类型。但是，你必须要升级到JDK7。另外，他的稳定性也暂时没有保障，没人知道是否会出现致命的错误。因此还不到将其正式应用的时候 在未来的某一天，等到JDK7真正稳定了（这不是说他现在不稳定），并且WAS针对JDK7进行优化后，G1 GC最终能够按照预期的那样工作了，我们可能就不需要在进行GC优化了。 想了解GC优化的更多内容，请登录Slideshare.com查看关联资源。强烈推荐Everything I Ever Learned About JVM Performance Tuning @Twitter。作者Attila Szegedi，一位Twitter工程师。请花些时间阅读。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p014.html":{"url":"article/p014.html","title":"成为Java GC专家(4)：Apache的MaxClients参数详解及其在Tomcat执行FullGC时的影响","keywords":"","body":"成为Java GC专家(4)：Apache的MaxClients参数详解及其在Tomcat执行FullGC时的影响 英文原文 这是“成为Java GC专家系列文章”的第四篇。 在第一篇文章 《成为Java GC专家(1)：深入浅出Java垃圾回收机制》 中我们学习了不同GC算法的执行过程，GC如何工作，新生代及老年代的基本概念，在JDK7中你应该了解的5种GC类型以及他们的性能如何。 在第二篇文章 《成为Java GC专家(2)：如何监控Java垃圾回收机制》 中我们学到了JVM到底是如何执行垃圾回收，我们如何监控GC，以及那些工具可以使得监控过程更高效。 在第三篇文章 《成为Java GC专家(3)：如何优化Java垃圾回收机制》 中我们通过实际的例子学到了一些可以优化GC的参数。同时我们讲解了如何减少对象被转移到老年代空间，如何缩短Full GC时间，以及如何设置GC类型及内存空间。 在第四篇文章中，我们将阐述Apache中MaxClients 参数的重要性，以及他如何在GC发生时，显著地影响整个系统的性能。我将提供几个例子以方便你理解MaxClients 导致的问题。同时我还会说明如何根据系统的内存情况，设置最佳的MaxClients参数值。 MaxClients对于系统的影响 NHN (译者注：NHN是作者工作的公司)服务的执行环境中存在一组Throttle valve-type参数（译者注：节流阀参数，用于控制系统负载）。这些参数对于系统来说十分重要。下面我们看一下Apache的 MaxClients 参数在Full GC 发生时是如何影响系统的。 大部分开发人员都知道在由于GC发生而导致的”停止世界现象(STW) “（详细请参见Understanding Java Garbage Collection）。尤其是，NHN的Java开发人员经常会遇到由于GC原因导致的Tomcat报错。由于Java 虚拟机 (JVM)管理着内存，以Java为基础的程序无法摆脱GC导致的STW现象。假如在某一个时间，当你正在操作你开发的应用时，GC开始执行。即使TTS错误没有发生，你的服务也会给客户展现未预期的503错误。 服务执行环境 由于架构本身的特点，相比较而言纵向扩展，Web服务更适合横向扩展（译者注:增加服务器的数量，而不是提高件配置）。因此，总体来讲，物理设备会根据性能要求被配置成1台Apache+n台Tomcat。但是本文假设我们的环境是1台Apache+一台Tomcat同时安装在一台主机行，如下图所示。 图1：本文假射的服务执行环境 仅供参考，本文描述的参数基于Apache 2.2.21 (prefork MPM)，Tomcat 6.0.35，CentOS 4.72 (32-bit)，jdk 1.6.0_24。 系统可用内存2GB，垃圾收集器使用ParallelOldGC，AdaptiveSizePolicy 采用默认的设置true，堆内存空间600M。 STW 和HTTP 503 让我们假设访问Apache的请求为 200 req/s且有10个httpd进程在运行，另外我们暂时不考虑每个请求的响应时间。在这种前提下，我们假设由于full GC导致的暂停时间为1秒。当Full GC发生的时候Tomcat会怎样？ 第一件进入你脑海的事情应该是Tomcat会因为full GC而停止响应任何请求。在这种情况下，当Tomcat暂停相应请求时Apache会发生什么？ 当Tomcat暂停时，请求会以200 req/s的速度不断的涌入Apache。一般来说，在Full GC发生之前，请求的响应可以快速地被10个或更多的httpd进程处理掉。但是，因为Tomcat暂停了，httpd进程会被不停地创建以相应新进请求。直到超过 httpd.conf 文件中定义 MaxClients 为止。由于默认值为256，Apache不会在乎请求以200 req/s的速度涌入。 这时，新创建的httpd线程将如何呢？ Httpd进程通过d_jk块所管理的空闲的AJP连接，将请求转发给Tomcat。如果没有空闲连接，他会申请创建新的连接。但是，因为Tomcat暂停了，创建新连接的请求会被拒绝。因此这些请求会被存储在backlog队列中，数量的多少取决于rver.xml于AJP Connector的设置。 一旦请求数量超过backlog队列的空间限制。Apache就会返回拒绝连接错误。并且返回HTTP 503错误给用户。 在这种假设条件下，默认的backlog队列空间是100，而请求到达速度是200 req/s。因此，full GC导致的一秒钟的暂停会使得超过100个请求返回503错误。 这样，当Full GC结束后，backlog队列中存储的内容会被Tomcat接受并在通过工作线程处理，线程的最大数量取决于 MaxThreads 的值（默认200）。 MaxClients 与backlog 在这种情况下，设定哪个参数可以避免返回给用户503错误呢？ 首先，我们应该知道backlog的值要够大，以至于能够容纳所有因为Full GC导致暂停期间涌入的请求。换句话说太应该不小于200。 那么，这么设置之后会不会产生新的问题呢？ 让我们假设将backlog设置为200后再重复一下上面的过程。得到的结果比之前更加严重。系统内存使用量一般情况下为50%，但是，在发生Full GC时快速增加到100%，同时导致交换内存空间快速增加，更为严重的是导致Full GC的暂停时间从1秒变成了4秒甚至更多，系统在此期间完全宕机，不能响应任何请求。 在第一种情况下，只有100或更多的请求返回503错误。但是，当我们把backlog调整到200后，超过500个请求会挂起3秒甚至更多地时间无法得到应答 上面这个例子可以很好的说明当你没有完全理解各个设置之间的内在关系时（例如，对于系统的影响），盲目修改系统会导致什么后果。 那么，为什么会产生这个现象呢？ 问题的根源在于 MaxClients 参数的特性。 将 MaxClients 设置为一个很大的值本身没有问题，但最重要的是在设定 MaxClients 参数时，你要确保即使等同于 MaxClients 数量的httpd进程被同时创建，内存使用量也不会超过80%。 系统的内存交换参数一般被设定为60（默认）。因此，当内存使用量超过80%时，就会进行内存交换。 让我们再来看一下为什么这个特性会导致上面那个严重的问题。当请求以200 req/s的速度涌向Tomcat时，Tomcat由于full GC暂停了。此时backlog被设置为200。Apache大约创建100个httpd进程。在这种情况下，一旦内存使用量超过80%，操作系统会激活交换内存区域，并且由于系统认为JVM的老年代中的对象在很长一段时间内未被使用，而将他们移动到交换区域。 最终的结果是，GC使用了内存交换空间，暂停时间剧增。因此httpd进程数进一步增加。从而导致上面描述的内存使用量达到100%的情况。 这两个场合的唯一区别就是backlog的值：100 vs.200。为什么只在200的情况下发生？ 两者不同的原因在于创建的httpd进程的数量。当backlog设置为100时并且Full GC发生时，会创建100个请求的连接并保存在backlog队列中。其他请求得到拒绝连接错误信息并发挥503错误。因此，总的httpd 进程数量仅仅会略高于100。 而当backlog被设置为200时，200个请求会创建连接，因此。总的httpd进程数会多于200。这样超过阀值，从而导致内存交换的发生。 紧接着，不考虑内存使用量而的设定 MaxClients 参数，Full GC导致httpd进程数量暴增，引发内存交换，降低系统性能。 MaxClients参数的计算公式 如果系统的内存使2GB，MaxClients 的值在任何情况下都不应该超过内存的80%（1.6GB），以避免由于内存交换导致的性能下降。换句话说。1.6GB的内存应该共享和分配给Apache，Tomcat以及那些默认被安装的代理程序。 让我们假设代理程序被默认安装在系统，并占用了200m内存，对于Tomcat堆内存的-Xmx 被设定为 600m。因此根据top命令的结果，Tomcat会一直占用725m（Perm Gen + Native Heap Area）。最终Apache可以使用700m内存空间。如下所示。 图2：测试系统的top截屏 如上所述，我们将内存设为700m后MaxClients 应该是多少呢？ 这要取决于加载模块的数量，对于NHN Web服务来说。Apache只是个简单的代理转发，每个httpd线程4m内存（根据top命令的结果）足以（参见图2）。因此。700m内存对应的 MaxClients应该是175。 总结 一个健壮的服务配置至少应该能够降低在服务过载时宕机的时间，在合理的范围内成功的应答请求。针对基于Java的Web服务。你必须检查你的服务在Full GC导致的STW时间内能否稳定的响应请求。 为了响应更多的用户请求和应对DDoS攻击，在没有全面考虑系统内存等因素的情况下，贸然地将 MaxClients设置为一个很大的值，那么它将失去作为阀值的功能，而导致系统出现更严重的问题。 本文提到的情况只会持续3-5秒，因此绝大多数传统的监控工具都无法及时的发现。 Everything you need to prepare for your technical interview.modified at 2019-01-21 "},"article/p015.html":{"url":"article/p015.html","title":"面向对象的六大原则","keywords":"","body":"面向对象的六大原则 单一职责原则——SRP 开闭原则——OCP 里式替换原则——LSP 依赖倒置原则——DIP 接口隔离原则——ISP 迪米特原则——LOD 单一职责原则SRP(Single Responsibility Principle) 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。 单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。如果一个类负责了方法M1,方法M2两个不同的事情，当M1方法发生变化的时候，我们需要修改这个类的M1方法，但是这个时候就有可能导致M2方法不能工作。这个不是我们期待的，但是由于这种设计却很有可能发生。所以这个时候，我们需要把M1方法，M2方法单独分离成两个类。让每个类只专心处理自己的方法。 单一职责原则的好处如下： 可以降低类的复杂度，一个类只负责一项职责，这样逻辑也简单很多 提高类的可读性，和系统的维护性，因为不会有其他奇怪的方法来干扰我们理解这个类的含义 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。 开放封闭原则OCP(Open－Close Principle) 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。 开闭原则和单一职责原则一样，是非常基础而且一般是常识的原则。开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。 当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。 这个准则和单一职责原则一样，是一个大家都这样去认为但是又没规定具体该如何去做的一种原则。 开闭原则我们可以用一种方式来确保他，我们用抽象去构建框架，用实现扩展细节。这样当发生修改的时候，我们就直接用抽象了派生一个具体类去实现修改。 里式替换原则LSP(the Liskov Substitution Principle LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。 里氏替换原则是一个非常有用的一个概念。他的定义 如果对每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有对象o1都替换成o2的时候，程序P的行为都没有发生变化，那么类型T2是类型T1的子类型。 这样说有点复杂，其实有一个简单的定义 所有引用基类的地方必须能够透明地使用其子类的对象。 里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类可以增加自己独有的方法。 当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。 里氏替换原则之所以这样要求是因为继承有很多缺点，他虽然是复用代码的一种方法，但同时继承在一定程度上违反了封装。父类的属性和方法对子类都是透明的，子类可以随意修改父类的成员。这也导致了，如果需求变更，子类对父类的方法进行一些复写的时候，其他的子类无法正常工作。所以里氏替换法则被提出来。 确保程序遵循里氏替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，然后用实现去扩展细节，这个是不是很耳熟，对，里氏替换原则和开闭原则往往是相互依存的。 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。 依赖倒置原则指的是一种特殊的解耦方式，使得高层次的模块不应该依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。 这也是一个让人难懂的定义，他可以简单来说就是： 高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 在Java 中抽象指的是接口或者抽象类，两者皆不能实例化。而细节就是实现类，也就是实现了接口或者继承了抽象类的类。他是可以被实例化的。高层模块指的是调用端，底层模块是具体的实现类。在Java中，依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的。这就是俗称的面向接口编程。 我们下面有一个例子来讲述这个问题。这个例子是工人用锤子来修理东西。我们的代码如下： public class Hammer { public String function(){ return \"用锤子修理东西\"; } } public class Worker { public void fix(Hammer hammer){ System.out.println(\"工人\" + hammer.function()); } public static void main(String[] args) { new Worker().fix(new Hammer()); } } 这个是一个很简单的例子，但是如果我们要新增加一个功能，工人用 螺丝刀来修理东西，在这个类，我们发现是很难做的。因为我们Worker类依赖于一个具体的实现类Hammer。所以我们用到面向接口编程的思想，改成如下的代码： public interface Tools { public String function(); } 然后我们的Worker是通过这个接口来于其他细节类进行依赖。代码如下： public class Worker { public void fix(Tools tool){ System.out.println(\"工人\" + tool.function()); } public static void main(String[] args) { new Worker().fix(new Hammer()); new Worker().fix(new Screwdriver()); } } 我们的Hammer类与Screwdriver类实现这个接口 public class Hammer implements Tools{ public String function(){ return \"用锤子修理东西\"; } } public class Screwdriver implements Tools{ @Override public String function() { return \"用螺丝刀修理东西\"; } } 这样，通过面向接口编程，我们的代码就有了很高的扩展性，降低了代码之间的耦合度，提高了系统的稳定性。 接口分离原则ISP(the Interface Segregation Principle ISP) 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来 接口隔离原则的定义是 客户端不应该依赖他不需要的接口 换一种说法就是类间的依赖关系应该建立在最小的接口上。这样说好像更难懂。我们通过一个例子来说明。我们知道在Java中一个具体类实现了一个接口，那必然就要实现接口中的所有方法。如果我们有一个类A和类B通过接口I来依赖，类B是对类A依赖的实现，这个接口I有5个方法。但是类A与类B只通过方法1,2,3依赖，然后类C与类D通过接口I来依赖，类D是对类C依赖的实现但是他们却是通过方法1,4,5依赖。那么是必在实现接口的时候，类B就要有实现他不需要的方法4和方法5 而类D就要实现他不需要的方法2，和方法3。这简直就是一个灾难的设计。 所以我们需要对接口进行拆分，就是把接口分成满足依赖关系的最小接口，类B与类D不需要去实现与他们无关接口方法。比如在这个例子中，我们可以把接口拆成3个，第一个是仅仅由方法1的接口，第二个接口是包含2,3方法的，第三个接口是包含4,5方法的。 这样，我们的设计就满足了接口隔离原则。 以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。 迪米特原则LOD(the Law of Demeter LOD) 迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。他的定义： 一个对象应该对其他对象保持最小的了解。 因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。 迪米特法则还有一个更简单的定义 只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 这里我们可以用一个现实生活中的例子来讲解一下。比如我们需要一张CD,我们可能去音像店去问老板有没有我们需要的那张CD，老板说现在没有，等有的时候你们来拿就行了。在这里我们不需要关心老板是从哪里，怎么获得的那张CD，我们只和老板（直接朋友）沟通，至于老板从他的朋友那里通过何种条件得到的CD，我们不关心，我们不和老板的朋友（陌生人）进行通信，这个就是迪米特的一个应用。说白了，就是一种中介的方式。我们通过老板这个中介来和真正提供CD的人发生联系。 总结 到这里，面向对象的六大原则，就写完了。我们看出来，这些原则其实都是应对不断改变的需求。每当需求变化的时候，我们利用这些原则来使我们的代码改动量最小，而且所造成的影响也是最小的。但是我们在看这些原则的时候，我们会发现很多原则并没有提供一种公式化的结论，而即使提供了公式化的结论的原则也只是建议去这样做。这是因为，这些设计原则本来就是从很多实际的代码中提取出来的，他是一个经验化的结论。怎么去用它，用好他，就要依靠设计者的经验。否则一味者去使用设计原则可能会使代码出现过度设计的情况。大多数的原则都是通过提取出抽象和接口来实现，如果发生过度的设计，就会出现很多抽象类和接口，增加了系统的复杂度。让本来很小的项目变得很庞大，当然这也是Java的特性（任何的小项目都会做成中型的项目）。 Everything you need to prepare for your technical interview.modified at 2019-01-17 "},"article/p016.html":{"url":"article/p016.html","title":"Java集合专题总结","keywords":"","body":"Java集合专题总结 Java 8 对 HashMap 的改进 如果说Java的hashmap是数组+链表，那么JDK 8之后就是数组+链表+红黑树组成了hashmap。之前的实现机制和原理在下面12-12期整理过，这次只说下新加的红黑树机制。 在之前谈过，如果hash算法不好，会使得hash表蜕化为顺序查找，即使负载因子和hash算法优化再多，也无法避免出现链表过长的情景（这个概论虽然很低），于是在JDK1.8中，对hashmap做了优化，引入红黑树。具体原理就是当hash表中每个桶附带的链表长度默认超过8时，链表就转换为红黑树结构，提高HashMap的性能，因为红黑树的增删改是O(logn)，而不是O(n)。 红黑树的具体原理和实现以后再总结。 主要看put方法实现 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 封装了一个final方法，里面用到一个常量，具体用处看源码： static final int TREEIFY_THRESHOLD = 8; 下面是具体源代码注释: final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; // 首先判断hash表是否是空的，如果空，则resize扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 通过key计算得到hash表下标，如果下标处为null， // 就新建链表头结点，在方法最后插入即可 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果下标处已经存在节点，则进入到这里 else { Node e; K k; // 先看hash表该处的头结点是否和key一样 // （hashcode和equals比较），一样就更新 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // hash表头结点和key不一样，则判断节点是不是红黑树， // 是红黑树就按照红黑树处理 else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); // 如果不是红黑树，则按照之前的hashmap原理处理 else { // 遍历链表 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // -1 for 1st (原jdk注释) 显然当链表长度大于等于7的时候， // 也就是说大于8的话，就转化为红黑树结构，针对红黑树进行插入 //（logn复杂度） if (binCount >= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // existing mapping for key if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果超过容量，即扩容 if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } resize是新的扩容方法，之前谈过，扩容原理是使用新的（2倍旧长度）的数组代替，把旧数组的内容放到新数组，需要重新计算hash和计算hash表的位置，非常耗时，但是自从 JDK 1.8 对hashmap 引入了红黑树，它和之前的扩容方法有了改进。 扩容方法的改进 final Node[] resize() { Node[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 如果长度没有超过最大值，则扩容为2倍的关系 else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) // double threshold newThr = oldThr 0) newCap = oldThr; // zero initial threshold signifies using defaults else { newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; table = newTab; // 进行新旧元素的转移过程 if (oldTab != null) { for (int j = 0; j e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode)e).split(this, newTab, j, oldCap); // preserve order（原注释） 如果不是红黑树的情况这里改进了， // 没有rehash的过程，如下分别记录链表的头尾 else { Node loHead = null, loTail = null; Node hiHead = null, hiTail = null; Node next; do { next = e.next; if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 因为有这样一个特点：比如hash表的长度是16，那么15对应二进制是： 0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 扩容之前有两个key，分别是k1和k2： k1的hash： 0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 k2的hash： 0000 0000， 0000 0000， 0000 0000， 0001 1111 = 15 hash值和15模得到： k1：0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 k2：0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 扩容之后表长对应为32，则31二进制： 0000 0000， 0000 0000， 0000 0000， 0001 1111 = 31 重新hash之后得到： k1：0000 0000， 0000 0000， 0000 0000， 0000 1111 = 15 k2：0000 0000， 0000 0000， 0000 0000， 0001 1111 = 31 = 15 + 16 观察发现：如果扩容后新增的位是0，那么rehash索引不变，否则才会改变，并且变为原来的索引+旧hash表的长度，故我们只需看原hash表长新增的bit是1还是0，如果是0，索引不变，如果是1，索引变成原索引+旧表长，根本不用像JDK 7 那样rehash，省去了重新计算hash值的时间，而且新增的bit是0还是1可以认为是随机的，因此resize的过程，还能均匀的把之前的冲突节点分散。 故JDK 8对HashMap的优化是非常到位的。 jdk 1.8之前的HashMap实现 Set和List接口是Collection接口的子接口，分别代表无序集合和有序集合，Queue是Java提供的队列实现。 Map用于保存具有key-value映射关系的数据 Java 中有四种常见的Map实现——HashMap, TreeMap, Hashtable和LinkedHashMap： HashMap就是一张hash表，键和值都没有排序。 TreeMap以红黑树结构为基础，键值可以设置按某种顺序排列。 LinkedHashMap保存了插入时的顺序。 Hashtable是同步的(而HashMap是不同步的)。所以如果在线程安全的环境下应该多使用HashMap，而不是Hashtable，因为Hashtable对同步有额外的开销，不过JDK 5之后的版本可以使用conncurrentHashMao代替HashTable。 本文重点总结HashMap，HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 HashMap是非线程安全的，只用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。 HashMap 实现了Serializable接口，因此它支持序列化。 HashMap还实现了Cloneable接口，故能被克隆。 HashMap原理和一些注意点 HashMap的存储结构 紫色部分即代表哈希表本身（其实是一个数组），数组的每个元素都是一个单链表的头节点，链表是用来解决hash地址冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中保存。 HashMap构造方法参数：初始容量和加载因子 这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（默认为16），加载因子是哈希表当前key的数量和容量的比值，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表提前进行 resize 操作（即扩容）。如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），严重浪费。 JDK开发者规定的默认加载因子为0.75，因为这是一个比较理想的值。另外，无论指定初始容量为多少，构造方法都会将实际容量设为不小于指定容量的2的幂次方，且最大值不能超过2的30次方。 HashMap中put、get的源码分析 get方法源码 // 获取key对应的value public V get(Object key) { if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; // 判断key是否相同 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) return e.value; } // 没找到则返回null return null; } // 获取“key为null”的元素的值，HashMap将“key为null”的元素存储在table[0]位置， // 但不一定是该链表的第一个位置！ private V getForNullKey() { for (Entry e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } 首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。 put方法源码 // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; // 将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; } 如果key为null，则将其添加到table[0]对应的链表中，如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，且将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下： // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ >= threshold) resize(2 * table.length); } 注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。 求hash值和索引值的方法 重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列 由hash值找到对应索引的方法如下： static int indexFor(int h, int length) { return h & (length-1); } 因为容量初始还是设定都会转化为2的幂次。故可以使用高效的位与运算替代模运算。下面会解释原因。 计算hash值的方法如下 static int hash(int h) { h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } JDK 的 HashMap 使用了一个 hash 方法对hash值使用位的操作，使hash值的计算效率很高。为什么这样做？主要是因为如果直接使用hashcode值，那么这是一个int值（8个16进制数，共32位），int值的范围正负21亿多，但是hash表没有那么长，一般比如初始16，自然散列地址需要对hash表长度取模运算，得到的余数才是地址下标。假设某个key的hashcode是0AAA0000，hash数组长默认16，如果不经过hash函数处理，该键值对会被存放在hash数组中下标为0处，因为0AAA0000 & (16-1) = 0。过了一会儿又存储另外一个键值对，其key的hashcode是0BBB0000，得到数组下标依然是0，这就说明这是个实现得很差的hash算法，因为hashcode的1位全集中在前16位了，导致算出来的数组下标一直是0。于是明明key相差很大的键值对，却存放在了同一个链表里，导致以后查询起来比较慢（蜕化为了顺序查找）。故JDK的设计者使用hash函数的若干次的移位、异或操作，把hashcode的“1位”变得“松散”，非常巧妙。 几个常见的面试题 说下hashmap的 扩容机制？ 前面说了，hashmap的构造器里指明了两个对于理解HashMap比较重要的两个参数 int initialCapacity, float loadFactor,这两个参数会影响HashMap效率，HashMap底层采用的散列数组实现，利用initialCapacity这个参数我们可以设置这个数组的大小，也就是散列桶的数量，但是如果需要Map的数据过多，在不断的add之后，这些桶可能都会被占满，这是有两种策略，一种是不改变Capacity，因为即使桶占满了，我们还是可以利用每个桶附带的链表增加元素。但是这有个缺点，此时HaspMap就退化成为了LinkedList，使get和put方法的时间开销上升，这是就要采用另一种方法：增加Hash桶的数量，这样get和put的时间开销又回退到近于常数复杂度上。Hashmap就是采用的该方法。 关于扩容。看hashmap的扩容方法，resize方法，它的源码如下： // 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int) (newCapacity * loadFactor); } 很明显，是从新建了一个HashMap的底层数组，长度为原来的两倍，而后调用transfer方法，将旧HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下： // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j e = src[j]; if (e != null) { src[j] = null; do { Entry next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。 hashmap什么时候需要增加容量呢？ 因为效率问题，JDK采用预处理法，这时前面说的loadFactor就派上了用场，当size > initialCapacity * loadFactor，hashmap内部resize方法就被调用，使得重新扩充hash桶的数量，在目前的实现中，是增加一倍，这样就保证当你真正想put新的元素时效率不会明显下降。所以一般情况下HashMap并不存在键值放满的情况。当然并不排除极端情况，比如设置的JVM内存用完了，或者这个HashMap的Capacity已经达到了MAXIMUM_CAPACITY（目前的实现是2^30）。 initialCapacity和loadFactor参数设什么样的值好呢？ initialCapacity的默认值是16，有些人可能会想如果内存足够，是不是可以将initialCapacity设大一些，即使用不了这么大，就可避免扩容导致的效率的下降，反正无论initialCapacity大小，我们使用的get和put方法都是常数复杂度的。这么说没什么不对，但是可能会忽略一点，实际的程序可能不仅仅使用get和put方法，也有可能使用迭代器，如initialCapacity容量较大，那么会使迭代器效率降低。所以理想的情况还是在使用HashMap前估计一下数据量。 加载因子默认值是0.75，是JDK权衡时间和空间效率之后得到的一个相对优良的数值。如果这个值过大，虽然空间利用率是高了，但是对于HashMap中的一些方法的效率就下降了，包括get和put方法，会导致每个hash桶所附加的链表增长，影响存取效率。如果比较小，除了导致空间利用率较低外没有什么坏处，只要有的是内存，毕竟现在大多数人把时间看的比空间重要。但是实际中还是很少有人会将这个值设置的低于0.5。 HashMap的key和value都能为null么？如果k能为null，那么它是怎么样查找值的？ 如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中。 HashMap中put值的时候如果发生了冲突，是怎么处理的？ JDK使用了链地址法，hash表的每个元素又分别链接着一个单链表，元素为头结点，如果不同的key映射到了相同的下标，那么就使用头插法，插入到该元素对应的链表。 HashMap的key是如何散列到hash表的？相比较HashTable有什么改进？ 我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除留余数法），HashTable就是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，且hashtable直接使用了hashcode值，没有重新计算。 HashMap中则通过 h&(length-1) 的方法来代替取模，其中h是key的hash值，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。 接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。 首先，length为2的整数次幂的话，h&(length-1) 在数学上就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率； 其次，length为2的整数次幂的话，则一定为偶数，那么 length-1 一定为奇数，奇数的二进制的最后一位是1，这样便保证了 h&(length-1) 的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀，而如果length为奇数的话，很明显 length-1 为偶数，它的最后一位是0，这样 h&(length-1) 的最后一位肯定为0，即只能为偶数，这样导致了任何hash值都只会被散列到数组的偶数下标位置上，浪费了一半的空间，因此length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。 讨论一下Hashtable HashTable同样是基于哈希表实现的，其实类似HashMap，只不过有些区别，HashTable同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 HashTable比较古老， 是JDK1.0就引入的类，而HashMap 是 1.2 引进的 Map 的一个实现。 HashTable 是线程安全的，能用于多线程环境中。Hashtable同样也实现了Serializable接口，支持序列化，也实现了Cloneable接口，能被克隆。 Hashtable继承于Dictionary类，实现了Map接口。Dictionary是声明了操作\"键值对\"函数接口的抽象类。 有一点注意，HashTable除了线程安全之外（其实是直接在方法上增加了synchronized关键字，比较古老，落后，低效的同步方式），还有就是它的key、value都不为null。另外Hashtable 也有 初始容量 和 加载因子。 public Hashtable() { this(11, 0.75f); } 默认加载因子也是 0.75，HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。因为HashTable是直接使用除留余数法定位地址。且Hashtable计算hash值，直接用key的hashCode()。 还要注意：前面说了Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但如在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。 最后针对扩容：Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 几个常见的笔试，面试题 HashTable和HashMap的区别有哪些？ HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 理解HashMap是Hashtable的轻量级实现（非线程安全的实现，hashtable是非轻量级，线程安全的），都实现Map接口，主要区别在于： 由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。 Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。 Hashtable和HashMap扩容的方法不一样，HashTable中hash数组默认大小11，扩容方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数，增加为原来的2倍，没有加1。 两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。 为什么HashMap是线程不安全的，实际会如何体现？ 第一，如果多个线程同时使用put方法添加元素 假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。 第二，如果多个线程同时检测到元素个数超过数组大小*loadFactor 这样会发生多个线程同时对hash数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。且会引起死循环的错误。 能否让HashMap实现线程安全，如何做？ 1、直接使用Hashtable，但是当一个线程访问HashTable的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以，效率很低，现在基本不会选择它了。 2、HashMap可以通过下面的语句进行同步： Collections.synchronizeMap(hashMap); 3、直接使用JDK 5 之后的 ConcurrentHashMap，如果使用Java 5或以上的话，请使用ConcurrentHashMap。 Collections.synchronizeMap(hashMap);又是如何保证了HashMap线程安全？ 直接分析源码吧 // synchronizedMap方法 public static Map synchronizedMap(Map m) { return new SynchronizedMap<>(m); } // SynchronizedMap类 private static class SynchronizedMap implements Map, Serializable { private static final long serialVersionUID = 1978198479659022715L; private final Map m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map m) { this.m = Objects.requireNonNull(m); mutex = this; } SynchronizedMap(Map m, Object mutex) { this.m = m; this.mutex = mutex; } public int size() { synchronized (mutex) {return m.size();} } public boolean isEmpty() { synchronized (mutex) {return m.isEmpty();} } public boolean containsKey(Object key) { synchronized (mutex) {return m.containsKey(key);} } public boolean containsValue(Object value) { synchronized (mutex) {return m.containsValue(value);} } public V get(Object key) { synchronized (mutex) {return m.get(key);} } public V put(K key, V value) { synchronized (mutex) {return m.put(key, value);} } public V remove(Object key) { synchronized (mutex) {return m.remove(key);} } // 省略其他方法 } 从源码中看出 synchronizedMap()方法返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized来保证对Map的操作是线程安全的，故效率其实也不高。 为什么HashTable的默认大小和HashMap不一样？ 前面分析了，Hashtable 的扩容方法是乘2再+1，不是简单的乘2，故hashtable保证了容量永远是奇数，结合之前分析hashmap的重算hash值的逻辑，就明白了，因为在数据分布在等差数据集合(如偶数)上时，如果公差与桶容量有公约数 n，则至少有(n-1)/n 数量的桶是利用不到的，故之前的hashmap 会在取模（使用位与运算代替）哈希前先做一次哈希运算，调整hash值。这里hashtable比较古老，直接使用了除留余数法，那么就需要设置容量起码不是偶数（除（近似）质数求余的分散效果好）。而JDK开发者选了11。 Everything you need to prepare for your technical interview.modified at 2019-01-24 "}}